{"ast":null,"code":"import _asyncToGenerator from \"/Users/bharris/Code/audio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nexport let AudioSeparationService = /*#__PURE__*/(() => {\n  class AudioSeparationService {\n    constructor() {\n      this.ctx = new AudioContext();\n      this.lastTargetRemoved = null;\n    }\n    decodeFile(file) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const arrayBuf = yield file.arrayBuffer();\n        return yield _this.ctx.decodeAudioData(arrayBuf.slice(0));\n      })();\n    }\n    fetchAndDecode(url) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const res = yield fetch(url);\n        if (!res.ok) throw new Error('HTTP ' + res.status);\n        const arr = yield res.arrayBuffer();\n        return yield _this2.ctx.decodeAudioData(arr.slice(0));\n      })();\n    }\n    removeStem(buffer, target, onProgress) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        _this3.lastTargetRemoved = target;\n        const sampleRate = buffer.sampleRate;\n        const offline = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, sampleRate);\n        // Copy original into buffer source\n        const source = offline.createBufferSource();\n        const clone = offline.createBuffer(buffer.numberOfChannels, buffer.length, sampleRate);\n        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {\n          clone.copyToChannel(buffer.getChannelData(ch), ch);\n        }\n        source.buffer = clone;\n        // Stem specific processing graph\n        let node = source;\n        switch (target) {\n          case 'vocals':\n            {\n              // Center channel cancellation approximation: (L - R)\n              if (buffer.numberOfChannels >= 2) {\n                const splitter = offline.createChannelSplitter(2);\n                const inverter = offline.createGain();\n                inverter.gain.value = -1;\n                const merger = offline.createChannelMerger(2);\n                source.connect(splitter);\n                splitter.connect(merger, 0, 0); // L\n                splitter.connect(inverter, 1);\n                inverter.connect(merger, 0, 1); // -R\n                node = merger;\n                // After merging L + (-R), apply some EQ to smooth artifacts\n                const hp = offline.createBiquadFilter();\n                hp.type = 'highpass';\n                hp.frequency.value = 120;\n                const lp = offline.createBiquadFilter();\n                lp.type = 'lowpass';\n                lp.frequency.value = 12000;\n                node.connect(hp);\n                hp.connect(lp);\n                node = lp;\n              }\n              break;\n            }\n          case 'bass':\n            {\n              // Remove low end using a high-pass filter\n              const hp = offline.createBiquadFilter();\n              hp.type = 'highpass';\n              hp.frequency.value = 180;\n              hp.Q.value = 0.7;\n              node.connect(hp);\n              node = hp;\n              break;\n            }\n          case 'guitar':\n            {\n              // Notch out mid bands where guitars often sit\n              const b1 = offline.createBiquadFilter();\n              b1.type = 'notch';\n              b1.frequency.value = 800;\n              b1.Q.value = 4;\n              const b2 = offline.createBiquadFilter();\n              b2.type = 'notch';\n              b2.frequency.value = 1500;\n              b2.Q.value = 4;\n              const b3 = offline.createBiquadFilter();\n              b3.type = 'notch';\n              b3.frequency.value = 3000;\n              b3.Q.value = 6;\n              node.connect(b1);\n              b1.connect(b2);\n              b2.connect(b3);\n              node = b3;\n              break;\n            }\n          case 'drums':\n            {\n              // Crude transient damping via lowpass + mild dynamics (manual)\n              const lp = offline.createBiquadFilter();\n              lp.type = 'lowpass';\n              lp.frequency.value = 6000;\n              lp.Q.value = 0.5;\n              const hp = offline.createBiquadFilter();\n              hp.type = 'highpass';\n              hp.frequency.value = 120;\n              hp.Q.value = 0.7;\n              node.connect(lp);\n              lp.connect(hp);\n              node = hp;\n              break;\n            }\n        }\n        // Blend: For demonstration we just output processed path. Real separation would subtract from original.\n        const gain = offline.createGain();\n        gain.gain.value = 1.0;\n        node.connect(gain);\n        gain.connect(offline.destination);\n        source.start();\n        const total = buffer.length;\n        // Provide fake progress updates (OfflineAudioContext doesn't give granular progress)\n        if (onProgress) {\n          for (let i = 0; i < 5; i++) {\n            yield new Promise(r => setTimeout(r, 80));\n            onProgress(Math.min(0.95, (i + 1) / 6));\n          }\n        }\n        const rendered = yield offline.startRendering();\n        onProgress?.(1);\n        return rendered;\n      })();\n    }\n    static {\n      this.ɵfac = function AudioSeparationService_Factory(t) {\n        return new (t || AudioSeparationService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: AudioSeparationService,\n        factory: AudioSeparationService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return AudioSeparationService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}