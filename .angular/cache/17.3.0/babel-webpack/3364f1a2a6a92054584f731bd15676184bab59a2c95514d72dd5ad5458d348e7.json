{"ast":null,"code":"import _asyncToGenerator from \"/Users/bharris/Code/audio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/bharris/Code/audio/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n/*!\n * ONNX Runtime Web v1.20.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Hd = Object.create;\nvar an = Object.defineProperty;\nvar qd = Object.getOwnPropertyDescriptor;\nvar jd = Object.getOwnPropertyNames;\nvar Xd = Object.getPrototypeOf,\n  Kd = Object.prototype.hasOwnProperty;\nvar Co = (i => typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(i, {\n  get: (e, o) => (typeof require < \"u\" ? require : e)[o]\n}) : i)(function (i) {\n  if (typeof require < \"u\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + i + '\" is not supported');\n});\nvar O = (i, e) => () => (i && (e = i(i = 0)), e);\nvar mt = (i, e) => () => (e || i((e = {\n    exports: {}\n  }).exports, e), e.exports),\n  Or = (i, e) => {\n    for (var o in e) an(i, o, {\n      get: e[o],\n      enumerable: !0\n    });\n  },\n  Qa = (i, e, o, t) => {\n    if (e && typeof e == \"object\" || typeof e == \"function\") for (let r of jd(e)) !Kd.call(i, r) && r !== o && an(i, r, {\n      get: () => e[r],\n      enumerable: !(t = qd(e, r)) || t.enumerable\n    });\n    return i;\n  };\nvar rr = (i, e, o) => (o = i != null ? Hd(Xd(i)) : {}, Qa(e || !i || !i.__esModule ? an(o, \"default\", {\n    value: i,\n    enumerable: !0\n  }) : o, i)),\n  sn = i => Qa(an({}, \"__esModule\", {\n    value: !0\n  }), i);\nvar un,\n  ke,\n  nr,\n  Jd,\n  ln,\n  fn = O(() => {\n    \"use strict\";\n\n    un = new Map(), ke = [], nr = (i, e, o) => {\n      if (e && typeof e.init == \"function\" && typeof e.createInferenceSessionHandler == \"function\") {\n        let t = un.get(i);\n        if (t === void 0) un.set(i, {\n          backend: e,\n          priority: o\n        });else {\n          if (t.priority > o) return;\n          if (t.priority === o && t.backend !== e) throw new Error(`cannot register backend \"${i}\" using priority ${o}`);\n        }\n        if (o >= 0) {\n          let r = ke.indexOf(i);\n          r !== -1 && ke.splice(r, 1);\n          for (let n = 0; n < ke.length; n++) if (un.get(ke[n]).priority <= o) {\n            ke.splice(n, 0, i);\n            return;\n          }\n          ke.push(i);\n        }\n        return;\n      }\n      throw new TypeError(\"not a valid backend\");\n    }, Jd = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (i) {\n        let e = un.get(i);\n        if (!e) return \"backend not found.\";\n        if (e.initialized) return e.backend;\n        if (e.aborted) return e.error;\n        {\n          let o = !!e.initPromise;\n          try {\n            return o || (e.initPromise = e.backend.init(i)), yield e.initPromise, e.initialized = !0, e.backend;\n          } catch (t) {\n            return o || (e.error = `${t}`, e.aborted = !0), e.error;\n          } finally {\n            delete e.initPromise;\n          }\n        }\n      });\n      return function Jd(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }(), ln = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (i) {\n        let e = i.executionProviders || [],\n          o = e.map(u => typeof u == \"string\" ? u : u.name),\n          t = o.length === 0 ? ke : o,\n          r,\n          n = [],\n          s = new Set();\n        for (let u of t) {\n          let l = yield Jd(u);\n          typeof l == \"string\" ? n.push({\n            name: u,\n            err: l\n          }) : (r || (r = l), r === l && s.add(u));\n        }\n        if (!r) throw new Error(`no available backend found. ERR: ${n.map(u => `[${u.name}] ${u.err}`).join(\", \")}`);\n        for (let {\n          name: u,\n          err: l\n        } of n) o.includes(u) && console.warn(`removing requested execution provider \"${u}\" from session options because it is not available: ${l}`);\n        let a = e.filter(u => s.has(typeof u == \"string\" ? u : u.name));\n        return [r, new Proxy(i, {\n          get: (u, l) => l === \"executionProviders\" ? a : Reflect.get(u, l)\n        })];\n      });\n      return function ln(_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n  });\nvar ts = O(() => {\n  \"use strict\";\n\n  fn();\n});\nvar es,\n  rs = O(() => {\n    \"use strict\";\n\n    es = \"1.20.0\";\n  });\nvar ns,\n  Gt,\n  No = O(() => {\n    \"use strict\";\n\n    rs();\n    ns = \"warning\", Gt = {\n      wasm: {},\n      webgl: {},\n      webgpu: {},\n      versions: {\n        common: es\n      },\n      set logLevel(i) {\n        if (i !== void 0) {\n          if (typeof i != \"string\" || [\"verbose\", \"info\", \"warning\", \"error\", \"fatal\"].indexOf(i) === -1) throw new Error(`Unsupported logging level: ${i}`);\n          ns = i;\n        }\n      },\n      get logLevel() {\n        return ns;\n      }\n    };\n    Object.defineProperty(Gt, \"logLevel\", {\n      enumerable: !0\n    });\n  });\nvar z,\n  os = O(() => {\n    \"use strict\";\n\n    No();\n    z = Gt;\n  });\nvar is,\n  as,\n  ss = O(() => {\n    \"use strict\";\n\n    is = (i, e) => {\n      let o = typeof document < \"u\" ? document.createElement(\"canvas\") : new OffscreenCanvas(1, 1);\n      o.width = i.dims[3], o.height = i.dims[2];\n      let t = o.getContext(\"2d\");\n      if (t != null) {\n        let r, n;\n        e?.tensorLayout !== void 0 && e.tensorLayout === \"NHWC\" ? (r = i.dims[2], n = i.dims[3]) : (r = i.dims[3], n = i.dims[2]);\n        let s = e?.format !== void 0 ? e.format : \"RGB\",\n          a = e?.norm,\n          u,\n          l;\n        a === void 0 || a.mean === void 0 ? u = [255, 255, 255, 255] : typeof a.mean == \"number\" ? u = [a.mean, a.mean, a.mean, a.mean] : (u = [a.mean[0], a.mean[1], a.mean[2], 0], a.mean[3] !== void 0 && (u[3] = a.mean[3])), a === void 0 || a.bias === void 0 ? l = [0, 0, 0, 0] : typeof a.bias == \"number\" ? l = [a.bias, a.bias, a.bias, a.bias] : (l = [a.bias[0], a.bias[1], a.bias[2], 0], a.bias[3] !== void 0 && (l[3] = a.bias[3]));\n        let f = n * r,\n          p = 0,\n          d = f,\n          y = f * 2,\n          T = -1;\n        s === \"RGBA\" ? (p = 0, d = f, y = f * 2, T = f * 3) : s === \"RGB\" ? (p = 0, d = f, y = f * 2) : s === \"RBG\" && (p = 0, y = f, d = f * 2);\n        for (let v = 0; v < n; v++) for (let S = 0; S < r; S++) {\n          let L = (i.data[p++] - l[0]) * u[0],\n            P = (i.data[d++] - l[1]) * u[1],\n            A = (i.data[y++] - l[2]) * u[2],\n            M = T === -1 ? 255 : (i.data[T++] - l[3]) * u[3];\n          t.fillStyle = \"rgba(\" + L + \",\" + P + \",\" + A + \",\" + M + \")\", t.fillRect(S, v, 1, 1);\n        }\n        if (\"toDataURL\" in o) return o.toDataURL();\n        throw new Error(\"toDataURL is not supported\");\n      } else throw new Error(\"Can not access image data\");\n    }, as = (i, e) => {\n      let o = typeof document < \"u\" ? document.createElement(\"canvas\").getContext(\"2d\") : new OffscreenCanvas(1, 1).getContext(\"2d\"),\n        t;\n      if (o != null) {\n        let r, n, s;\n        e?.tensorLayout !== void 0 && e.tensorLayout === \"NHWC\" ? (r = i.dims[2], n = i.dims[1], s = i.dims[3]) : (r = i.dims[3], n = i.dims[2], s = i.dims[1]);\n        let a = e !== void 0 && e.format !== void 0 ? e.format : \"RGB\",\n          u = e?.norm,\n          l,\n          f;\n        u === void 0 || u.mean === void 0 ? l = [255, 255, 255, 255] : typeof u.mean == \"number\" ? l = [u.mean, u.mean, u.mean, u.mean] : (l = [u.mean[0], u.mean[1], u.mean[2], 255], u.mean[3] !== void 0 && (l[3] = u.mean[3])), u === void 0 || u.bias === void 0 ? f = [0, 0, 0, 0] : typeof u.bias == \"number\" ? f = [u.bias, u.bias, u.bias, u.bias] : (f = [u.bias[0], u.bias[1], u.bias[2], 0], u.bias[3] !== void 0 && (f[3] = u.bias[3]));\n        let p = n * r;\n        if (e !== void 0 && (e.format !== void 0 && s === 4 && e.format !== \"RGBA\" || s === 3 && e.format !== \"RGB\" && e.format !== \"BGR\")) throw new Error(\"Tensor format doesn't match input tensor dims\");\n        let d = 4,\n          y = 0,\n          T = 1,\n          v = 2,\n          S = 3,\n          L = 0,\n          P = p,\n          A = p * 2,\n          M = -1;\n        a === \"RGBA\" ? (L = 0, P = p, A = p * 2, M = p * 3) : a === \"RGB\" ? (L = 0, P = p, A = p * 2) : a === \"RBG\" && (L = 0, A = p, P = p * 2), t = o.createImageData(r, n);\n        for (let V = 0; V < n * r; y += d, T += d, v += d, S += d, V++) t.data[y] = (i.data[L++] - f[0]) * l[0], t.data[T] = (i.data[P++] - f[1]) * l[1], t.data[v] = (i.data[A++] - f[2]) * l[2], t.data[S] = M === -1 ? 255 : (i.data[M++] - f[3]) * l[3];\n      } else throw new Error(\"Can not access image data\");\n      return t;\n    };\n  });\nvar Ro,\n  us,\n  ls,\n  fs,\n  cs,\n  ps,\n  ds = O(() => {\n    \"use strict\";\n\n    cn();\n    Ro = (i, e) => {\n      if (i === void 0) throw new Error(\"Image buffer must be defined\");\n      if (e.height === void 0 || e.width === void 0) throw new Error(\"Image height and width must be defined\");\n      if (e.tensorLayout === \"NHWC\") throw new Error(\"NHWC Tensor layout is not supported yet\");\n      let {\n          height: o,\n          width: t\n        } = e,\n        r = e.norm ?? {\n          mean: 255,\n          bias: 0\n        },\n        n,\n        s;\n      typeof r.mean == \"number\" ? n = [r.mean, r.mean, r.mean, r.mean] : n = [r.mean[0], r.mean[1], r.mean[2], r.mean[3] ?? 255], typeof r.bias == \"number\" ? s = [r.bias, r.bias, r.bias, r.bias] : s = [r.bias[0], r.bias[1], r.bias[2], r.bias[3] ?? 0];\n      let a = e.format !== void 0 ? e.format : \"RGBA\",\n        u = e.tensorFormat !== void 0 && e.tensorFormat !== void 0 ? e.tensorFormat : \"RGB\",\n        l = o * t,\n        f = u === \"RGBA\" ? new Float32Array(l * 4) : new Float32Array(l * 3),\n        p = 4,\n        d = 0,\n        y = 1,\n        T = 2,\n        v = 3,\n        S = 0,\n        L = l,\n        P = l * 2,\n        A = -1;\n      a === \"RGB\" && (p = 3, d = 0, y = 1, T = 2, v = -1), u === \"RGBA\" ? A = l * 3 : u === \"RBG\" ? (S = 0, P = l, L = l * 2) : u === \"BGR\" && (P = 0, L = l, S = l * 2);\n      for (let V = 0; V < l; V++, d += p, T += p, y += p, v += p) f[S++] = (i[d] + s[0]) / n[0], f[L++] = (i[y] + s[1]) / n[1], f[P++] = (i[T] + s[2]) / n[2], A !== -1 && v !== -1 && (f[A++] = (i[v] + s[3]) / n[3]);\n      return u === \"RGBA\" ? new St(\"float32\", f, [1, 4, o, t]) : new St(\"float32\", f, [1, 3, o, t]);\n    }, us = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (i, e) {\n        let o = typeof HTMLImageElement < \"u\" && i instanceof HTMLImageElement,\n          t = typeof ImageData < \"u\" && i instanceof ImageData,\n          r = typeof ImageBitmap < \"u\" && i instanceof ImageBitmap,\n          n = typeof i == \"string\",\n          s,\n          a = e ?? {},\n          u = () => {\n            if (typeof document < \"u\") return document.createElement(\"canvas\");\n            if (typeof OffscreenCanvas < \"u\") return new OffscreenCanvas(1, 1);\n            throw new Error(\"Canvas is not supported\");\n          },\n          l = f => typeof HTMLCanvasElement < \"u\" && f instanceof HTMLCanvasElement || f instanceof OffscreenCanvas ? f.getContext(\"2d\") : null;\n        if (o) {\n          let f = u();\n          f.width = i.width, f.height = i.height;\n          let p = l(f);\n          if (p != null) {\n            let d = i.height,\n              y = i.width;\n            if (e !== void 0 && e.resizedHeight !== void 0 && e.resizedWidth !== void 0 && (d = e.resizedHeight, y = e.resizedWidth), e !== void 0) {\n              if (a = e, e.tensorFormat !== void 0) throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n              a.tensorFormat = \"RGBA\", a.height = d, a.width = y;\n            } else a.tensorFormat = \"RGBA\", a.height = d, a.width = y;\n            p.drawImage(i, 0, 0), s = p.getImageData(0, 0, y, d).data;\n          } else throw new Error(\"Can not access image data\");\n        } else if (t) {\n          let f, p;\n          if (e !== void 0 && e.resizedWidth !== void 0 && e.resizedHeight !== void 0 ? (f = e.resizedHeight, p = e.resizedWidth) : (f = i.height, p = i.width), e !== void 0 && (a = e), a.format = \"RGBA\", a.height = f, a.width = p, e !== void 0) {\n            let d = u();\n            d.width = p, d.height = f;\n            let y = l(d);\n            if (y != null) y.putImageData(i, 0, 0), s = y.getImageData(0, 0, p, f).data;else throw new Error(\"Can not access image data\");\n          } else s = i.data;\n        } else if (r) {\n          if (e === void 0) throw new Error(\"Please provide image config with format for Imagebitmap\");\n          let f = u();\n          f.width = i.width, f.height = i.height;\n          let p = l(f);\n          if (p != null) {\n            let d = i.height,\n              y = i.width;\n            return p.drawImage(i, 0, 0, y, d), s = p.getImageData(0, 0, y, d).data, a.height = d, a.width = y, Ro(s, a);\n          } else throw new Error(\"Can not access image data\");\n        } else {\n          if (n) return new Promise((f, p) => {\n            let d = u(),\n              y = l(d);\n            if (!i || !y) return p();\n            let T = new Image();\n            T.crossOrigin = \"Anonymous\", T.src = i, T.onload = () => {\n              d.width = T.width, d.height = T.height, y.drawImage(T, 0, 0, d.width, d.height);\n              let v = y.getImageData(0, 0, d.width, d.height);\n              a.height = d.height, a.width = d.width, f(Ro(v.data, a));\n            };\n          });\n          throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        }\n        if (s !== void 0) return Ro(s, a);\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n      });\n      return function us(_x3, _x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }(), ls = (i, e) => {\n      let {\n          width: o,\n          height: t,\n          download: r,\n          dispose: n\n        } = e,\n        s = [1, t, o, 4];\n      return new St({\n        location: \"texture\",\n        type: \"float32\",\n        texture: i,\n        dims: s,\n        download: r,\n        dispose: n\n      });\n    }, fs = (i, e) => {\n      let {\n        dataType: o,\n        dims: t,\n        download: r,\n        dispose: n\n      } = e;\n      return new St({\n        location: \"gpu-buffer\",\n        type: o ?? \"float32\",\n        gpuBuffer: i,\n        dims: t,\n        download: r,\n        dispose: n\n      });\n    }, cs = (i, e) => {\n      let {\n        dataType: o,\n        dims: t,\n        download: r,\n        dispose: n\n      } = e;\n      return new St({\n        location: \"ml-tensor\",\n        type: o ?? \"float32\",\n        mlTensor: i,\n        dims: t,\n        download: r,\n        dispose: n\n      });\n    }, ps = (i, e, o) => new St({\n      location: \"cpu-pinned\",\n      type: i,\n      data: e,\n      dims: o ?? [e.length]\n    });\n  });\nvar Be,\n  Sr,\n  hs,\n  ms,\n  bs = O(() => {\n    \"use strict\";\n\n    Be = new Map([[\"float32\", Float32Array], [\"uint8\", Uint8Array], [\"int8\", Int8Array], [\"uint16\", Uint16Array], [\"int16\", Int16Array], [\"int32\", Int32Array], [\"bool\", Uint8Array], [\"float64\", Float64Array], [\"uint32\", Uint32Array], [\"int4\", Uint8Array], [\"uint4\", Uint8Array]]), Sr = new Map([[Float32Array, \"float32\"], [Uint8Array, \"uint8\"], [Int8Array, \"int8\"], [Uint16Array, \"uint16\"], [Int16Array, \"int16\"], [Int32Array, \"int32\"], [Float64Array, \"float64\"], [Uint32Array, \"uint32\"]]), hs = !1, ms = () => {\n      if (!hs) {\n        hs = !0;\n        let i = typeof BigInt64Array < \"u\" && BigInt64Array.from,\n          e = typeof BigUint64Array < \"u\" && BigUint64Array.from,\n          o = typeof Float16Array < \"u\" && Float16Array.from;\n        i && (Be.set(\"int64\", BigInt64Array), Sr.set(BigInt64Array, \"int64\")), e && (Be.set(\"uint64\", BigUint64Array), Sr.set(BigUint64Array, \"uint64\")), o ? (Be.set(\"float16\", Float16Array), Sr.set(Float16Array, \"float16\")) : Be.set(\"float16\", Uint16Array);\n      }\n    };\n  });\nvar gs,\n  ys,\n  xs = O(() => {\n    \"use strict\";\n\n    cn();\n    gs = i => {\n      let e = 1;\n      for (let o = 0; o < i.length; o++) {\n        let t = i[o];\n        if (typeof t != \"number\" || !Number.isSafeInteger(t)) throw new TypeError(`dims[${o}] must be an integer, got: ${t}`);\n        if (t < 0) throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${t}`);\n        e *= t;\n      }\n      return e;\n    }, ys = (i, e) => {\n      switch (i.location) {\n        case \"cpu\":\n          return new St(i.type, i.data, e);\n        case \"cpu-pinned\":\n          return new St({\n            location: \"cpu-pinned\",\n            data: i.data,\n            type: i.type,\n            dims: e\n          });\n        case \"texture\":\n          return new St({\n            location: \"texture\",\n            texture: i.texture,\n            type: i.type,\n            dims: e\n          });\n        case \"gpu-buffer\":\n          return new St({\n            location: \"gpu-buffer\",\n            gpuBuffer: i.gpuBuffer,\n            type: i.type,\n            dims: e\n          });\n        case \"ml-tensor\":\n          return new St({\n            location: \"ml-tensor\",\n            mlTensor: i.mlTensor,\n            type: i.type,\n            dims: e\n          });\n        default:\n          throw new Error(`tensorReshape: tensor location ${i.location} is not supported`);\n      }\n    };\n  });\nvar St,\n  cn = O(() => {\n    \"use strict\";\n\n    ss();\n    ds();\n    bs();\n    xs();\n    St = class {\n      constructor(e, o, t) {\n        ms();\n        let r, n;\n        if (typeof e == \"object\" && \"location\" in e) switch (this.dataLocation = e.location, r = e.type, n = e.dims, e.location) {\n          case \"cpu-pinned\":\n            {\n              let a = Be.get(r);\n              if (!a) throw new TypeError(`unsupported type \"${r}\" to create tensor from pinned buffer`);\n              if (!(e.data instanceof a)) throw new TypeError(`buffer should be of type ${a.name}`);\n              this.cpuData = e.data;\n              break;\n            }\n          case \"texture\":\n            {\n              if (r !== \"float32\") throw new TypeError(`unsupported type \"${r}\" to create tensor from texture`);\n              this.gpuTextureData = e.texture, this.downloader = e.download, this.disposer = e.dispose;\n              break;\n            }\n          case \"gpu-buffer\":\n            {\n              if (r !== \"float32\" && r !== \"float16\" && r !== \"int32\" && r !== \"int64\" && r !== \"uint32\" && r !== \"uint8\" && r !== \"bool\" && r !== \"uint4\" && r !== \"int4\") throw new TypeError(`unsupported type \"${r}\" to create tensor from gpu buffer`);\n              this.gpuBufferData = e.gpuBuffer, this.downloader = e.download, this.disposer = e.dispose;\n              break;\n            }\n          case \"ml-tensor\":\n            {\n              if (r !== \"float32\" && r !== \"float16\" && r !== \"int32\" && r !== \"int64\" && r !== \"uint32\" && r !== \"uint64\" && r !== \"int8\" && r !== \"uint8\" && r !== \"bool\") throw new TypeError(`unsupported type \"${r}\" to create tensor from MLTensor`);\n              this.mlTensorData = e.mlTensor, this.downloader = e.download, this.disposer = e.dispose;\n              break;\n            }\n          default:\n            throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);\n        } else {\n          let a, u;\n          if (typeof e == \"string\") {\n            if (r = e, u = t, e === \"string\") {\n              if (!Array.isArray(o)) throw new TypeError(\"A string tensor's data must be a string array.\");\n              a = o;\n            } else {\n              let l = Be.get(e);\n              if (l === void 0) throw new TypeError(`Unsupported tensor type: ${e}.`);\n              if (Array.isArray(o)) {\n                if (e === \"float16\" && l === Uint16Array || e === \"uint4\" || e === \"int4\") throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${l.name} as data.`);\n                e === \"uint64\" || e === \"int64\" ? a = l.from(o, BigInt) : a = l.from(o);\n              } else if (o instanceof l) a = o;else if (o instanceof Uint8ClampedArray) {\n                if (e === \"uint8\") a = Uint8Array.from(o);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");\n              } else throw new TypeError(`A ${r} tensor's data must be type of ${l}`);\n            }\n          } else if (u = o, Array.isArray(e)) {\n            if (e.length === 0) throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n            let l = typeof e[0];\n            if (l === \"string\") r = \"string\", a = e;else if (l === \"boolean\") r = \"bool\", a = Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`);\n          } else if (e instanceof Uint8ClampedArray) r = \"uint8\", a = Uint8Array.from(e);else {\n            let l = Sr.get(e.constructor);\n            if (l === void 0) throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);\n            r = l, a = e;\n          }\n          if (u === void 0) u = [a.length];else if (!Array.isArray(u)) throw new TypeError(\"A tensor's dims must be a number array\");\n          n = u, this.cpuData = a, this.dataLocation = \"cpu\";\n        }\n        let s = gs(n);\n        if (this.cpuData && s !== this.cpuData.length && !((r === \"uint4\" || r === \"int4\") && Math.ceil(s / 2) === this.cpuData.length)) throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);\n        this.type = r, this.dims = n, this.size = s;\n      }\n      static fromImage(e, o) {\n        return _asyncToGenerator(function* () {\n          return us(e, o);\n        })();\n      }\n      static fromTexture(e, o) {\n        return ls(e, o);\n      }\n      static fromGpuBuffer(e, o) {\n        return fs(e, o);\n      }\n      static fromMLTensor(e, o) {\n        return cs(e, o);\n      }\n      static fromPinnedBuffer(e, o, t) {\n        return ps(e, o, t);\n      }\n      toDataURL(e) {\n        return is(this, e);\n      }\n      toImageData(e) {\n        return as(this, e);\n      }\n      get data() {\n        if (this.ensureValid(), !this.cpuData) throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");\n        return this.cpuData;\n      }\n      get location() {\n        return this.dataLocation;\n      }\n      get texture() {\n        if (this.ensureValid(), !this.gpuTextureData) throw new Error(\"The data is not stored as a WebGL texture.\");\n        return this.gpuTextureData;\n      }\n      get gpuBuffer() {\n        if (this.ensureValid(), !this.gpuBufferData) throw new Error(\"The data is not stored as a WebGPU buffer.\");\n        return this.gpuBufferData;\n      }\n      get mlTensor() {\n        if (this.ensureValid(), !this.mlTensorData) throw new Error(\"The data is not stored as a WebNN MLTensor.\");\n        return this.mlTensorData;\n      }\n      getData(e) {\n        var _this = this;\n        return _asyncToGenerator(function* () {\n          switch (_this.ensureValid(), _this.dataLocation) {\n            case \"cpu\":\n            case \"cpu-pinned\":\n              return _this.data;\n            case \"texture\":\n            case \"gpu-buffer\":\n            case \"ml-tensor\":\n              {\n                if (!_this.downloader) throw new Error(\"The current tensor is not created with a specified data downloader.\");\n                if (_this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n                try {\n                  _this.isDownloading = !0;\n                  let o = yield _this.downloader();\n                  return _this.downloader = void 0, _this.dataLocation = \"cpu\", _this.cpuData = o, e && _this.disposer && (_this.disposer(), _this.disposer = void 0), o;\n                } finally {\n                  _this.isDownloading = !1;\n                }\n              }\n            default:\n              throw new Error(`cannot get data from location: ${_this.dataLocation}`);\n          }\n        })();\n      }\n      dispose() {\n        if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n        this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.mlTensorData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = \"none\";\n      }\n      ensureValid() {\n        if (this.dataLocation === \"none\") throw new Error(\"The tensor is disposed.\");\n      }\n      reshape(e) {\n        if (this.ensureValid(), this.downloader || this.disposer) throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");\n        return ys(this, e);\n      }\n    };\n  });\nvar yt,\n  pn = O(() => {\n    \"use strict\";\n\n    cn();\n    yt = St;\n  });\nvar Ts,\n  ws,\n  Fe,\n  Ce,\n  Go = O(() => {\n    \"use strict\";\n\n    No();\n    Ts = (i, e) => {\n      (typeof Gt.trace > \"u\" ? !Gt.wasm.trace : !Gt.trace) || console.timeStamp(`${i}::ORT::${e}`);\n    }, ws = (i, e) => {\n      let o = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [],\n        t = !1;\n      for (let r = 0; r < o.length; r++) {\n        if (t && !o[r].includes(\"TRACE_FUNC\")) {\n          let n = `FUNC_${i}::${o[r].trim().split(\" \")[1]}`;\n          e && (n += `::${e}`), Ts(\"CPU\", n);\n          return;\n        }\n        o[r].includes(\"TRACE_FUNC\") && (t = !0);\n      }\n    }, Fe = i => {\n      (typeof Gt.trace > \"u\" ? !Gt.wasm.trace : !Gt.trace) || ws(\"BEGIN\", i);\n    }, Ce = i => {\n      (typeof Gt.trace > \"u\" ? !Gt.wasm.trace : !Gt.trace) || ws(\"END\", i);\n    };\n  });\nvar dn,\n  vs = O(() => {\n    \"use strict\";\n\n    fn();\n    pn();\n    Go();\n    dn = class i {\n      constructor(e) {\n        this.handler = e;\n      }\n      run(e, o, t) {\n        var _this2 = this;\n        return _asyncToGenerator(function* () {\n          Fe();\n          let r = {},\n            n = {};\n          if (typeof e != \"object\" || e === null || e instanceof yt || Array.isArray(e)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n          let s = !0;\n          if (typeof o == \"object\") {\n            if (o === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n            if (o instanceof yt) throw new TypeError(\"'fetches' cannot be a Tensor\");\n            if (Array.isArray(o)) {\n              if (o.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n              s = !1;\n              for (let l of o) {\n                if (typeof l != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n                if (_this2.outputNames.indexOf(l) === -1) throw new RangeError(`'fetches' contains invalid output name: ${l}.`);\n                r[l] = null;\n              }\n              if (typeof t == \"object\" && t !== null) n = t;else if (typeof t < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else {\n              let l = !1,\n                f = Object.getOwnPropertyNames(o);\n              for (let p of _this2.outputNames) if (f.indexOf(p) !== -1) {\n                let d = o[p];\n                (d === null || d instanceof yt) && (l = !0, s = !1, r[p] = d);\n              }\n              if (l) {\n                if (typeof t == \"object\" && t !== null) n = t;else if (typeof t < \"u\") throw new TypeError(\"'options' must be an object.\");\n              } else n = o;\n            }\n          } else if (typeof o < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n          for (let l of _this2.inputNames) if (typeof e[l] > \"u\") throw new Error(`input '${l}' is missing in 'feeds'.`);\n          if (s) for (let l of _this2.outputNames) r[l] = null;\n          let a = yield _this2.handler.run(e, r, n),\n            u = {};\n          for (let l in a) if (Object.hasOwnProperty.call(a, l)) {\n            let f = a[l];\n            f instanceof yt ? u[l] = f : u[l] = new yt(f.type, f.data, f.dims);\n          }\n          return Ce(), u;\n        })();\n      }\n      release() {\n        var _this3 = this;\n        return _asyncToGenerator(function* () {\n          return _this3.handler.dispose();\n        })();\n      }\n      static create(e, o, t, r) {\n        return _asyncToGenerator(function* () {\n          Fe();\n          let n,\n            s = {};\n          if (typeof e == \"string\") {\n            if (n = e, typeof o == \"object\" && o !== null) s = o;else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n          } else if (e instanceof Uint8Array) {\n            if (n = e, typeof o == \"object\" && o !== null) s = o;else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n          } else if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && e instanceof SharedArrayBuffer) {\n            let f = e,\n              p = 0,\n              d = e.byteLength;\n            if (typeof o == \"object\" && o !== null) s = o;else if (typeof o == \"number\") {\n              if (p = o, !Number.isSafeInteger(p)) throw new RangeError(\"'byteOffset' must be an integer.\");\n              if (p < 0 || p >= f.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);\n              if (d = e.byteLength - p, typeof t == \"number\") {\n                if (d = t, !Number.isSafeInteger(d)) throw new RangeError(\"'byteLength' must be an integer.\");\n                if (d <= 0 || p + d > f.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength - p}].`);\n                if (typeof r == \"object\" && r !== null) s = r;else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n              } else if (typeof t < \"u\") throw new TypeError(\"'byteLength' must be a number.\");\n            } else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n            n = new Uint8Array(f, p, d);\n          } else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n          let [a, u] = yield ln(s),\n            l = yield a.createInferenceSessionHandler(n, u);\n          return Ce(), new i(l);\n        })();\n      }\n      startProfiling() {\n        this.handler.startProfiling();\n      }\n      endProfiling() {\n        this.handler.endProfiling();\n      }\n      get inputNames() {\n        return this.handler.inputNames;\n      }\n      get outputNames() {\n        return this.handler.outputNames;\n      }\n    };\n  });\nvar Yd,\n  Is = O(() => {\n    \"use strict\";\n\n    vs();\n    Yd = dn;\n  });\nvar _s = O(() => {\n  \"use strict\";\n});\nvar Os = O(() => {\n  \"use strict\";\n});\nvar Ss = O(() => {\n  \"use strict\";\n});\nvar As = O(() => {\n  \"use strict\";\n});\nvar Zd,\n  hn,\n  Ps = O(() => {\n    \"use strict\";\n\n    fn();\n    pn();\n    Zd = \"Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.\", hn = class i {\n      constructor(e, o, t) {\n        this.handler = e, this.hasOptimizerModel = o, this.hasEvalModel = t;\n      }\n      get trainingInputNames() {\n        return this.handler.inputNames;\n      }\n      get trainingOutputNames() {\n        return this.handler.outputNames;\n      }\n      get evalInputNames() {\n        if (this.hasEvalModel) return this.handler.evalInputNames;\n        throw new Error(\"This training session has no evalModel loaded.\");\n      }\n      get evalOutputNames() {\n        if (this.hasEvalModel) return this.handler.evalOutputNames;\n        throw new Error(\"This training session has no evalModel loaded.\");\n      }\n      static create(e, o) {\n        return _asyncToGenerator(function* () {\n          let t = e.evalModel || \"\",\n            r = e.optimizerModel || \"\",\n            n = o || {},\n            [s, a] = yield ln(n);\n          if (s.createTrainingSessionHandler) {\n            let u = yield s.createTrainingSessionHandler(e.checkpointState, e.trainModel, t, r, a);\n            return new i(u, !!e.optimizerModel, !!e.evalModel);\n          } else throw new Error(Zd);\n        })();\n      }\n      typeNarrowingForRunStep(e, o, t, r, n) {\n        let s = {},\n          a = {};\n        if (typeof t != \"object\" || t === null || t instanceof yt || Array.isArray(t)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        let u = !0;\n        if (typeof r == \"object\") {\n          if (r === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n          if (r instanceof yt) throw new TypeError(\"'fetches' cannot be a Tensor\");\n          if (Array.isArray(r)) {\n            if (r.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n            u = !1;\n            for (let l of r) {\n              if (typeof l != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n              if (o.indexOf(l) === -1) throw new RangeError(`'fetches' contains invalid output name: ${l}.`);\n              s[l] = null;\n            }\n            if (typeof n == \"object\" && n !== null) a = n;else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n          } else {\n            let l = !1,\n              f = Object.getOwnPropertyNames(r);\n            for (let p of o) if (f.indexOf(p) !== -1) {\n              let d = r[p];\n              (d === null || d instanceof yt) && (l = !0, u = !1, s[p] = d);\n            }\n            if (l) {\n              if (typeof n == \"object\" && n !== null) a = n;else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else a = r;\n          }\n        } else if (typeof r < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        for (let l of e) if (typeof t[l] > \"u\") throw new Error(`input '${l}' is missing in 'feeds'.`);\n        if (u) for (let l of o) s[l] = null;\n        return [s, a];\n      }\n      convertHandlerReturnTypeToMapOfTensors(e) {\n        let o = {};\n        for (let t in e) if (Object.hasOwnProperty.call(e, t)) {\n          let r = e[t];\n          r instanceof yt ? o[t] = r : o[t] = new yt(r.type, r.data, r.dims);\n        }\n        return o;\n      }\n      lazyResetGrad() {\n        var _this4 = this;\n        return _asyncToGenerator(function* () {\n          yield _this4.handler.lazyResetGrad();\n        })();\n      }\n      runTrainStep(e, o, t) {\n        var _this5 = this;\n        return _asyncToGenerator(function* () {\n          let [r, n] = _this5.typeNarrowingForRunStep(_this5.trainingInputNames, _this5.trainingOutputNames, e, o, t),\n            s = yield _this5.handler.runTrainStep(e, r, n);\n          return _this5.convertHandlerReturnTypeToMapOfTensors(s);\n        })();\n      }\n      runOptimizerStep(e) {\n        var _this6 = this;\n        return _asyncToGenerator(function* () {\n          if (_this6.hasOptimizerModel) yield _this6.handler.runOptimizerStep(e || {});else throw new Error(\"This TrainingSession has no OptimizerModel loaded.\");\n        })();\n      }\n      runEvalStep(e, o, t) {\n        var _this7 = this;\n        return _asyncToGenerator(function* () {\n          if (_this7.hasEvalModel) {\n            let [r, n] = _this7.typeNarrowingForRunStep(_this7.evalInputNames, _this7.evalOutputNames, e, o, t),\n              s = yield _this7.handler.runEvalStep(e, r, n);\n            return _this7.convertHandlerReturnTypeToMapOfTensors(s);\n          } else throw new Error(\"This TrainingSession has no EvalModel loaded.\");\n        })();\n      }\n      getParametersSize() {\n        var _this8 = this;\n        return _asyncToGenerator(function* (e = !0) {\n          return _this8.handler.getParametersSize(e);\n        }).apply(this, arguments);\n      }\n      loadParametersBuffer(_x5) {\n        var _this9 = this;\n        return _asyncToGenerator(function* (e, o = !0) {\n          let t = yield _this9.getParametersSize(o);\n          if (e.length !== 4 * t) throw new Error(\"Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.\");\n          return _this9.handler.loadParametersBuffer(e, o);\n        }).apply(this, arguments);\n      }\n      getContiguousParameters() {\n        var _this0 = this;\n        return _asyncToGenerator(function* (e = !0) {\n          return _this0.handler.getContiguousParameters(e);\n        }).apply(this, arguments);\n      }\n      release() {\n        var _this1 = this;\n        return _asyncToGenerator(function* () {\n          return _this1.handler.dispose();\n        })();\n      }\n    };\n  });\nvar Qd,\n  Es = O(() => {\n    \"use strict\";\n\n    Ps();\n    Qd = hn;\n  });\nvar Mo = {};\nOr(Mo, {\n  InferenceSession: () => Yd,\n  TRACE: () => Ts,\n  TRACE_FUNC_BEGIN: () => Fe,\n  TRACE_FUNC_END: () => Ce,\n  Tensor: () => yt,\n  TrainingSession: () => Qd,\n  env: () => z,\n  registerBackend: () => nr\n});\nvar Yt = O(() => {\n  \"use strict\";\n\n  ts();\n  os();\n  Is();\n  pn();\n  _s();\n  Os();\n  Go();\n  Ss();\n  As();\n  Es();\n});\nfunction _e(i, e, o, t) {\n  if (e === void 0) return eh(i);\n  if (o === void 0) mn(i, e, 1);else if (typeof o == \"number\" && t === void 0) mn(i, e, o);else if (typeof o == \"string\" && t === void 0) mn(i, o, 1, e);else if (typeof o == \"string\" && typeof t == \"number\") mn(i, o, t, e);else throw new TypeError(\"input is valid\");\n}\nfunction eh(i) {\n  return {\n    verbose: _e.verbose.bind(null, i),\n    info: _e.info.bind(null, i),\n    warning: _e.warning.bind(null, i),\n    error: _e.error.bind(null, i),\n    fatal: _e.fatal.bind(null, i)\n  };\n}\nfunction mn(i, e, o, t) {\n  let r = Ar[t || \"\"] || Ar[\"\"];\n  Ls[i] < Ls[r.minimalSeverity] || (r.logDateTime && (e = `${new Date().toISOString()}|${e}`), r.logSourceLocation, th[r.provider].log(i, e, t));\n}\nvar Uo,\n  Vo,\n  Ls,\n  th,\n  $s,\n  Ar,\n  tt,\n  gn,\n  yn,\n  xn,\n  bn,\n  Ut = O(() => {\n    \"use strict\";\n\n    Uo = class {\n      log(e, o, t) {}\n    }, Vo = class {\n      log(e, o, t) {\n        console.log(`${this.color(e)} ${t ? \"\\x1B[35m\" + t + \"\\x1B[0m \" : \"\"}${o}`);\n      }\n      color(e) {\n        switch (e) {\n          case \"verbose\":\n            return \"\\x1B[34;40mv\\x1B[0m\";\n          case \"info\":\n            return \"\\x1B[32mi\\x1B[0m\";\n          case \"warning\":\n            return \"\\x1B[30;43mw\\x1B[0m\";\n          case \"error\":\n            return \"\\x1B[31;40me\\x1B[0m\";\n          case \"fatal\":\n            return \"\\x1B[101mf\\x1B[0m\";\n          default:\n            throw new Error(`unsupported severity: ${e}`);\n        }\n      }\n    }, Ls = {\n      verbose: 1e3,\n      info: 2e3,\n      warning: 4e3,\n      error: 5e3,\n      fatal: 6e3\n    }, th = {\n      none: new Uo(),\n      console: new Vo()\n    }, $s = {\n      provider: \"console\",\n      minimalSeverity: \"warning\",\n      logDateTime: !0,\n      logSourceLocation: !1\n    }, Ar = {\n      \"\": $s\n    };\n    (u => {\n      function i(l, f) {\n        u(\"verbose\", l, f);\n      }\n      u.verbose = i;\n      function e(l, f) {\n        u(\"info\", l, f);\n      }\n      u.info = e;\n      function o(l, f) {\n        u(\"warning\", l, f);\n      }\n      u.warning = o;\n      function t(l, f) {\n        u(\"error\", l, f);\n      }\n      u.error = t;\n      function r(l, f) {\n        u(\"fatal\", l, f);\n      }\n      u.fatal = r;\n      function n(l) {\n        Ar = {}, s(\"\", l || {});\n      }\n      u.reset = n;\n      function s(l, f) {\n        if (l === \"*\") n(f);else {\n          let p = Ar[l] || $s;\n          Ar[l] = {\n            provider: f.provider || p.provider,\n            minimalSeverity: f.minimalSeverity || p.minimalSeverity,\n            logDateTime: f.logDateTime === void 0 ? p.logDateTime : f.logDateTime,\n            logSourceLocation: f.logSourceLocation === void 0 ? p.logSourceLocation : f.logSourceLocation\n          };\n        }\n      }\n      u.set = s;\n      function a(l) {\n        let f = {};\n        l.logLevel && (f.minimalSeverity = l.logLevel), s(\"\", f);\n      }\n      u.setWithEnv = a;\n    })(_e ||= {});\n    tt = _e, gn = class {\n      constructor(e, o, t, r, n, s) {\n        this.category = e;\n        this.name = o;\n        this.startTime = t;\n        this.endCallback = r;\n        this.timer = n;\n        this.ctx = s;\n      }\n      end() {\n        var _this10 = this;\n        return _asyncToGenerator(function* () {\n          return _this10.endCallback(_this10);\n        })();\n      }\n      checkTimer() {\n        var _this11 = this;\n        return _asyncToGenerator(function* () {\n          if (_this11.ctx === void 0 || _this11.timer === void 0) throw new Error(\"No webgl timer found\");\n          return _this11.ctx.endTimer(), _this11.ctx.waitForQueryAndGetTime(_this11.timer);\n        })();\n      }\n    }, yn = class {\n      constructor(e, o, t, r) {\n        this.category = e;\n        this.name = o;\n        this.startTime = t;\n        this.endTime = r;\n      }\n    }, xn = class {\n      constructor(e, o, t) {\n        this._started = !1;\n        this._flushPointer = 0;\n        this._started = !1, this._maxNumberEvents = e === void 0 ? 1e4 : e, this._flushBatchSize = o === void 0 ? 10 : o, this._flushIntervalInMilliseconds = t === void 0 ? 5e3 : t;\n      }\n      static create(e) {\n        return e === void 0 ? new this() : new this(e.maxNumberEvents, e.flushBatchSize, e.flushIntervalInMilliseconds);\n      }\n      start() {\n        this._started = !0, this._timingEvents = [], this._flushTime = bn(), this._flushPointer = 0;\n      }\n      stop() {\n        for (this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n      }\n      event(e, o, t, r) {\n        let n = this._started ? this.begin(e, o, r) : void 0,\n          s = !1,\n          a = t();\n        if (a && typeof a.then == \"function\") return s = !0, new Promise((u, l) => {\n          a.then( /*#__PURE__*/function () {\n            var _ref4 = _asyncToGenerator(function* (f) {\n              n && (yield n.end()), u(f);\n            });\n            return function (_x6) {\n              return _ref4.apply(this, arguments);\n            };\n          }(), /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (f) {\n              n && (yield n.end()), l(f);\n            });\n            return function (_x7) {\n              return _ref5.apply(this, arguments);\n            };\n          }());\n        });\n        if (!s && n) {\n          let u = n.end();\n          if (u && typeof u.then == \"function\") return new Promise((l, f) => {\n            u.then(() => {\n              l(a);\n            }, p => {\n              f(p);\n            });\n          });\n        }\n        return a;\n      }\n      begin(e, o, t) {\n        var _this12 = this;\n        if (!this._started) throw new Error(\"profiler is not started yet\");\n        if (t === void 0) {\n          let r = bn();\n          return this.flush(r), new gn(e, o, r, n => this.endSync(n));\n        } else {\n          let r = t.beginTimer();\n          return new gn(e, o, 0, /*#__PURE__*/function () {\n            var _ref6 = _asyncToGenerator(function* (n) {\n              return _this12.end(n);\n            });\n            return function (_x8) {\n              return _ref6.apply(this, arguments);\n            };\n          }(), r, t);\n        }\n      }\n      end(e) {\n        var _this13 = this;\n        return _asyncToGenerator(function* () {\n          let o = yield e.checkTimer();\n          _this13._timingEvents.length < _this13._maxNumberEvents && (_this13._timingEvents.push(new yn(e.category, e.name, e.startTime, o)), _this13.flush(o));\n        })();\n      }\n      endSync(e) {\n        let o = bn();\n        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new yn(e.category, e.name, e.startTime, o)), this.flush(o));\n      }\n      logOneEvent(e) {\n        tt.verbose(`Profiler.${e.category}`, `${(e.endTime - e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`);\n      }\n      flush(e) {\n        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e - this._flushTime >= this._flushIntervalInMilliseconds) {\n          for (let o = this._flushPointer; this._flushPointer < o + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n          this._flushTime = bn();\n        }\n      }\n      get started() {\n        return this._started;\n      }\n    }, bn = typeof performance < \"u\" && performance.now ? () => performance.now() : Date.now;\n  });\nfunction ks(i, e, o) {\n  for (let t of o) {\n    let r = t[0],\n      n = t[1],\n      s = t[2],\n      a = t[3],\n      u = t[4];\n    if (i.opType === r) {\n      for (let l of e) if ((l.domain === n || l.domain === \"ai.onnx\" && n === \"\") && rh(l.version, s)) return {\n        opImpl: a,\n        opInit: u\n      };\n    }\n  }\n  throw new TypeError(`cannot resolve operator '${i.opType}' with opsets: ${e.map(t => `${t.domain || \"ai.onnx\"} v${t.version}`).join(\", \")}`);\n}\nfunction rh(i, e) {\n  if (e.endsWith(\"+\")) {\n    let o = Number.parseInt(e.substring(0, e.length - 1), 10);\n    return !isNaN(o) && o <= i;\n  } else if (e.split(\"-\").length === 2) {\n    let o = e.split(\"-\"),\n      t = Number.parseInt(o[0], 10),\n      r = Number.parseInt(o[1], 10);\n    return !isNaN(t) && !isNaN(r) && t <= i && i <= r;\n  } else return Number.parseInt(e, 10) === i;\n}\nvar Bs = O(() => {\n  \"use strict\";\n});\nvar Fs = mt(zo => {\n  \"use strict\";\n\n  zo.__esModule = !0;\n  var nh = function () {\n    function i(e) {\n      if (!e) throw new TypeError(\"Invalid argument; `value` has no value.\");\n      this.value = i.EMPTY, e && i.isGuid(e) && (this.value = e);\n    }\n    return i.isGuid = function (e) {\n      var o = e.toString();\n      return e && (e instanceof i || i.validator.test(o));\n    }, i.create = function () {\n      return new i([i.gen(2), i.gen(1), i.gen(1), i.gen(1), i.gen(3)].join(\"-\"));\n    }, i.createEmpty = function () {\n      return new i(\"emptyguid\");\n    }, i.parse = function (e) {\n      return new i(e);\n    }, i.raw = function () {\n      return [i.gen(2), i.gen(1), i.gen(1), i.gen(1), i.gen(3)].join(\"-\");\n    }, i.gen = function (e) {\n      for (var o = \"\", t = 0; t < e; t++) o += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);\n      return o;\n    }, i.prototype.equals = function (e) {\n      return i.isGuid(e) && this.value === e.toString();\n    }, i.prototype.isEmpty = function () {\n      return this.value === i.EMPTY;\n    }, i.prototype.toString = function () {\n      return this.value;\n    }, i.prototype.toJSON = function () {\n      return {\n        value: this.value\n      };\n    }, i.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\"), i.EMPTY = \"00000000-0000-0000-0000-000000000000\", i;\n  }();\n  zo.Guid = nh;\n});\nfunction rt(i, e, o) {\n  this.low = i | 0, this.high = e | 0, this.unsigned = !!o;\n}\nfunction Et(i) {\n  return (i && i.__isLong__) === !0;\n}\nfunction Cs(i) {\n  var e = Math.clz32(i & -i);\n  return i ? 31 - e : e;\n}\nfunction Ne(i, e) {\n  var o, t, r;\n  return e ? (i >>>= 0, (r = 0 <= i && i < 256) && (t = Rs[i], t) ? t : (o = J(i, 0, !0), r && (Rs[i] = o), o)) : (i |= 0, (r = -128 <= i && i < 128) && (t = Ns[i], t) ? t : (o = J(i, i < 0 ? -1 : 0, !1), r && (Ns[i] = o), o));\n}\nfunction zt(i, e) {\n  if (isNaN(i)) return e ? ye : Zt;\n  if (e) {\n    if (i < 0) return ye;\n    if (i >= Vs) return Hs;\n  } else {\n    if (i <= -Ms) return Ct;\n    if (i + 1 >= Ms) return Ws;\n  }\n  return i < 0 ? zt(-i, e).neg() : J(i % ir | 0, i / ir | 0, e);\n}\nfunction J(i, e, o) {\n  return new rt(i, e, o);\n}\nfunction Ho(i, e, o) {\n  if (i.length === 0) throw Error(\"empty string\");\n  if (typeof e == \"number\" ? (o = e, e = !1) : e = !!e, i === \"NaN\" || i === \"Infinity\" || i === \"+Infinity\" || i === \"-Infinity\") return e ? ye : Zt;\n  if (o = o || 10, o < 2 || 36 < o) throw RangeError(\"radix\");\n  var t;\n  if ((t = i.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  if (t === 0) return Ho(i.substring(1), e, o).neg();\n  for (var r = zt(Tn(o, 8)), n = Zt, s = 0; s < i.length; s += 8) {\n    var a = Math.min(8, i.length - s),\n      u = parseInt(i.substring(s, s + a), o);\n    if (a < 8) {\n      var l = zt(Tn(o, a));\n      n = n.mul(l).add(zt(u));\n    } else n = n.mul(r), n = n.add(zt(u));\n  }\n  return n.unsigned = e, n;\n}\nfunction Qt(i, e) {\n  return typeof i == \"number\" ? zt(i, e) : typeof i == \"string\" ? Ho(i, e) : J(i.low, i.high, typeof e == \"boolean\" ? e : i.unsigned);\n}\nvar Vt,\n  Ns,\n  Rs,\n  Tn,\n  Gs,\n  oh,\n  ir,\n  Vs,\n  Ms,\n  Us,\n  Zt,\n  ye,\n  or,\n  zs,\n  Wo,\n  Ws,\n  Hs,\n  Ct,\n  D,\n  xe,\n  qo = O(() => {\n    Vt = null;\n    try {\n      Vt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n    } catch {}\n    rt.prototype.__isLong__;\n    Object.defineProperty(rt.prototype, \"__isLong__\", {\n      value: !0\n    });\n    rt.isLong = Et;\n    Ns = {}, Rs = {};\n    rt.fromInt = Ne;\n    rt.fromNumber = zt;\n    rt.fromBits = J;\n    Tn = Math.pow;\n    rt.fromString = Ho;\n    rt.fromValue = Qt;\n    Gs = 65536, oh = 1 << 24, ir = Gs * Gs, Vs = ir * ir, Ms = Vs / 2, Us = Ne(oh), Zt = Ne(0);\n    rt.ZERO = Zt;\n    ye = Ne(0, !0);\n    rt.UZERO = ye;\n    or = Ne(1);\n    rt.ONE = or;\n    zs = Ne(1, !0);\n    rt.UONE = zs;\n    Wo = Ne(-1);\n    rt.NEG_ONE = Wo;\n    Ws = J(-1, 2147483647, !1);\n    rt.MAX_VALUE = Ws;\n    Hs = J(-1, -1, !0);\n    rt.MAX_UNSIGNED_VALUE = Hs;\n    Ct = J(0, -2147483648, !1);\n    rt.MIN_VALUE = Ct;\n    D = rt.prototype;\n    D.toInt = function () {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    D.toNumber = function () {\n      return this.unsigned ? (this.high >>> 0) * ir + (this.low >>> 0) : this.high * ir + (this.low >>> 0);\n    };\n    D.toString = function (e) {\n      if (e = e || 10, e < 2 || 36 < e) throw RangeError(\"radix\");\n      if (this.isZero()) return \"0\";\n      if (this.isNegative()) if (this.eq(Ct)) {\n        var o = zt(e),\n          t = this.div(o),\n          r = t.mul(o).sub(this);\n        return t.toString(e) + r.toInt().toString(e);\n      } else return \"-\" + this.neg().toString(e);\n      for (var n = zt(Tn(e, 6), this.unsigned), s = this, a = \"\";;) {\n        var u = s.div(n),\n          l = s.sub(u.mul(n)).toInt() >>> 0,\n          f = l.toString(e);\n        if (s = u, s.isZero()) return f + a;\n        for (; f.length < 6;) f = \"0\" + f;\n        a = \"\" + f + a;\n      }\n    };\n    D.getHighBits = function () {\n      return this.high;\n    };\n    D.getHighBitsUnsigned = function () {\n      return this.high >>> 0;\n    };\n    D.getLowBits = function () {\n      return this.low;\n    };\n    D.getLowBitsUnsigned = function () {\n      return this.low >>> 0;\n    };\n    D.getNumBitsAbs = function () {\n      if (this.isNegative()) return this.eq(Ct) ? 64 : this.neg().getNumBitsAbs();\n      for (var e = this.high != 0 ? this.high : this.low, o = 31; o > 0 && !(e & 1 << o); o--);\n      return this.high != 0 ? o + 33 : o + 1;\n    };\n    D.isZero = function () {\n      return this.high === 0 && this.low === 0;\n    };\n    D.eqz = D.isZero;\n    D.isNegative = function () {\n      return !this.unsigned && this.high < 0;\n    };\n    D.isPositive = function () {\n      return this.unsigned || this.high >= 0;\n    };\n    D.isOdd = function () {\n      return (this.low & 1) === 1;\n    };\n    D.isEven = function () {\n      return (this.low & 1) === 0;\n    };\n    D.equals = function (e) {\n      return Et(e) || (e = Qt(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;\n    };\n    D.eq = D.equals;\n    D.notEquals = function (e) {\n      return !this.eq(e);\n    };\n    D.neq = D.notEquals;\n    D.ne = D.notEquals;\n    D.lessThan = function (e) {\n      return this.comp(e) < 0;\n    };\n    D.lt = D.lessThan;\n    D.lessThanOrEqual = function (e) {\n      return this.comp(e) <= 0;\n    };\n    D.lte = D.lessThanOrEqual;\n    D.le = D.lessThanOrEqual;\n    D.greaterThan = function (e) {\n      return this.comp(e) > 0;\n    };\n    D.gt = D.greaterThan;\n    D.greaterThanOrEqual = function (e) {\n      return this.comp(e) >= 0;\n    };\n    D.gte = D.greaterThanOrEqual;\n    D.ge = D.greaterThanOrEqual;\n    D.compare = function (e) {\n      if (Et(e) || (e = Qt(e)), this.eq(e)) return 0;\n      var o = this.isNegative(),\n        t = e.isNegative();\n      return o && !t ? -1 : !o && t ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;\n    };\n    D.comp = D.compare;\n    D.negate = function () {\n      return !this.unsigned && this.eq(Ct) ? Ct : this.not().add(or);\n    };\n    D.neg = D.negate;\n    D.add = function (e) {\n      Et(e) || (e = Qt(e));\n      var o = this.high >>> 16,\n        t = this.high & 65535,\n        r = this.low >>> 16,\n        n = this.low & 65535,\n        s = e.high >>> 16,\n        a = e.high & 65535,\n        u = e.low >>> 16,\n        l = e.low & 65535,\n        f = 0,\n        p = 0,\n        d = 0,\n        y = 0;\n      return y += n + l, d += y >>> 16, y &= 65535, d += r + u, p += d >>> 16, d &= 65535, p += t + a, f += p >>> 16, p &= 65535, f += o + s, f &= 65535, J(d << 16 | y, f << 16 | p, this.unsigned);\n    };\n    D.subtract = function (e) {\n      return Et(e) || (e = Qt(e)), this.add(e.neg());\n    };\n    D.sub = D.subtract;\n    D.multiply = function (e) {\n      if (this.isZero()) return this;\n      if (Et(e) || (e = Qt(e)), Vt) {\n        var o = Vt.mul(this.low, this.high, e.low, e.high);\n        return J(o, Vt.get_high(), this.unsigned);\n      }\n      if (e.isZero()) return this.unsigned ? ye : Zt;\n      if (this.eq(Ct)) return e.isOdd() ? Ct : Zt;\n      if (e.eq(Ct)) return this.isOdd() ? Ct : Zt;\n      if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();\n      if (e.isNegative()) return this.mul(e.neg()).neg();\n      if (this.lt(Us) && e.lt(Us)) return zt(this.toNumber() * e.toNumber(), this.unsigned);\n      var t = this.high >>> 16,\n        r = this.high & 65535,\n        n = this.low >>> 16,\n        s = this.low & 65535,\n        a = e.high >>> 16,\n        u = e.high & 65535,\n        l = e.low >>> 16,\n        f = e.low & 65535,\n        p = 0,\n        d = 0,\n        y = 0,\n        T = 0;\n      return T += s * f, y += T >>> 16, T &= 65535, y += n * f, d += y >>> 16, y &= 65535, y += s * l, d += y >>> 16, y &= 65535, d += r * f, p += d >>> 16, d &= 65535, d += n * l, p += d >>> 16, d &= 65535, d += s * u, p += d >>> 16, d &= 65535, p += t * f + r * l + n * u + s * a, p &= 65535, J(y << 16 | T, p << 16 | d, this.unsigned);\n    };\n    D.mul = D.multiply;\n    D.divide = function (e) {\n      if (Et(e) || (e = Qt(e)), e.isZero()) throw Error(\"division by zero\");\n      if (Vt) {\n        if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1) return this;\n        var o = (this.unsigned ? Vt.div_u : Vt.div_s)(this.low, this.high, e.low, e.high);\n        return J(o, Vt.get_high(), this.unsigned);\n      }\n      if (this.isZero()) return this.unsigned ? ye : Zt;\n      var t, r, n;\n      if (this.unsigned) {\n        if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return ye;\n        if (e.gt(this.shru(1))) return zs;\n        n = ye;\n      } else {\n        if (this.eq(Ct)) {\n          if (e.eq(or) || e.eq(Wo)) return Ct;\n          if (e.eq(Ct)) return or;\n          var s = this.shr(1);\n          return t = s.div(e).shl(1), t.eq(Zt) ? e.isNegative() ? or : Wo : (r = this.sub(e.mul(t)), n = t.add(r.div(e)), n);\n        } else if (e.eq(Ct)) return this.unsigned ? ye : Zt;\n        if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();\n        if (e.isNegative()) return this.div(e.neg()).neg();\n        n = Zt;\n      }\n      for (r = this; r.gte(e);) {\n        t = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));\n        for (var a = Math.ceil(Math.log(t) / Math.LN2), u = a <= 48 ? 1 : Tn(2, a - 48), l = zt(t), f = l.mul(e); f.isNegative() || f.gt(r);) t -= u, l = zt(t, this.unsigned), f = l.mul(e);\n        l.isZero() && (l = or), n = n.add(l), r = r.sub(f);\n      }\n      return n;\n    };\n    D.div = D.divide;\n    D.modulo = function (e) {\n      if (Et(e) || (e = Qt(e)), Vt) {\n        var o = (this.unsigned ? Vt.rem_u : Vt.rem_s)(this.low, this.high, e.low, e.high);\n        return J(o, Vt.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(e).mul(e));\n    };\n    D.mod = D.modulo;\n    D.rem = D.modulo;\n    D.not = function () {\n      return J(~this.low, ~this.high, this.unsigned);\n    };\n    D.countLeadingZeros = function () {\n      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    D.clz = D.countLeadingZeros;\n    D.countTrailingZeros = function () {\n      return this.low ? Cs(this.low) : Cs(this.high) + 32;\n    };\n    D.ctz = D.countTrailingZeros;\n    D.and = function (e) {\n      return Et(e) || (e = Qt(e)), J(this.low & e.low, this.high & e.high, this.unsigned);\n    };\n    D.or = function (e) {\n      return Et(e) || (e = Qt(e)), J(this.low | e.low, this.high | e.high, this.unsigned);\n    };\n    D.xor = function (e) {\n      return Et(e) || (e = Qt(e)), J(this.low ^ e.low, this.high ^ e.high, this.unsigned);\n    };\n    D.shiftLeft = function (e) {\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? J(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : J(0, this.low << e - 32, this.unsigned);\n    };\n    D.shl = D.shiftLeft;\n    D.shiftRight = function (e) {\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? J(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : J(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    D.shr = D.shiftRight;\n    D.shiftRightUnsigned = function (e) {\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? J(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? J(this.high, 0, this.unsigned) : J(this.high >>> e - 32, 0, this.unsigned);\n    };\n    D.shru = D.shiftRightUnsigned;\n    D.shr_u = D.shiftRightUnsigned;\n    D.rotateLeft = function (e) {\n      var o;\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? J(this.high, this.low, this.unsigned) : e < 32 ? (o = 32 - e, J(this.low << e | this.high >>> o, this.high << e | this.low >>> o, this.unsigned)) : (e -= 32, o = 32 - e, J(this.high << e | this.low >>> o, this.low << e | this.high >>> o, this.unsigned));\n    };\n    D.rotl = D.rotateLeft;\n    D.rotateRight = function (e) {\n      var o;\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? J(this.high, this.low, this.unsigned) : e < 32 ? (o = 32 - e, J(this.high << o | this.low >>> e, this.low << o | this.high >>> e, this.unsigned)) : (e -= 32, o = 32 - e, J(this.low << o | this.high >>> e, this.high << o | this.low >>> e, this.unsigned));\n    };\n    D.rotr = D.rotateRight;\n    D.toSigned = function () {\n      return this.unsigned ? J(this.low, this.high, !1) : this;\n    };\n    D.toUnsigned = function () {\n      return this.unsigned ? this : J(this.low, this.high, !0);\n    };\n    D.toBytes = function (e) {\n      return e ? this.toBytesLE() : this.toBytesBE();\n    };\n    D.toBytesLE = function () {\n      var e = this.high,\n        o = this.low;\n      return [o & 255, o >>> 8 & 255, o >>> 16 & 255, o >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];\n    };\n    D.toBytesBE = function () {\n      var e = this.high,\n        o = this.low;\n      return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, o >>> 24, o >>> 16 & 255, o >>> 8 & 255, o & 255];\n    };\n    rt.fromBytes = function (e, o, t) {\n      return t ? rt.fromBytesLE(e, o) : rt.fromBytesBE(e, o);\n    };\n    rt.fromBytesLE = function (e, o) {\n      return new rt(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, o);\n    };\n    rt.fromBytesBE = function (e, o) {\n      return new rt(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], o);\n    };\n    xe = rt;\n  });\nvar w,\n  wn = O(() => {\n    w = {};\n    w.Offset;\n    w.Table;\n    w.SIZEOF_SHORT = 2;\n    w.SIZEOF_INT = 4;\n    w.FILE_IDENTIFIER_LENGTH = 4;\n    w.SIZE_PREFIX_LENGTH = 4;\n    w.Encoding = {\n      UTF8_BYTES: 1,\n      UTF16_STRING: 2\n    };\n    w.int32 = new Int32Array(2);\n    w.float32 = new Float32Array(w.int32.buffer);\n    w.float64 = new Float64Array(w.int32.buffer);\n    w.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n    w.Long = function (i, e) {\n      this.low = i | 0, this.high = e | 0;\n    };\n    w.Long.create = function (i, e) {\n      return i == 0 && e == 0 ? w.Long.ZERO : new w.Long(i, e);\n    };\n    w.Long.prototype.toFloat64 = function () {\n      return (this.low >>> 0) + this.high * 4294967296;\n    };\n    w.Long.prototype.equals = function (i) {\n      return this.low == i.low && this.high == i.high;\n    };\n    w.Long.ZERO = new w.Long(0, 0);\n    w.Builder = function (i) {\n      if (i) var e = i;else var e = 1024;\n      this.bb = w.ByteBuffer.allocate(e), this.space = e, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n    };\n    w.Builder.prototype.clear = function () {\n      this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n    };\n    w.Builder.prototype.forceDefaults = function (i) {\n      this.force_defaults = i;\n    };\n    w.Builder.prototype.dataBuffer = function () {\n      return this.bb;\n    };\n    w.Builder.prototype.asUint8Array = function () {\n      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    };\n    w.Builder.prototype.prep = function (i, e) {\n      i > this.minalign && (this.minalign = i);\n      for (var o = ~(this.bb.capacity() - this.space + e) + 1 & i - 1; this.space < o + i + e;) {\n        var t = this.bb.capacity();\n        this.bb = w.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - t;\n      }\n      this.pad(o);\n    };\n    w.Builder.prototype.pad = function (i) {\n      for (var e = 0; e < i; e++) this.bb.writeInt8(--this.space, 0);\n    };\n    w.Builder.prototype.writeInt8 = function (i) {\n      this.bb.writeInt8(this.space -= 1, i);\n    };\n    w.Builder.prototype.writeInt16 = function (i) {\n      this.bb.writeInt16(this.space -= 2, i);\n    };\n    w.Builder.prototype.writeInt32 = function (i) {\n      this.bb.writeInt32(this.space -= 4, i);\n    };\n    w.Builder.prototype.writeInt64 = function (i) {\n      this.bb.writeInt64(this.space -= 8, i);\n    };\n    w.Builder.prototype.writeFloat32 = function (i) {\n      this.bb.writeFloat32(this.space -= 4, i);\n    };\n    w.Builder.prototype.writeFloat64 = function (i) {\n      this.bb.writeFloat64(this.space -= 8, i);\n    };\n    w.Builder.prototype.addInt8 = function (i) {\n      this.prep(1, 0), this.writeInt8(i);\n    };\n    w.Builder.prototype.addInt16 = function (i) {\n      this.prep(2, 0), this.writeInt16(i);\n    };\n    w.Builder.prototype.addInt32 = function (i) {\n      this.prep(4, 0), this.writeInt32(i);\n    };\n    w.Builder.prototype.addInt64 = function (i) {\n      this.prep(8, 0), this.writeInt64(i);\n    };\n    w.Builder.prototype.addFloat32 = function (i) {\n      this.prep(4, 0), this.writeFloat32(i);\n    };\n    w.Builder.prototype.addFloat64 = function (i) {\n      this.prep(8, 0), this.writeFloat64(i);\n    };\n    w.Builder.prototype.addFieldInt8 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addInt8(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldInt16 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addInt16(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldInt32 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addInt32(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldInt64 = function (i, e, o) {\n      (this.force_defaults || !e.equals(o)) && (this.addInt64(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldFloat32 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addFloat32(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldFloat64 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addFloat64(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldOffset = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addOffset(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldStruct = function (i, e, o) {\n      e != o && (this.nested(e), this.slot(i));\n    };\n    w.Builder.prototype.nested = function (i) {\n      if (i != this.offset()) throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n    };\n    w.Builder.prototype.notNested = function () {\n      if (this.isNested) throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n    };\n    w.Builder.prototype.slot = function (i) {\n      this.vtable[i] = this.offset();\n    };\n    w.Builder.prototype.offset = function () {\n      return this.bb.capacity() - this.space;\n    };\n    w.Builder.growByteBuffer = function (i) {\n      var e = i.capacity();\n      if (e & 3221225472) throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n      var o = e << 1,\n        t = w.ByteBuffer.allocate(o);\n      return t.setPosition(o - e), t.bytes().set(i.bytes(), o - e), t;\n    };\n    w.Builder.prototype.addOffset = function (i) {\n      this.prep(w.SIZEOF_INT, 0), this.writeInt32(this.offset() - i + w.SIZEOF_INT);\n    };\n    w.Builder.prototype.startObject = function (i) {\n      this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = i;\n      for (var e = 0; e < i; e++) this.vtable[e] = 0;\n      this.isNested = !0, this.object_start = this.offset();\n    };\n    w.Builder.prototype.endObject = function () {\n      if (this.vtable == null || !this.isNested) throw new Error(\"FlatBuffers: endObject called without startObject\");\n      this.addInt32(0);\n      for (var i = this.offset(), e = this.vtable_in_use - 1; e >= 0 && this.vtable[e] == 0; e--);\n      for (var o = e + 1; e >= 0; e--) this.addInt16(this.vtable[e] != 0 ? i - this.vtable[e] : 0);\n      var t = 2;\n      this.addInt16(i - this.object_start);\n      var r = (o + t) * w.SIZEOF_SHORT;\n      this.addInt16(r);\n      var n = 0,\n        s = this.space;\n      t: for (e = 0; e < this.vtables.length; e++) {\n        var a = this.bb.capacity() - this.vtables[e];\n        if (r == this.bb.readInt16(a)) {\n          for (var u = w.SIZEOF_SHORT; u < r; u += w.SIZEOF_SHORT) if (this.bb.readInt16(s + u) != this.bb.readInt16(a + u)) continue t;\n          n = this.vtables[e];\n          break;\n        }\n      }\n      return n ? (this.space = this.bb.capacity() - i, this.bb.writeInt32(this.space, n - i)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - i, this.offset() - i)), this.isNested = !1, i;\n    };\n    w.Builder.prototype.finish = function (i, e, o) {\n      var t = o ? w.SIZE_PREFIX_LENGTH : 0;\n      if (e) {\n        var r = e;\n        if (this.prep(this.minalign, w.SIZEOF_INT + w.FILE_IDENTIFIER_LENGTH + t), r.length != w.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + w.FILE_IDENTIFIER_LENGTH);\n        for (var n = w.FILE_IDENTIFIER_LENGTH - 1; n >= 0; n--) this.writeInt8(r.charCodeAt(n));\n      }\n      this.prep(this.minalign, w.SIZEOF_INT + t), this.addOffset(i), t && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);\n    };\n    w.Builder.prototype.finishSizePrefixed = function (i, e) {\n      this.finish(i, e, !0);\n    };\n    w.Builder.prototype.requiredField = function (i, e) {\n      var o = this.bb.capacity() - i,\n        t = o - this.bb.readInt32(o),\n        r = this.bb.readInt16(t + e) != 0;\n      if (!r) throw new Error(\"FlatBuffers: field \" + e + \" must be set\");\n    };\n    w.Builder.prototype.startVector = function (i, e, o) {\n      this.notNested(), this.vector_num_elems = e, this.prep(w.SIZEOF_INT, i * e), this.prep(o, i * e);\n    };\n    w.Builder.prototype.endVector = function () {\n      return this.writeInt32(this.vector_num_elems), this.offset();\n    };\n    w.Builder.prototype.createString = function (i) {\n      if (i instanceof Uint8Array) var e = i;else for (var e = [], o = 0; o < i.length;) {\n        var t,\n          r = i.charCodeAt(o++);\n        if (r < 55296 || r >= 56320) t = r;else {\n          var n = i.charCodeAt(o++);\n          t = (r << 10) + n + (65536 - 56623104 - 56320);\n        }\n        t < 128 ? e.push(t) : (t < 2048 ? e.push(t >> 6 & 31 | 192) : (t < 65536 ? e.push(t >> 12 & 15 | 224) : e.push(t >> 18 & 7 | 240, t >> 12 & 63 | 128), e.push(t >> 6 & 63 | 128)), e.push(t & 63 | 128));\n      }\n      this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length);\n      for (var o = 0, s = this.space, a = this.bb.bytes(); o < e.length; o++) a[s++] = e[o];\n      return this.endVector();\n    };\n    w.Builder.prototype.createLong = function (i, e) {\n      return w.Long.create(i, e);\n    };\n    w.ByteBuffer = function (i) {\n      this.bytes_ = i, this.position_ = 0;\n    };\n    w.ByteBuffer.allocate = function (i) {\n      return new w.ByteBuffer(new Uint8Array(i));\n    };\n    w.ByteBuffer.prototype.clear = function () {\n      this.position_ = 0;\n    };\n    w.ByteBuffer.prototype.bytes = function () {\n      return this.bytes_;\n    };\n    w.ByteBuffer.prototype.position = function () {\n      return this.position_;\n    };\n    w.ByteBuffer.prototype.setPosition = function (i) {\n      this.position_ = i;\n    };\n    w.ByteBuffer.prototype.capacity = function () {\n      return this.bytes_.length;\n    };\n    w.ByteBuffer.prototype.readInt8 = function (i) {\n      return this.readUint8(i) << 24 >> 24;\n    };\n    w.ByteBuffer.prototype.readUint8 = function (i) {\n      return this.bytes_[i];\n    };\n    w.ByteBuffer.prototype.readInt16 = function (i) {\n      return this.readUint16(i) << 16 >> 16;\n    };\n    w.ByteBuffer.prototype.readUint16 = function (i) {\n      return this.bytes_[i] | this.bytes_[i + 1] << 8;\n    };\n    w.ByteBuffer.prototype.readInt32 = function (i) {\n      return this.bytes_[i] | this.bytes_[i + 1] << 8 | this.bytes_[i + 2] << 16 | this.bytes_[i + 3] << 24;\n    };\n    w.ByteBuffer.prototype.readUint32 = function (i) {\n      return this.readInt32(i) >>> 0;\n    };\n    w.ByteBuffer.prototype.readInt64 = function (i) {\n      return new w.Long(this.readInt32(i), this.readInt32(i + 4));\n    };\n    w.ByteBuffer.prototype.readUint64 = function (i) {\n      return new w.Long(this.readUint32(i), this.readUint32(i + 4));\n    };\n    w.ByteBuffer.prototype.readFloat32 = function (i) {\n      return w.int32[0] = this.readInt32(i), w.float32[0];\n    };\n    w.ByteBuffer.prototype.readFloat64 = function (i) {\n      return w.int32[w.isLittleEndian ? 0 : 1] = this.readInt32(i), w.int32[w.isLittleEndian ? 1 : 0] = this.readInt32(i + 4), w.float64[0];\n    };\n    w.ByteBuffer.prototype.writeInt8 = function (i, e) {\n      this.bytes_[i] = e;\n    };\n    w.ByteBuffer.prototype.writeUint8 = function (i, e) {\n      this.bytes_[i] = e;\n    };\n    w.ByteBuffer.prototype.writeInt16 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8;\n    };\n    w.ByteBuffer.prototype.writeUint16 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8;\n    };\n    w.ByteBuffer.prototype.writeInt32 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8, this.bytes_[i + 2] = e >> 16, this.bytes_[i + 3] = e >> 24;\n    };\n    w.ByteBuffer.prototype.writeUint32 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8, this.bytes_[i + 2] = e >> 16, this.bytes_[i + 3] = e >> 24;\n    };\n    w.ByteBuffer.prototype.writeInt64 = function (i, e) {\n      this.writeInt32(i, e.low), this.writeInt32(i + 4, e.high);\n    };\n    w.ByteBuffer.prototype.writeUint64 = function (i, e) {\n      this.writeUint32(i, e.low), this.writeUint32(i + 4, e.high);\n    };\n    w.ByteBuffer.prototype.writeFloat32 = function (i, e) {\n      w.float32[0] = e, this.writeInt32(i, w.int32[0]);\n    };\n    w.ByteBuffer.prototype.writeFloat64 = function (i, e) {\n      w.float64[0] = e, this.writeInt32(i, w.int32[w.isLittleEndian ? 0 : 1]), this.writeInt32(i + 4, w.int32[w.isLittleEndian ? 1 : 0]);\n    };\n    w.ByteBuffer.prototype.getBufferIdentifier = function () {\n      if (this.bytes_.length < this.position_ + w.SIZEOF_INT + w.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n      for (var i = \"\", e = 0; e < w.FILE_IDENTIFIER_LENGTH; e++) i += String.fromCharCode(this.readInt8(this.position_ + w.SIZEOF_INT + e));\n      return i;\n    };\n    w.ByteBuffer.prototype.__offset = function (i, e) {\n      var o = i - this.readInt32(i);\n      return e < this.readInt16(o) ? this.readInt16(o + e) : 0;\n    };\n    w.ByteBuffer.prototype.__union = function (i, e) {\n      return i.bb_pos = e + this.readInt32(e), i.bb = this, i;\n    };\n    w.ByteBuffer.prototype.__string = function (i, e) {\n      i += this.readInt32(i);\n      var o = this.readInt32(i),\n        t = \"\",\n        r = 0;\n      if (i += w.SIZEOF_INT, e === w.Encoding.UTF8_BYTES) return this.bytes_.subarray(i, i + o);\n      for (; r < o;) {\n        var n,\n          s = this.readUint8(i + r++);\n        if (s < 192) n = s;else {\n          var a = this.readUint8(i + r++);\n          if (s < 224) n = (s & 31) << 6 | a & 63;else {\n            var u = this.readUint8(i + r++);\n            if (s < 240) n = (s & 15) << 12 | (a & 63) << 6 | u & 63;else {\n              var l = this.readUint8(i + r++);\n              n = (s & 7) << 18 | (a & 63) << 12 | (u & 63) << 6 | l & 63;\n            }\n          }\n        }\n        n < 65536 ? t += String.fromCharCode(n) : (n -= 65536, t += String.fromCharCode((n >> 10) + 55296, (n & 1024 - 1) + 56320));\n      }\n      return t;\n    };\n    w.ByteBuffer.prototype.__indirect = function (i) {\n      return i + this.readInt32(i);\n    };\n    w.ByteBuffer.prototype.__vector = function (i) {\n      return i + this.readInt32(i) + w.SIZEOF_INT;\n    };\n    w.ByteBuffer.prototype.__vector_len = function (i) {\n      return this.readInt32(i + this.readInt32(i));\n    };\n    w.ByteBuffer.prototype.__has_identifier = function (i) {\n      if (i.length != w.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + w.FILE_IDENTIFIER_LENGTH);\n      for (var e = 0; e < w.FILE_IDENTIFIER_LENGTH; e++) if (i.charCodeAt(e) != this.readInt8(this.position_ + w.SIZEOF_INT + e)) return !1;\n      return !0;\n    };\n    w.ByteBuffer.prototype.createLong = function (i, e) {\n      return w.Long.create(i, e);\n    };\n  });\nvar F,\n  Pr = O(() => {\n    \"use strict\";\n\n    wn();\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (A => (A[A.UNDEFINED = 0] = \"UNDEFINED\", A[A.FLOAT = 1] = \"FLOAT\", A[A.INT = 2] = \"INT\", A[A.STRING = 3] = \"STRING\", A[A.TENSOR = 4] = \"TENSOR\", A[A.GRAPH = 5] = \"GRAPH\", A[A.FLOATS = 6] = \"FLOATS\", A[A.INTS = 7] = \"INTS\", A[A.STRINGS = 8] = \"STRINGS\", A[A.TENSORS = 9] = \"TENSORS\", A[A.GRAPHS = 10] = \"GRAPHS\", A[A.SPARSE_TENSOR = 11] = \"SPARSE_TENSOR\", A[A.SPARSE_TENSORS = 12] = \"SPARSE_TENSORS\"))(r = n.AttributeType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (l => (l[l.UNKNOWN = 0] = \"UNKNOWN\", l[l.VALUE = 1] = \"VALUE\", l[l.PARAM = 2] = \"PARAM\"))(r = n.DimensionValueType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (C => (C[C.UNDEFINED = 0] = \"UNDEFINED\", C[C.FLOAT = 1] = \"FLOAT\", C[C.UINT8 = 2] = \"UINT8\", C[C.INT8 = 3] = \"INT8\", C[C.UINT16 = 4] = \"UINT16\", C[C.INT16 = 5] = \"INT16\", C[C.INT32 = 6] = \"INT32\", C[C.INT64 = 7] = \"INT64\", C[C.STRING = 8] = \"STRING\", C[C.BOOL = 9] = \"BOOL\", C[C.FLOAT16 = 10] = \"FLOAT16\", C[C.DOUBLE = 11] = \"DOUBLE\", C[C.UINT32 = 12] = \"UINT32\", C[C.UINT64 = 13] = \"UINT64\", C[C.COMPLEX64 = 14] = \"COMPLEX64\", C[C.COMPLEX128 = 15] = \"COMPLEX128\", C[C.BFLOAT16 = 16] = \"BFLOAT16\", C[C.FLOAT8E4M3FN = 17] = \"FLOAT8E4M3FN\", C[C.FLOAT8E4M3FNUZ = 18] = \"FLOAT8E4M3FNUZ\", C[C.FLOAT8E5M2 = 19] = \"FLOAT8E5M2\", C[C.FLOAT8E5M2FNUZ = 20] = \"FLOAT8E5M2FNUZ\"))(r = n.TensorDataType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (u => (u[u.Primitive = 0] = \"Primitive\", u[u.Fused = 1] = \"Fused\"))(r = n.NodeType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (f => (f[f.NONE = 0] = \"NONE\", f[f.tensor_type = 1] = \"tensor_type\", f[f.sequence_type = 2] = \"sequence_type\", f[f.map_type = 3] = \"map_type\"))(r = n.TypeInfoValue ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsShape(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsShape(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            dim(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 4);\n              return l ? (u || new e.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            dimLength() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startShape(a) {\n              a.startObject(1);\n            }\n            static addDim(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static createDimVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startDimVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endShape(a) {\n              return a.endObject();\n            }\n            static createShape(a, u) {\n              return r.startShape(a), r.addDim(a, u), r.endShape(a);\n            }\n          }\n          n.Shape = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsDimension(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsDimension(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            value(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            denotation(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            static startDimension(a) {\n              a.startObject(2);\n            }\n            static addValue(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDenotation(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endDimension(a) {\n              return a.endObject();\n            }\n            static createDimension(a, u, l) {\n              return r.startDimension(a), r.addValue(a, u), r.addDenotation(a, l), r.endDimension(a);\n            }\n          }\n          n.Dimension = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsDimensionValue(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsDimensionValue(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            dimType() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt8(this.bb_pos + a) : 0;\n            }\n            dimValue() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            dimParam(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            static startDimensionValue(a) {\n              a.startObject(3);\n            }\n            static addDimType(a, u) {\n              a.addFieldInt8(0, u, 0);\n            }\n            static addDimValue(a, u) {\n              a.addFieldInt64(1, u, a.createLong(0, 0));\n            }\n            static addDimParam(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endDimensionValue(a) {\n              return a.endObject();\n            }\n            static createDimensionValue(a, u, l, f) {\n              return r.startDimensionValue(a), r.addDimType(a, u), r.addDimValue(a, l), r.addDimParam(a, f), r.endDimensionValue(a);\n            }\n          }\n          n.DimensionValue = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsTensorTypeAndShape(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsTensorTypeAndShape(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            elemType() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            shape(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startTensorTypeAndShape(a) {\n              a.startObject(2);\n            }\n            static addElemType(a, u) {\n              a.addFieldInt32(0, u, 0);\n            }\n            static addShape(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endTensorTypeAndShape(a) {\n              return a.endObject();\n            }\n            static createTensorTypeAndShape(a, u, l) {\n              return r.startTensorTypeAndShape(a), r.addElemType(a, u), r.addShape(a, l), r.endTensorTypeAndShape(a);\n            }\n          }\n          n.TensorTypeAndShape = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsMapType(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsMapType(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            keyType() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            valueType(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startMapType(a) {\n              a.startObject(2);\n            }\n            static addKeyType(a, u) {\n              a.addFieldInt32(0, u, 0);\n            }\n            static addValueType(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endMapType(a) {\n              return a.endObject();\n            }\n            static createMapType(a, u, l) {\n              return r.startMapType(a), r.addKeyType(a, u), r.addValueType(a, l), r.endMapType(a);\n            }\n          }\n          n.MapType = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSequenceType(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSequenceType(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            elemType(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startSequenceType(a) {\n              a.startObject(1);\n            }\n            static addElemType(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static endSequenceType(a) {\n              return a.endObject();\n            }\n            static createSequenceType(a, u) {\n              return r.startSequenceType(a), r.addElemType(a, u), r.endSequenceType(a);\n            }\n          }\n          n.SequenceType = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            nodeIndex() {\n              return this.bb.readUint32(this.bb_pos);\n            }\n            srcArgIndex() {\n              return this.bb.readInt32(this.bb_pos + 4);\n            }\n            dstArgIndex() {\n              return this.bb.readInt32(this.bb_pos + 8);\n            }\n            static createEdgeEnd(a, u, l, f) {\n              return a.prep(4, 12), a.writeInt32(f), a.writeInt32(l), a.writeInt32(u), a.offset();\n            }\n          }\n          n.EdgeEnd = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsNodeEdge(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsNodeEdge(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            nodeIndex() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readUint32(this.bb_pos + a) : 0;\n            }\n            inputEdges(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + l) + a * 12, this.bb) : null;\n            }\n            inputEdgesLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            outputEdges(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 8);\n              return l ? (u || new e.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + l) + a * 12, this.bb) : null;\n            }\n            outputEdgesLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startNodeEdge(a) {\n              a.startObject(3);\n            }\n            static addNodeIndex(a, u) {\n              a.addFieldInt32(0, u, 0);\n            }\n            static addInputEdges(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static startInputEdgesVector(a, u) {\n              a.startVector(12, u, 4);\n            }\n            static addOutputEdges(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static startOutputEdgesVector(a, u) {\n              a.startVector(12, u, 4);\n            }\n            static endNodeEdge(a) {\n              return a.endObject();\n            }\n            static createNodeEdge(a, u, l, f) {\n              return r.startNodeEdge(a), r.addNodeIndex(a, u), r.addInputEdges(a, l), r.addOutputEdges(a, f), r.endNodeEdge(a);\n            }\n          }\n          n.NodeEdge = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsNode(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsNode(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            domain(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            sinceVersion() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            index() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.readUint32(this.bb_pos + a) : 0;\n            }\n            opType(a) {\n              let u = this.bb.__offset(this.bb_pos, 14);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            type() {\n              let a = this.bb.__offset(this.bb_pos, 16);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            executionProviderType(a) {\n              let u = this.bb.__offset(this.bb_pos, 18);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            inputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 20);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            inputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 20);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            outputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 22);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            outputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 22);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            attributes(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 24);\n              return l ? (u || new e.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            attributesLength() {\n              let a = this.bb.__offset(this.bb_pos, 24);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            inputArgCounts(a) {\n              let u = this.bb.__offset(this.bb_pos, 26);\n              return u ? this.bb.readInt32(this.bb.__vector(this.bb_pos + u) + a * 4) : 0;\n            }\n            inputArgCountsLength() {\n              let a = this.bb.__offset(this.bb_pos, 26);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            inputArgCountsArray() {\n              let a = this.bb.__offset(this.bb_pos, 26);\n              return a ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            implicitInputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 28);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            implicitInputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 28);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startNode(a) {\n              a.startObject(13);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addDomain(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static addSinceVersion(a, u) {\n              a.addFieldInt32(3, u, 0);\n            }\n            static addIndex(a, u) {\n              a.addFieldInt32(4, u, 0);\n            }\n            static addOpType(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static addType(a, u) {\n              a.addFieldInt32(6, u, 0);\n            }\n            static addExecutionProviderType(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static addInputs(a, u) {\n              a.addFieldOffset(8, u, 0);\n            }\n            static createInputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startInputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addOutputs(a, u) {\n              a.addFieldOffset(9, u, 0);\n            }\n            static createOutputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startOutputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addAttributes(a, u) {\n              a.addFieldOffset(10, u, 0);\n            }\n            static createAttributesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startAttributesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addInputArgCounts(a, u) {\n              a.addFieldOffset(11, u, 0);\n            }\n            static createInputArgCountsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt32(u[l]);\n              return a.endVector();\n            }\n            static startInputArgCountsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addImplicitInputs(a, u) {\n              a.addFieldOffset(12, u, 0);\n            }\n            static createImplicitInputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startImplicitInputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endNode(a) {\n              return a.endObject();\n            }\n            static createNode(a, u, l, f, p, d, y, T, v, S, L, P, A, M) {\n              return r.startNode(a), r.addName(a, u), r.addDocString(a, l), r.addDomain(a, f), r.addSinceVersion(a, p), r.addIndex(a, d), r.addOpType(a, y), r.addType(a, T), r.addExecutionProviderType(a, v), r.addInputs(a, S), r.addOutputs(a, L), r.addAttributes(a, P), r.addInputArgCounts(a, A), r.addImplicitInputs(a, M), r.endNode(a);\n            }\n          }\n          n.Node = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsValueInfo(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsValueInfo(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            type(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? (a || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startValueInfo(a) {\n              a.startObject(3);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addType(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endValueInfo(a) {\n              return a.endObject();\n            }\n            static createValueInfo(a, u, l, f) {\n              return r.startValueInfo(a), r.addName(a, u), r.addDocString(a, l), r.addType(a, f), r.endValueInfo(a);\n            }\n          }\n          n.ValueInfo = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsTypeInfo(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsTypeInfo(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            denotation(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            valueType() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.readUint8(this.bb_pos + a) : 0;\n            }\n            value(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__union(a, this.bb_pos + u) : null;\n            }\n            static startTypeInfo(a) {\n              a.startObject(3);\n            }\n            static addDenotation(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addValueType(a, u) {\n              a.addFieldInt8(1, u, 0);\n            }\n            static addValue(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endTypeInfo(a) {\n              return a.endObject();\n            }\n            static createTypeInfo(a, u, l, f) {\n              return r.startTypeInfo(a), r.addDenotation(a, u), r.addValueType(a, l), r.addValue(a, f), r.endTypeInfo(a);\n            }\n          }\n          n.TypeInfo = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsOperatorSetId(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsOperatorSetId(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            domain(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            version() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            static startOperatorSetId(a) {\n              a.startObject(2);\n            }\n            static addDomain(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addVersion(a, u) {\n              a.addFieldInt64(1, u, a.createLong(0, 0));\n            }\n            static endOperatorSetId(a) {\n              return a.endObject();\n            }\n            static createOperatorSetId(a, u, l) {\n              return r.startOperatorSetId(a), r.addDomain(a, u), r.addVersion(a, l), r.endOperatorSetId(a);\n            }\n          }\n          n.OperatorSetId = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsTensor(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsTensor(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            dims(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            dimsLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            dataType() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            rawData(a) {\n              let u = this.bb.__offset(this.bb_pos, 12);\n              return u ? this.bb.readUint8(this.bb.__vector(this.bb_pos + u) + a) : 0;\n            }\n            rawDataLength() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            rawDataArray() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            stringData(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 14);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            stringDataLength() {\n              let a = this.bb.__offset(this.bb_pos, 14);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startTensor(a) {\n              a.startObject(6);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addDims(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static createDimsVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startDimsVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static addDataType(a, u) {\n              a.addFieldInt32(3, u, 0);\n            }\n            static addRawData(a, u) {\n              a.addFieldOffset(4, u, 0);\n            }\n            static createRawDataVector(a, u) {\n              a.startVector(1, u.length, 1);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt8(u[l]);\n              return a.endVector();\n            }\n            static startRawDataVector(a, u) {\n              a.startVector(1, u, 1);\n            }\n            static addStringData(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static createStringDataVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startStringDataVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endTensor(a) {\n              return a.endObject();\n            }\n            static createTensor(a, u, l, f, p, d, y) {\n              return r.startTensor(a), r.addName(a, u), r.addDocString(a, l), r.addDims(a, f), r.addDataType(a, p), r.addRawData(a, d), r.addStringData(a, y), r.endTensor(a);\n            }\n          }\n          n.Tensor = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSparseTensor(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSparseTensor(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            values(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            indices(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            dims(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            dimsLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startSparseTensor(a) {\n              a.startObject(3);\n            }\n            static addValues(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addIndices(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addDims(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static createDimsVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startDimsVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static endSparseTensor(a) {\n              return a.endObject();\n            }\n            static createSparseTensor(a, u, l, f) {\n              return r.startSparseTensor(a), r.addValues(a, u), r.addIndices(a, l), r.addDims(a, f), r.endSparseTensor(a);\n            }\n          }\n          n.SparseTensor = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsAttribute(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsAttribute(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            type() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            f() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readFloat32(this.bb_pos + a) : 0;\n            }\n            i() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            s(a) {\n              let u = this.bb.__offset(this.bb_pos, 14);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            t(a) {\n              let u = this.bb.__offset(this.bb_pos, 16);\n              return u ? (a || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            g(a) {\n              let u = this.bb.__offset(this.bb_pos, 18);\n              return u ? (a || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            floats(a) {\n              let u = this.bb.__offset(this.bb_pos, 20);\n              return u ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + u) + a * 4) : 0;\n            }\n            floatsLength() {\n              let a = this.bb.__offset(this.bb_pos, 20);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            floatsArray() {\n              let a = this.bb.__offset(this.bb_pos, 20);\n              return a ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            ints(a) {\n              let u = this.bb.__offset(this.bb_pos, 22);\n              return u ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            intsLength() {\n              let a = this.bb.__offset(this.bb_pos, 22);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            strings(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 24);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            stringsLength() {\n              let a = this.bb.__offset(this.bb_pos, 24);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            tensors(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 26);\n              return l ? (u || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            tensorsLength() {\n              let a = this.bb.__offset(this.bb_pos, 26);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            graphs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 28);\n              return l ? (u || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            graphsLength() {\n              let a = this.bb.__offset(this.bb_pos, 28);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startAttribute(a) {\n              a.startObject(13);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addType(a, u) {\n              a.addFieldInt32(2, u, 0);\n            }\n            static addF(a, u) {\n              a.addFieldFloat32(3, u, 0);\n            }\n            static addI(a, u) {\n              a.addFieldInt64(4, u, a.createLong(0, 0));\n            }\n            static addS(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static addT(a, u) {\n              a.addFieldOffset(6, u, 0);\n            }\n            static addG(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static addFloats(a, u) {\n              a.addFieldOffset(8, u, 0);\n            }\n            static createFloatsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addFloat32(u[l]);\n              return a.endVector();\n            }\n            static startFloatsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addInts(a, u) {\n              a.addFieldOffset(9, u, 0);\n            }\n            static createIntsVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startIntsVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static addStrings(a, u) {\n              a.addFieldOffset(10, u, 0);\n            }\n            static createStringsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startStringsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addTensors(a, u) {\n              a.addFieldOffset(11, u, 0);\n            }\n            static createTensorsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startTensorsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addGraphs(a, u) {\n              a.addFieldOffset(12, u, 0);\n            }\n            static createGraphsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startGraphsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endAttribute(a) {\n              return a.endObject();\n            }\n            static createAttribute(a, u, l, f, p, d, y, T, v, S, L, P, A, M) {\n              return r.startAttribute(a), r.addName(a, u), r.addDocString(a, l), r.addType(a, f), r.addF(a, p), r.addI(a, d), r.addS(a, y), r.addT(a, T), r.addG(a, v), r.addFloats(a, S), r.addInts(a, L), r.addStrings(a, P), r.addTensors(a, A), r.addGraphs(a, M), r.endAttribute(a);\n            }\n          }\n          n.Attribute = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsGraph(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsGraph(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            initializers(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 4);\n              return l ? (u || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            initializersLength() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            nodeArgs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            nodeArgsLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            nodes(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 8);\n              return l ? (u || new e.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            nodesLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            maxNodeIndex() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readUint32(this.bb_pos + a) : 0;\n            }\n            nodeEdges(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 12);\n              return l ? (u || new e.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            nodeEdgesLength() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            inputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 14);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            inputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 14);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            outputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 16);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            outputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 16);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            sparseInitializers(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 18);\n              return l ? (u || new e.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            sparseInitializersLength() {\n              let a = this.bb.__offset(this.bb_pos, 18);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startGraph(a) {\n              a.startObject(8);\n            }\n            static addInitializers(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static createInitializersVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startInitializersVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addNodeArgs(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createNodeArgsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startNodeArgsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addNodes(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static createNodesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startNodesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addMaxNodeIndex(a, u) {\n              a.addFieldInt32(3, u, 0);\n            }\n            static addNodeEdges(a, u) {\n              a.addFieldOffset(4, u, 0);\n            }\n            static createNodeEdgesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startNodeEdgesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addInputs(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static createInputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startInputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addOutputs(a, u) {\n              a.addFieldOffset(6, u, 0);\n            }\n            static createOutputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startOutputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addSparseInitializers(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static createSparseInitializersVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startSparseInitializersVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endGraph(a) {\n              return a.endObject();\n            }\n            static createGraph(a, u, l, f, p, d, y, T, v) {\n              return r.startGraph(a), r.addInitializers(a, u), r.addNodeArgs(a, l), r.addNodes(a, f), r.addMaxNodeIndex(a, p), r.addNodeEdges(a, d), r.addInputs(a, y), r.addOutputs(a, T), r.addSparseInitializers(a, v), r.endGraph(a);\n            }\n          }\n          n.Graph = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsModel(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsModel(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            irVersion() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            opsetImport(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            opsetImportLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            producerName(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            producerVersion(a) {\n              let u = this.bb.__offset(this.bb_pos, 10);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            domain(a) {\n              let u = this.bb.__offset(this.bb_pos, 12);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            modelVersion() {\n              let a = this.bb.__offset(this.bb_pos, 14);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 16);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            graph(a) {\n              let u = this.bb.__offset(this.bb_pos, 18);\n              return u ? (a || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            graphDocString(a) {\n              let u = this.bb.__offset(this.bb_pos, 20);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            static startModel(a) {\n              a.startObject(9);\n            }\n            static addIrVersion(a, u) {\n              a.addFieldInt64(0, u, a.createLong(0, 0));\n            }\n            static addOpsetImport(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createOpsetImportVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startOpsetImportVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addProducerName(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static addProducerVersion(a, u) {\n              a.addFieldOffset(3, u, 0);\n            }\n            static addDomain(a, u) {\n              a.addFieldOffset(4, u, 0);\n            }\n            static addModelVersion(a, u) {\n              a.addFieldInt64(5, u, a.createLong(0, 0));\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(6, u, 0);\n            }\n            static addGraph(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static addGraphDocString(a, u) {\n              a.addFieldOffset(8, u, 0);\n            }\n            static endModel(a) {\n              return a.endObject();\n            }\n            static createModel(a, u, l, f, p, d, y, T, v, S) {\n              return r.startModel(a), r.addIrVersion(a, u), r.addOpsetImport(a, l), r.addProducerName(a, f), r.addProducerVersion(a, p), r.addDomain(a, d), r.addModelVersion(a, y), r.addDocString(a, T), r.addGraph(a, v), r.addGraphDocString(a, S), r.endModel(a);\n            }\n          }\n          n.Model = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsKernelCreateInfos(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsKernelCreateInfos(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            nodeIndices(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.readUint32(this.bb.__vector(this.bb_pos + u) + a * 4) : 0;\n            }\n            nodeIndicesLength() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            nodeIndicesArray() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            kernelDefHashes(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.readUint64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            kernelDefHashesLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startKernelCreateInfos(a) {\n              a.startObject(2);\n            }\n            static addNodeIndices(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static createNodeIndicesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt32(u[l]);\n              return a.endVector();\n            }\n            static startNodeIndicesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addKernelDefHashes(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createKernelDefHashesVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startKernelDefHashesVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static endKernelCreateInfos(a) {\n              return a.endObject();\n            }\n            static createKernelCreateInfos(a, u, l) {\n              return r.startKernelCreateInfos(a), r.addNodeIndices(a, u), r.addKernelDefHashes(a, l), r.endKernelCreateInfos(a);\n            }\n          }\n          n.KernelCreateInfos = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSubGraphSessionState(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSubGraphSessionState(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            graphId(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            sessionState(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startSubGraphSessionState(a) {\n              a.startObject(2);\n            }\n            static addGraphId(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addSessionState(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endSubGraphSessionState(a) {\n              let u = a.endObject();\n              return a.requiredField(u, 4), u;\n            }\n            static createSubGraphSessionState(a, u, l) {\n              return r.startSubGraphSessionState(a), r.addGraphId(a, u), r.addSessionState(a, l), r.endSubGraphSessionState(a);\n            }\n          }\n          n.SubGraphSessionState = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSessionState(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSessionState(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            kernels(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            subGraphSessionStates(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            subGraphSessionStatesLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startSessionState(a) {\n              a.startObject(2);\n            }\n            static addKernels(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addSubGraphSessionStates(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createSubGraphSessionStatesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startSubGraphSessionStatesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endSessionState(a) {\n              return a.endObject();\n            }\n            static createSessionState(a, u, l) {\n              return r.startSessionState(a), r.addKernels(a, u), r.addSubGraphSessionStates(a, l), r.endSessionState(a);\n            }\n          }\n          n.SessionState = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsInferenceSession(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsInferenceSession(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static bufferHasIdentifier(a) {\n              return a.__has_identifier(\"ORTM\");\n            }\n            ortVersion(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            model(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            sessionState(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? (a || new e.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startInferenceSession(a) {\n              a.startObject(3);\n            }\n            static addOrtVersion(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addModel(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addSessionState(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endInferenceSession(a) {\n              return a.endObject();\n            }\n            static finishInferenceSessionBuffer(a, u) {\n              a.finish(u, \"ORTM\");\n            }\n            static finishSizePrefixedInferenceSessionBuffer(a, u) {\n              a.finish(u, \"ORTM\", !0);\n            }\n            static createInferenceSession(a, u, l, f) {\n              return r.startInferenceSession(a), r.addOrtVersion(a, u), r.addModel(a, l), r.addSessionState(a, f), r.endInferenceSession(a);\n            }\n          }\n          n.InferenceSession = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n  });\nvar js = mt((Vy, qs) => {\n  \"use strict\";\n\n  qs.exports = ih;\n  function ih(i, e) {\n    for (var o = new Array(arguments.length - 1), t = 0, r = 2, n = !0; r < arguments.length;) o[t++] = arguments[r++];\n    return new Promise(function (a, u) {\n      o[t] = function (f) {\n        if (n) if (n = !1, f) u(f);else {\n          for (var p = new Array(arguments.length - 1), d = 0; d < p.length;) p[d++] = arguments[d];\n          a.apply(null, p);\n        }\n      };\n      try {\n        i.apply(e || null, o);\n      } catch (l) {\n        n && (n = !1, u(l));\n      }\n    });\n  }\n});\nvar Ys = mt(Js => {\n  \"use strict\";\n\n  var vn = Js;\n  vn.length = function (e) {\n    var o = e.length;\n    if (!o) return 0;\n    for (var t = 0; --o % 4 > 1 && e.charAt(o) === \"=\";) ++t;\n    return Math.ceil(e.length * 3) / 4 - t;\n  };\n  var ar = new Array(64),\n    Ks = new Array(123);\n  for (te = 0; te < 64;) Ks[ar[te] = te < 26 ? te + 65 : te < 52 ? te + 71 : te < 62 ? te - 4 : te - 59 | 43] = te++;\n  var te;\n  vn.encode = function (e, o, t) {\n    for (var r = null, n = [], s = 0, a = 0, u; o < t;) {\n      var l = e[o++];\n      switch (a) {\n        case 0:\n          n[s++] = ar[l >> 2], u = (l & 3) << 4, a = 1;\n          break;\n        case 1:\n          n[s++] = ar[u | l >> 4], u = (l & 15) << 2, a = 2;\n          break;\n        case 2:\n          n[s++] = ar[u | l >> 6], n[s++] = ar[l & 63], a = 0;\n          break;\n      }\n      s > 8191 && ((r || (r = [])).push(String.fromCharCode.apply(String, n)), s = 0);\n    }\n    return a && (n[s++] = ar[u], n[s++] = 61, a === 1 && (n[s++] = 61)), r ? (s && r.push(String.fromCharCode.apply(String, n.slice(0, s))), r.join(\"\")) : String.fromCharCode.apply(String, n.slice(0, s));\n  };\n  var Xs = \"invalid encoding\";\n  vn.decode = function (e, o, t) {\n    for (var r = t, n = 0, s, a = 0; a < e.length;) {\n      var u = e.charCodeAt(a++);\n      if (u === 61 && n > 1) break;\n      if ((u = Ks[u]) === void 0) throw Error(Xs);\n      switch (n) {\n        case 0:\n          s = u, n = 1;\n          break;\n        case 1:\n          o[t++] = s << 2 | (u & 48) >> 4, s = u, n = 2;\n          break;\n        case 2:\n          o[t++] = (s & 15) << 4 | (u & 60) >> 2, s = u, n = 3;\n          break;\n        case 3:\n          o[t++] = (s & 3) << 6 | u, n = 0;\n          break;\n      }\n    }\n    if (n === 1) throw Error(Xs);\n    return t - r;\n  };\n  vn.test = function (e) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);\n  };\n});\nvar Qs = mt((Wy, Zs) => {\n  \"use strict\";\n\n  Zs.exports = In;\n  function In() {\n    this._listeners = {};\n  }\n  In.prototype.on = function (e, o, t) {\n    return (this._listeners[e] || (this._listeners[e] = [])).push({\n      fn: o,\n      ctx: t || this\n    }), this;\n  };\n  In.prototype.off = function (e, o) {\n    if (e === void 0) this._listeners = {};else if (o === void 0) this._listeners[e] = [];else for (var t = this._listeners[e], r = 0; r < t.length;) t[r].fn === o ? t.splice(r, 1) : ++r;\n    return this;\n  };\n  In.prototype.emit = function (e) {\n    var o = this._listeners[e];\n    if (o) {\n      for (var t = [], r = 1; r < arguments.length;) t.push(arguments[r++]);\n      for (r = 0; r < o.length;) o[r].fn.apply(o[r++].ctx, t);\n    }\n    return this;\n  };\n});\nvar au = mt((Hy, iu) => {\n  \"use strict\";\n\n  iu.exports = tu(tu);\n  function tu(i) {\n    return typeof Float32Array < \"u\" ? function () {\n      var e = new Float32Array([-0]),\n        o = new Uint8Array(e.buffer),\n        t = o[3] === 128;\n      function r(u, l, f) {\n        e[0] = u, l[f] = o[0], l[f + 1] = o[1], l[f + 2] = o[2], l[f + 3] = o[3];\n      }\n      function n(u, l, f) {\n        e[0] = u, l[f] = o[3], l[f + 1] = o[2], l[f + 2] = o[1], l[f + 3] = o[0];\n      }\n      i.writeFloatLE = t ? r : n, i.writeFloatBE = t ? n : r;\n      function s(u, l) {\n        return o[0] = u[l], o[1] = u[l + 1], o[2] = u[l + 2], o[3] = u[l + 3], e[0];\n      }\n      function a(u, l) {\n        return o[3] = u[l], o[2] = u[l + 1], o[1] = u[l + 2], o[0] = u[l + 3], e[0];\n      }\n      i.readFloatLE = t ? s : a, i.readFloatBE = t ? a : s;\n    }() : function () {\n      function e(t, r, n, s) {\n        var a = r < 0 ? 1 : 0;\n        if (a && (r = -r), r === 0) t(1 / r > 0 ? 0 : 2147483648, n, s);else if (isNaN(r)) t(2143289344, n, s);else if (r > 34028234663852886e22) t((a << 31 | 2139095040) >>> 0, n, s);else if (r < 11754943508222875e-54) t((a << 31 | Math.round(r / 1401298464324817e-60)) >>> 0, n, s);else {\n          var u = Math.floor(Math.log(r) / Math.LN2),\n            l = Math.round(r * Math.pow(2, -u) * 8388608) & 8388607;\n          t((a << 31 | u + 127 << 23 | l) >>> 0, n, s);\n        }\n      }\n      i.writeFloatLE = e.bind(null, eu), i.writeFloatBE = e.bind(null, ru);\n      function o(t, r, n) {\n        var s = t(r, n),\n          a = (s >> 31) * 2 + 1,\n          u = s >>> 23 & 255,\n          l = s & 8388607;\n        return u === 255 ? l ? NaN : a * (1 / 0) : u === 0 ? a * 1401298464324817e-60 * l : a * Math.pow(2, u - 150) * (l + 8388608);\n      }\n      i.readFloatLE = o.bind(null, nu), i.readFloatBE = o.bind(null, ou);\n    }(), typeof Float64Array < \"u\" ? function () {\n      var e = new Float64Array([-0]),\n        o = new Uint8Array(e.buffer),\n        t = o[7] === 128;\n      function r(u, l, f) {\n        e[0] = u, l[f] = o[0], l[f + 1] = o[1], l[f + 2] = o[2], l[f + 3] = o[3], l[f + 4] = o[4], l[f + 5] = o[5], l[f + 6] = o[6], l[f + 7] = o[7];\n      }\n      function n(u, l, f) {\n        e[0] = u, l[f] = o[7], l[f + 1] = o[6], l[f + 2] = o[5], l[f + 3] = o[4], l[f + 4] = o[3], l[f + 5] = o[2], l[f + 6] = o[1], l[f + 7] = o[0];\n      }\n      i.writeDoubleLE = t ? r : n, i.writeDoubleBE = t ? n : r;\n      function s(u, l) {\n        return o[0] = u[l], o[1] = u[l + 1], o[2] = u[l + 2], o[3] = u[l + 3], o[4] = u[l + 4], o[5] = u[l + 5], o[6] = u[l + 6], o[7] = u[l + 7], e[0];\n      }\n      function a(u, l) {\n        return o[7] = u[l], o[6] = u[l + 1], o[5] = u[l + 2], o[4] = u[l + 3], o[3] = u[l + 4], o[2] = u[l + 5], o[1] = u[l + 6], o[0] = u[l + 7], e[0];\n      }\n      i.readDoubleLE = t ? s : a, i.readDoubleBE = t ? a : s;\n    }() : function () {\n      function e(t, r, n, s, a, u) {\n        var l = s < 0 ? 1 : 0;\n        if (l && (s = -s), s === 0) t(0, a, u + r), t(1 / s > 0 ? 0 : 2147483648, a, u + n);else if (isNaN(s)) t(0, a, u + r), t(2146959360, a, u + n);else if (s > 17976931348623157e292) t(0, a, u + r), t((l << 31 | 2146435072) >>> 0, a, u + n);else {\n          var f;\n          if (s < 22250738585072014e-324) f = s / 5e-324, t(f >>> 0, a, u + r), t((l << 31 | f / 4294967296) >>> 0, a, u + n);else {\n            var p = Math.floor(Math.log(s) / Math.LN2);\n            p === 1024 && (p = 1023), f = s * Math.pow(2, -p), t(f * 4503599627370496 >>> 0, a, u + r), t((l << 31 | p + 1023 << 20 | f * 1048576 & 1048575) >>> 0, a, u + n);\n          }\n        }\n      }\n      i.writeDoubleLE = e.bind(null, eu, 0, 4), i.writeDoubleBE = e.bind(null, ru, 4, 0);\n      function o(t, r, n, s, a) {\n        var u = t(s, a + r),\n          l = t(s, a + n),\n          f = (l >> 31) * 2 + 1,\n          p = l >>> 20 & 2047,\n          d = 4294967296 * (l & 1048575) + u;\n        return p === 2047 ? d ? NaN : f * (1 / 0) : p === 0 ? f * 5e-324 * d : f * Math.pow(2, p - 1075) * (d + 4503599627370496);\n      }\n      i.readDoubleLE = o.bind(null, nu, 0, 4), i.readDoubleBE = o.bind(null, ou, 4, 0);\n    }(), i;\n  }\n  function eu(i, e, o) {\n    e[o] = i & 255, e[o + 1] = i >>> 8 & 255, e[o + 2] = i >>> 16 & 255, e[o + 3] = i >>> 24;\n  }\n  function ru(i, e, o) {\n    e[o] = i >>> 24, e[o + 1] = i >>> 16 & 255, e[o + 2] = i >>> 8 & 255, e[o + 3] = i & 255;\n  }\n  function nu(i, e) {\n    return (i[e] | i[e + 1] << 8 | i[e + 2] << 16 | i[e + 3] << 24) >>> 0;\n  }\n  function ou(i, e) {\n    return (i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3]) >>> 0;\n  }\n});\nvar su = mt((exports, module) => {\n  \"use strict\";\n\n  module.exports = inquire;\n  function inquire(moduleName) {\n    try {\n      var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n      if (mod && (mod.length || Object.keys(mod).length)) return mod;\n    } catch (i) {}\n    return null;\n  }\n});\nvar lu = mt(uu => {\n  \"use strict\";\n\n  var jo = uu;\n  jo.length = function (e) {\n    for (var o = 0, t = 0, r = 0; r < e.length; ++r) t = e.charCodeAt(r), t < 128 ? o += 1 : t < 2048 ? o += 2 : (t & 64512) === 55296 && (e.charCodeAt(r + 1) & 64512) === 56320 ? (++r, o += 4) : o += 3;\n    return o;\n  };\n  jo.read = function (e, o, t) {\n    var r = t - o;\n    if (r < 1) return \"\";\n    for (var n = null, s = [], a = 0, u; o < t;) u = e[o++], u < 128 ? s[a++] = u : u > 191 && u < 224 ? s[a++] = (u & 31) << 6 | e[o++] & 63 : u > 239 && u < 365 ? (u = ((u & 7) << 18 | (e[o++] & 63) << 12 | (e[o++] & 63) << 6 | e[o++] & 63) - 65536, s[a++] = 55296 + (u >> 10), s[a++] = 56320 + (u & 1023)) : s[a++] = (u & 15) << 12 | (e[o++] & 63) << 6 | e[o++] & 63, a > 8191 && ((n || (n = [])).push(String.fromCharCode.apply(String, s)), a = 0);\n    return n ? (a && n.push(String.fromCharCode.apply(String, s.slice(0, a))), n.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, a));\n  };\n  jo.write = function (e, o, t) {\n    for (var r = t, n, s, a = 0; a < e.length; ++a) n = e.charCodeAt(a), n < 128 ? o[t++] = n : n < 2048 ? (o[t++] = n >> 6 | 192, o[t++] = n & 63 | 128) : (n & 64512) === 55296 && ((s = e.charCodeAt(a + 1)) & 64512) === 56320 ? (n = 65536 + ((n & 1023) << 10) + (s & 1023), ++a, o[t++] = n >> 18 | 240, o[t++] = n >> 12 & 63 | 128, o[t++] = n >> 6 & 63 | 128, o[t++] = n & 63 | 128) : (o[t++] = n >> 12 | 224, o[t++] = n >> 6 & 63 | 128, o[t++] = n & 63 | 128);\n    return t - r;\n  };\n});\nvar cu = mt((jy, fu) => {\n  \"use strict\";\n\n  fu.exports = ah;\n  function ah(i, e, o) {\n    var t = o || 8192,\n      r = t >>> 1,\n      n = null,\n      s = t;\n    return function (u) {\n      if (u < 1 || u > r) return i(u);\n      s + u > t && (n = i(t), s = 0);\n      var l = e.call(n, s, s += u);\n      return s & 7 && (s = (s | 7) + 1), l;\n    };\n  }\n});\nvar du = mt((Xy, pu) => {\n  \"use strict\";\n\n  pu.exports = vt;\n  var Er = Se();\n  function vt(i, e) {\n    this.lo = i >>> 0, this.hi = e >>> 0;\n  }\n  var Re = vt.zero = new vt(0, 0);\n  Re.toNumber = function () {\n    return 0;\n  };\n  Re.zzEncode = Re.zzDecode = function () {\n    return this;\n  };\n  Re.length = function () {\n    return 1;\n  };\n  var sh = vt.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n  vt.fromNumber = function (e) {\n    if (e === 0) return Re;\n    var o = e < 0;\n    o && (e = -e);\n    var t = e >>> 0,\n      r = (e - t) / 4294967296 >>> 0;\n    return o && (r = ~r >>> 0, t = ~t >>> 0, ++t > 4294967295 && (t = 0, ++r > 4294967295 && (r = 0))), new vt(t, r);\n  };\n  vt.from = function (e) {\n    if (typeof e == \"number\") return vt.fromNumber(e);\n    if (Er.isString(e)) if (Er.Long) e = Er.Long.fromString(e);else return vt.fromNumber(parseInt(e, 10));\n    return e.low || e.high ? new vt(e.low >>> 0, e.high >>> 0) : Re;\n  };\n  vt.prototype.toNumber = function (e) {\n    if (!e && this.hi >>> 31) {\n      var o = ~this.lo + 1 >>> 0,\n        t = ~this.hi >>> 0;\n      return o || (t = t + 1 >>> 0), -(o + t * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n  };\n  vt.prototype.toLong = function (e) {\n    return Er.Long ? new Er.Long(this.lo | 0, this.hi | 0, !!e) : {\n      low: this.lo | 0,\n      high: this.hi | 0,\n      unsigned: !!e\n    };\n  };\n  var Oe = String.prototype.charCodeAt;\n  vt.fromHash = function (e) {\n    return e === sh ? Re : new vt((Oe.call(e, 0) | Oe.call(e, 1) << 8 | Oe.call(e, 2) << 16 | Oe.call(e, 3) << 24) >>> 0, (Oe.call(e, 4) | Oe.call(e, 5) << 8 | Oe.call(e, 6) << 16 | Oe.call(e, 7) << 24) >>> 0);\n  };\n  vt.prototype.toHash = function () {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n  };\n  vt.prototype.zzEncode = function () {\n    var e = this.hi >> 31;\n    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;\n  };\n  vt.prototype.zzDecode = function () {\n    var e = -(this.lo & 1);\n    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;\n  };\n  vt.prototype.length = function () {\n    var e = this.lo,\n      o = (this.lo >>> 28 | this.hi << 4) >>> 0,\n      t = this.hi >>> 24;\n    return t === 0 ? o === 0 ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : o < 16384 ? o < 128 ? 5 : 6 : o < 2097152 ? 7 : 8 : t < 128 ? 9 : 10;\n  };\n});\nvar Se = mt(Xo => {\n  \"use strict\";\n\n  var N = Xo;\n  N.asPromise = js();\n  N.base64 = Ys();\n  N.EventEmitter = Qs();\n  N.float = au();\n  N.inquire = su();\n  N.utf8 = lu();\n  N.pool = cu();\n  N.LongBits = du();\n  N.isNode = !!(typeof global < \"u\" && global && global.process && global.process.versions && global.process.versions.node);\n  N.global = N.isNode && global || typeof window < \"u\" && window || typeof self < \"u\" && self || Xo;\n  N.emptyArray = Object.freeze ? Object.freeze([]) : [];\n  N.emptyObject = Object.freeze ? Object.freeze({}) : {};\n  N.isInteger = Number.isInteger || function (e) {\n    return typeof e == \"number\" && isFinite(e) && Math.floor(e) === e;\n  };\n  N.isString = function (e) {\n    return typeof e == \"string\" || e instanceof String;\n  };\n  N.isObject = function (e) {\n    return e && typeof e == \"object\";\n  };\n  N.isset = N.isSet = function (e, o) {\n    var t = e[o];\n    return t != null && e.hasOwnProperty(o) ? typeof t != \"object\" || (Array.isArray(t) ? t.length : Object.keys(t).length) > 0 : !1;\n  };\n  N.Buffer = function () {\n    try {\n      var i = N.inquire(\"buffer\").Buffer;\n      return i.prototype.utf8Write ? i : null;\n    } catch {\n      return null;\n    }\n  }();\n  N._Buffer_from = null;\n  N._Buffer_allocUnsafe = null;\n  N.newBuffer = function (e) {\n    return typeof e == \"number\" ? N.Buffer ? N._Buffer_allocUnsafe(e) : new N.Array(e) : N.Buffer ? N._Buffer_from(e) : typeof Uint8Array > \"u\" ? e : new Uint8Array(e);\n  };\n  N.Array = typeof Uint8Array < \"u\" ? Uint8Array : Array;\n  N.Long = N.global.dcodeIO && N.global.dcodeIO.Long || N.global.Long || N.inquire(\"long\");\n  N.key2Re = /^true|false|0|1$/;\n  N.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n  N.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n  N.longToHash = function (e) {\n    return e ? N.LongBits.from(e).toHash() : N.LongBits.zeroHash;\n  };\n  N.longFromHash = function (e, o) {\n    var t = N.LongBits.fromHash(e);\n    return N.Long ? N.Long.fromBits(t.lo, t.hi, o) : t.toNumber(!!o);\n  };\n  function hu(i, e, o) {\n    for (var t = Object.keys(e), r = 0; r < t.length; ++r) (i[t[r]] === void 0 || !o) && (i[t[r]] = e[t[r]]);\n    return i;\n  }\n  N.merge = hu;\n  N.lcFirst = function (e) {\n    return e.charAt(0).toLowerCase() + e.substring(1);\n  };\n  function mu(i) {\n    function e(o, t) {\n      if (!(this instanceof e)) return new e(o, t);\n      Object.defineProperty(this, \"message\", {\n        get: function () {\n          return o;\n        }\n      }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, \"stack\", {\n        value: new Error().stack || \"\"\n      }), t && hu(this, t);\n    }\n    return e.prototype = Object.create(Error.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        enumerable: !1,\n        configurable: !0\n      },\n      name: {\n        get: function () {\n          return i;\n        },\n        set: void 0,\n        enumerable: !1,\n        configurable: !0\n      },\n      toString: {\n        value: function () {\n          return this.name + \": \" + this.message;\n        },\n        writable: !0,\n        enumerable: !1,\n        configurable: !0\n      }\n    }), e;\n  }\n  N.newError = mu;\n  N.ProtocolError = mu(\"ProtocolError\");\n  N.oneOfGetter = function (e) {\n    for (var o = {}, t = 0; t < e.length; ++t) o[e[t]] = 1;\n    return function () {\n      for (var r = Object.keys(this), n = r.length - 1; n > -1; --n) if (o[r[n]] === 1 && this[r[n]] !== void 0 && this[r[n]] !== null) return r[n];\n    };\n  };\n  N.oneOfSetter = function (e) {\n    return function (o) {\n      for (var t = 0; t < e.length; ++t) e[t] !== o && delete this[e[t]];\n    };\n  };\n  N.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: !0\n  };\n  N._configure = function () {\n    var i = N.Buffer;\n    if (!i) {\n      N._Buffer_from = N._Buffer_allocUnsafe = null;\n      return;\n    }\n    N._Buffer_from = i.from !== Uint8Array.from && i.from || function (o, t) {\n      return new i(o, t);\n    }, N._Buffer_allocUnsafe = i.allocUnsafe || function (o) {\n      return new i(o);\n    };\n  };\n});\nvar ei = mt((Jy, xu) => {\n  \"use strict\";\n\n  xu.exports = X;\n  var Wt = Se(),\n    Ko,\n    _n = Wt.LongBits,\n    bu = Wt.base64,\n    gu = Wt.utf8;\n  function Dr(i, e, o) {\n    this.fn = i, this.len = e, this.next = void 0, this.val = o;\n  }\n  function Yo() {}\n  function uh(i) {\n    this.head = i.head, this.tail = i.tail, this.len = i.len, this.next = i.states;\n  }\n  function X() {\n    this.len = 0, this.head = new Dr(Yo, 0, 0), this.tail = this.head, this.states = null;\n  }\n  var yu = function () {\n    return Wt.Buffer ? function () {\n      return (X.create = function () {\n        return new Ko();\n      })();\n    } : function () {\n      return new X();\n    };\n  };\n  X.create = yu();\n  X.alloc = function (e) {\n    return new Wt.Array(e);\n  };\n  Wt.Array !== Array && (X.alloc = Wt.pool(X.alloc, Wt.Array.prototype.subarray));\n  X.prototype._push = function (e, o, t) {\n    return this.tail = this.tail.next = new Dr(e, o, t), this.len += o, this;\n  };\n  function Zo(i, e, o) {\n    e[o] = i & 255;\n  }\n  function lh(i, e, o) {\n    for (; i > 127;) e[o++] = i & 127 | 128, i >>>= 7;\n    e[o] = i;\n  }\n  function Qo(i, e) {\n    this.len = i, this.next = void 0, this.val = e;\n  }\n  Qo.prototype = Object.create(Dr.prototype);\n  Qo.prototype.fn = lh;\n  X.prototype.uint32 = function (e) {\n    return this.len += (this.tail = this.tail.next = new Qo((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;\n  };\n  X.prototype.int32 = function (e) {\n    return e < 0 ? this._push(ti, 10, _n.fromNumber(e)) : this.uint32(e);\n  };\n  X.prototype.sint32 = function (e) {\n    return this.uint32((e << 1 ^ e >> 31) >>> 0);\n  };\n  function ti(i, e, o) {\n    for (; i.hi;) e[o++] = i.lo & 127 | 128, i.lo = (i.lo >>> 7 | i.hi << 25) >>> 0, i.hi >>>= 7;\n    for (; i.lo > 127;) e[o++] = i.lo & 127 | 128, i.lo = i.lo >>> 7;\n    e[o++] = i.lo;\n  }\n  X.prototype.uint64 = function (e) {\n    var o = _n.from(e);\n    return this._push(ti, o.length(), o);\n  };\n  X.prototype.int64 = X.prototype.uint64;\n  X.prototype.sint64 = function (e) {\n    var o = _n.from(e).zzEncode();\n    return this._push(ti, o.length(), o);\n  };\n  X.prototype.bool = function (e) {\n    return this._push(Zo, 1, e ? 1 : 0);\n  };\n  function Jo(i, e, o) {\n    e[o] = i & 255, e[o + 1] = i >>> 8 & 255, e[o + 2] = i >>> 16 & 255, e[o + 3] = i >>> 24;\n  }\n  X.prototype.fixed32 = function (e) {\n    return this._push(Jo, 4, e >>> 0);\n  };\n  X.prototype.sfixed32 = X.prototype.fixed32;\n  X.prototype.fixed64 = function (e) {\n    var o = _n.from(e);\n    return this._push(Jo, 4, o.lo)._push(Jo, 4, o.hi);\n  };\n  X.prototype.sfixed64 = X.prototype.fixed64;\n  X.prototype.float = function (e) {\n    return this._push(Wt.float.writeFloatLE, 4, e);\n  };\n  X.prototype.double = function (e) {\n    return this._push(Wt.float.writeDoubleLE, 8, e);\n  };\n  var fh = Wt.Array.prototype.set ? function (e, o, t) {\n    o.set(e, t);\n  } : function (e, o, t) {\n    for (var r = 0; r < e.length; ++r) o[t + r] = e[r];\n  };\n  X.prototype.bytes = function (e) {\n    var o = e.length >>> 0;\n    if (!o) return this._push(Zo, 1, 0);\n    if (Wt.isString(e)) {\n      var t = X.alloc(o = bu.length(e));\n      bu.decode(e, t, 0), e = t;\n    }\n    return this.uint32(o)._push(fh, o, e);\n  };\n  X.prototype.string = function (e) {\n    var o = gu.length(e);\n    return o ? this.uint32(o)._push(gu.write, o, e) : this._push(Zo, 1, 0);\n  };\n  X.prototype.fork = function () {\n    return this.states = new uh(this), this.head = this.tail = new Dr(Yo, 0, 0), this.len = 0, this;\n  };\n  X.prototype.reset = function () {\n    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Dr(Yo, 0, 0), this.len = 0), this;\n  };\n  X.prototype.ldelim = function () {\n    var e = this.head,\n      o = this.tail,\n      t = this.len;\n    return this.reset().uint32(t), t && (this.tail.next = e.next, this.tail = o, this.len += t), this;\n  };\n  X.prototype.finish = function () {\n    for (var e = this.head.next, o = this.constructor.alloc(this.len), t = 0; e;) e.fn(e.val, o, t), t += e.len, e = e.next;\n    return o;\n  };\n  X._configure = function (i) {\n    Ko = i, X.create = yu(), Ko._configure();\n  };\n});\nvar vu = mt((Yy, wu) => {\n  \"use strict\";\n\n  wu.exports = ce;\n  var Tu = ei();\n  (ce.prototype = Object.create(Tu.prototype)).constructor = ce;\n  var Ae = Se();\n  function ce() {\n    Tu.call(this);\n  }\n  ce._configure = function () {\n    ce.alloc = Ae._Buffer_allocUnsafe, ce.writeBytesBuffer = Ae.Buffer && Ae.Buffer.prototype instanceof Uint8Array && Ae.Buffer.prototype.set.name === \"set\" ? function (e, o, t) {\n      o.set(e, t);\n    } : function (e, o, t) {\n      if (e.copy) e.copy(o, t, 0, e.length);else for (var r = 0; r < e.length;) o[t++] = e[r++];\n    };\n  };\n  ce.prototype.bytes = function (e) {\n    Ae.isString(e) && (e = Ae._Buffer_from(e, \"base64\"));\n    var o = e.length >>> 0;\n    return this.uint32(o), o && this._push(ce.writeBytesBuffer, o, e), this;\n  };\n  function ch(i, e, o) {\n    i.length < 40 ? Ae.utf8.write(i, e, o) : e.utf8Write ? e.utf8Write(i, o) : e.write(i, o);\n  }\n  ce.prototype.string = function (e) {\n    var o = Ae.Buffer.byteLength(e);\n    return this.uint32(o), o && this._push(ch, o, e), this;\n  };\n  ce._configure();\n});\nvar oi = mt((Zy, Au) => {\n  \"use strict\";\n\n  Au.exports = ct;\n  var ee = Se(),\n    ni,\n    Ou = ee.LongBits,\n    ph = ee.utf8;\n  function re(i, e) {\n    return RangeError(\"index out of range: \" + i.pos + \" + \" + (e || 1) + \" > \" + i.len);\n  }\n  function ct(i) {\n    this.buf = i, this.pos = 0, this.len = i.length;\n  }\n  var Iu = typeof Uint8Array < \"u\" ? function (e) {\n      if (e instanceof Uint8Array || Array.isArray(e)) return new ct(e);\n      throw Error(\"illegal buffer\");\n    } : function (e) {\n      if (Array.isArray(e)) return new ct(e);\n      throw Error(\"illegal buffer\");\n    },\n    Su = function () {\n      return ee.Buffer ? function (o) {\n        return (ct.create = function (r) {\n          return ee.Buffer.isBuffer(r) ? new ni(r) : Iu(r);\n        })(o);\n      } : Iu;\n    };\n  ct.create = Su();\n  ct.prototype._slice = ee.Array.prototype.subarray || ee.Array.prototype.slice;\n  ct.prototype.uint32 = function () {\n    var e = 4294967295;\n    return function () {\n      if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return e;\n      if ((this.pos += 5) > this.len) throw this.pos = this.len, re(this, 10);\n      return e;\n    };\n  }();\n  ct.prototype.int32 = function () {\n    return this.uint32() | 0;\n  };\n  ct.prototype.sint32 = function () {\n    var e = this.uint32();\n    return e >>> 1 ^ -(e & 1) | 0;\n  };\n  function ri() {\n    var i = new Ou(0, 0),\n      e = 0;\n    if (this.len - this.pos > 4) {\n      for (; e < 4; ++e) if (i.lo = (i.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return i;\n      if (i.lo = (i.lo | (this.buf[this.pos] & 127) << 28) >>> 0, i.hi = (i.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return i;\n      e = 0;\n    } else {\n      for (; e < 3; ++e) {\n        if (this.pos >= this.len) throw re(this);\n        if (i.lo = (i.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return i;\n      }\n      return i.lo = (i.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, i;\n    }\n    if (this.len - this.pos > 4) {\n      for (; e < 5; ++e) if (i.hi = (i.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return i;\n    } else for (; e < 5; ++e) {\n      if (this.pos >= this.len) throw re(this);\n      if (i.hi = (i.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return i;\n    }\n    throw Error(\"invalid varint encoding\");\n  }\n  ct.prototype.bool = function () {\n    return this.uint32() !== 0;\n  };\n  function On(i, e) {\n    return (i[e - 4] | i[e - 3] << 8 | i[e - 2] << 16 | i[e - 1] << 24) >>> 0;\n  }\n  ct.prototype.fixed32 = function () {\n    if (this.pos + 4 > this.len) throw re(this, 4);\n    return On(this.buf, this.pos += 4);\n  };\n  ct.prototype.sfixed32 = function () {\n    if (this.pos + 4 > this.len) throw re(this, 4);\n    return On(this.buf, this.pos += 4) | 0;\n  };\n  function _u() {\n    if (this.pos + 8 > this.len) throw re(this, 8);\n    return new Ou(On(this.buf, this.pos += 4), On(this.buf, this.pos += 4));\n  }\n  ct.prototype.float = function () {\n    if (this.pos + 4 > this.len) throw re(this, 4);\n    var e = ee.float.readFloatLE(this.buf, this.pos);\n    return this.pos += 4, e;\n  };\n  ct.prototype.double = function () {\n    if (this.pos + 8 > this.len) throw re(this, 4);\n    var e = ee.float.readDoubleLE(this.buf, this.pos);\n    return this.pos += 8, e;\n  };\n  ct.prototype.bytes = function () {\n    var e = this.uint32(),\n      o = this.pos,\n      t = this.pos + e;\n    if (t > this.len) throw re(this, e);\n    if (this.pos += e, Array.isArray(this.buf)) return this.buf.slice(o, t);\n    if (o === t) {\n      var r = ee.Buffer;\n      return r ? r.alloc(0) : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, o, t);\n  };\n  ct.prototype.string = function () {\n    var e = this.bytes();\n    return ph.read(e, 0, e.length);\n  };\n  ct.prototype.skip = function (e) {\n    if (typeof e == \"number\") {\n      if (this.pos + e > this.len) throw re(this, e);\n      this.pos += e;\n    } else do if (this.pos >= this.len) throw re(this); while (this.buf[this.pos++] & 128);\n    return this;\n  };\n  ct.prototype.skipType = function (i) {\n    switch (i) {\n      case 0:\n        this.skip();\n        break;\n      case 1:\n        this.skip(8);\n        break;\n      case 2:\n        this.skip(this.uint32());\n        break;\n      case 3:\n        for (; (i = this.uint32() & 7) !== 4;) this.skipType(i);\n        break;\n      case 5:\n        this.skip(4);\n        break;\n      default:\n        throw Error(\"invalid wire type \" + i + \" at offset \" + this.pos);\n    }\n    return this;\n  };\n  ct._configure = function (i) {\n    ni = i, ct.create = Su(), ni._configure();\n    var e = ee.Long ? \"toLong\" : \"toNumber\";\n    ee.merge(ct.prototype, {\n      int64: function () {\n        return ri.call(this)[e](!1);\n      },\n      uint64: function () {\n        return ri.call(this)[e](!0);\n      },\n      sint64: function () {\n        return ri.call(this).zzDecode()[e](!1);\n      },\n      fixed64: function () {\n        return _u.call(this)[e](!0);\n      },\n      sfixed64: function () {\n        return _u.call(this)[e](!1);\n      }\n    });\n  };\n});\nvar Lu = mt((Qy, Du) => {\n  \"use strict\";\n\n  Du.exports = Ge;\n  var Eu = oi();\n  (Ge.prototype = Object.create(Eu.prototype)).constructor = Ge;\n  var Pu = Se();\n  function Ge(i) {\n    Eu.call(this, i);\n  }\n  Ge._configure = function () {\n    Pu.Buffer && (Ge.prototype._slice = Pu.Buffer.prototype.slice);\n  };\n  Ge.prototype.string = function () {\n    var e = this.uint32();\n    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + e, this.len));\n  };\n  Ge._configure();\n});\nvar ku = mt((tx, $u) => {\n  \"use strict\";\n\n  $u.exports = Lr;\n  var ii = Se();\n  (Lr.prototype = Object.create(ii.EventEmitter.prototype)).constructor = Lr;\n  function Lr(i, e, o) {\n    if (typeof i != \"function\") throw TypeError(\"rpcImpl must be a function\");\n    ii.EventEmitter.call(this), this.rpcImpl = i, this.requestDelimited = !!e, this.responseDelimited = !!o;\n  }\n  Lr.prototype.rpcCall = function i(e, o, t, r, n) {\n    if (!r) throw TypeError(\"request must be specified\");\n    var s = this;\n    if (!n) return ii.asPromise(i, s, e, o, t, r);\n    if (!s.rpcImpl) {\n      setTimeout(function () {\n        n(Error(\"already ended\"));\n      }, 0);\n      return;\n    }\n    try {\n      return s.rpcImpl(e, o[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](r).finish(), function (u, l) {\n        if (u) return s.emit(\"error\", u, e), n(u);\n        if (l === null) {\n          s.end(!0);\n          return;\n        }\n        if (!(l instanceof t)) try {\n          l = t[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](l);\n        } catch (f) {\n          return s.emit(\"error\", f, e), n(f);\n        }\n        return s.emit(\"data\", l, e), n(null, l);\n      });\n    } catch (a) {\n      s.emit(\"error\", a, e), setTimeout(function () {\n        n(a);\n      }, 0);\n      return;\n    }\n  };\n  Lr.prototype.end = function (e) {\n    return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n  };\n});\nvar Fu = mt(Bu => {\n  \"use strict\";\n\n  var dh = Bu;\n  dh.Service = ku();\n});\nvar Nu = mt((rx, Cu) => {\n  \"use strict\";\n\n  Cu.exports = {};\n});\nvar Mu = mt(Gu => {\n  \"use strict\";\n\n  var Nt = Gu;\n  Nt.build = \"minimal\";\n  Nt.Writer = ei();\n  Nt.BufferWriter = vu();\n  Nt.Reader = oi();\n  Nt.BufferReader = Lu();\n  Nt.util = Se();\n  Nt.rpc = Fu();\n  Nt.roots = Nu();\n  Nt.configure = Ru;\n  function Ru() {\n    Nt.util._configure(), Nt.Writer._configure(Nt.BufferWriter), Nt.Reader._configure(Nt.BufferReader);\n  }\n  Ru();\n});\nvar Vu = mt((ox, Uu) => {\n  \"use strict\";\n\n  Uu.exports = Mu();\n});\nvar sr = mt((ix, zu) => {\n  \"use strict\";\n\n  var nt = Vu(),\n    $ = nt.Reader,\n    pt = nt.Writer,\n    b = nt.util,\n    h = nt.roots.default || (nt.roots.default = {});\n  h.onnx = function () {\n    var i = {};\n    return i.Version = function () {\n      var e = {},\n        o = Object.create(e);\n      return o[e[0] = \"_START_VERSION\"] = 0, o[e[1] = \"IR_VERSION_2017_10_10\"] = 1, o[e[2] = \"IR_VERSION_2017_10_30\"] = 2, o[e[3] = \"IR_VERSION_2017_11_3\"] = 3, o[e[4] = \"IR_VERSION_2019_1_22\"] = 4, o[e[5] = \"IR_VERSION_2019_3_18\"] = 5, o[e[6] = \"IR_VERSION_2019_9_19\"] = 6, o[e[7] = \"IR_VERSION_2020_5_8\"] = 7, o[e[8] = \"IR_VERSION_2021_7_30\"] = 8, o[e[9] = \"IR_VERSION\"] = 9, o;\n    }(), i.AttributeProto = function () {\n      function e(o) {\n        if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.name = \"\", e.prototype.refAttrName = \"\", e.prototype.docString = \"\", e.prototype.type = 0, e.prototype.f = 0, e.prototype.i = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.prototype.s = b.newBuffer([]), e.prototype.t = null, e.prototype.g = null, e.prototype.sparseTensor = null, e.prototype.tp = null, e.prototype.floats = b.emptyArray, e.prototype.ints = b.emptyArray, e.prototype.strings = b.emptyArray, e.prototype.tensors = b.emptyArray, e.prototype.graphs = b.emptyArray, e.prototype.sparseTensors = b.emptyArray, e.prototype.typeProtos = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(10).string(t.name), t.f != null && Object.hasOwnProperty.call(t, \"f\") && r.uint32(21).float(t.f), t.i != null && Object.hasOwnProperty.call(t, \"i\") && r.uint32(24).int64(t.i), t.s != null && Object.hasOwnProperty.call(t, \"s\") && r.uint32(34).bytes(t.s), t.t != null && Object.hasOwnProperty.call(t, \"t\") && h.onnx.TensorProto.encode(t.t, r.uint32(42).fork()).ldelim(), t.g != null && Object.hasOwnProperty.call(t, \"g\") && h.onnx.GraphProto.encode(t.g, r.uint32(50).fork()).ldelim(), t.floats != null && t.floats.length) {\n          r.uint32(58).fork();\n          for (var n = 0; n < t.floats.length; ++n) r.float(t.floats[n]);\n          r.ldelim();\n        }\n        if (t.ints != null && t.ints.length) {\n          r.uint32(66).fork();\n          for (var n = 0; n < t.ints.length; ++n) r.int64(t.ints[n]);\n          r.ldelim();\n        }\n        if (t.strings != null && t.strings.length) for (var n = 0; n < t.strings.length; ++n) r.uint32(74).bytes(t.strings[n]);\n        if (t.tensors != null && t.tensors.length) for (var n = 0; n < t.tensors.length; ++n) h.onnx.TensorProto.encode(t.tensors[n], r.uint32(82).fork()).ldelim();\n        if (t.graphs != null && t.graphs.length) for (var n = 0; n < t.graphs.length; ++n) h.onnx.GraphProto.encode(t.graphs[n], r.uint32(90).fork()).ldelim();\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(106).string(t.docString), t.tp != null && Object.hasOwnProperty.call(t, \"tp\") && h.onnx.TypeProto.encode(t.tp, r.uint32(114).fork()).ldelim(), t.typeProtos != null && t.typeProtos.length) for (var n = 0; n < t.typeProtos.length; ++n) h.onnx.TypeProto.encode(t.typeProtos[n], r.uint32(122).fork()).ldelim();\n        if (t.type != null && Object.hasOwnProperty.call(t, \"type\") && r.uint32(160).int32(t.type), t.refAttrName != null && Object.hasOwnProperty.call(t, \"refAttrName\") && r.uint32(170).string(t.refAttrName), t.sparseTensor != null && Object.hasOwnProperty.call(t, \"sparseTensor\") && h.onnx.SparseTensorProto.encode(t.sparseTensor, r.uint32(178).fork()).ldelim(), t.sparseTensors != null && t.sparseTensors.length) for (var n = 0; n < t.sparseTensors.length; ++n) h.onnx.SparseTensorProto.encode(t.sparseTensors[n], r.uint32(186).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.AttributeProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 21:\n              {\n                s.refAttrName = t.string();\n                break;\n              }\n            case 13:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 20:\n              {\n                s.type = t.int32();\n                break;\n              }\n            case 2:\n              {\n                s.f = t.float();\n                break;\n              }\n            case 3:\n              {\n                s.i = t.int64();\n                break;\n              }\n            case 4:\n              {\n                s.s = t.bytes();\n                break;\n              }\n            case 5:\n              {\n                s.t = h.onnx.TensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 6:\n              {\n                s.g = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 22:\n              {\n                s.sparseTensor = h.onnx.SparseTensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 14:\n              {\n                s.tp = h.onnx.TypeProto.decode(t, t.uint32());\n                break;\n              }\n            case 7:\n              {\n                if (s.floats && s.floats.length || (s.floats = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.floats.push(t.float());else s.floats.push(t.float());\n                break;\n              }\n            case 8:\n              {\n                if (s.ints && s.ints.length || (s.ints = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.ints.push(t.int64());else s.ints.push(t.int64());\n                break;\n              }\n            case 9:\n              {\n                s.strings && s.strings.length || (s.strings = []), s.strings.push(t.bytes());\n                break;\n              }\n            case 10:\n              {\n                s.tensors && s.tensors.length || (s.tensors = []), s.tensors.push(h.onnx.TensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 11:\n              {\n                s.graphs && s.graphs.length || (s.graphs = []), s.graphs.push(h.onnx.GraphProto.decode(t, t.uint32()));\n                break;\n              }\n            case 23:\n              {\n                s.sparseTensors && s.sparseTensors.length || (s.sparseTensors = []), s.sparseTensors.push(h.onnx.SparseTensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 15:\n              {\n                s.typeProtos && s.typeProtos.length || (s.typeProtos = []), s.typeProtos.push(h.onnx.TypeProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.refAttrName != null && t.hasOwnProperty(\"refAttrName\") && !b.isString(t.refAttrName)) return \"refAttrName: string expected\";\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.type != null && t.hasOwnProperty(\"type\")) switch (t.type) {\n          default:\n            return \"type: enum value expected\";\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 11:\n          case 13:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 12:\n          case 14:\n            break;\n        }\n        if (t.f != null && t.hasOwnProperty(\"f\") && typeof t.f != \"number\") return \"f: number expected\";\n        if (t.i != null && t.hasOwnProperty(\"i\") && !b.isInteger(t.i) && !(t.i && b.isInteger(t.i.low) && b.isInteger(t.i.high))) return \"i: integer|Long expected\";\n        if (t.s != null && t.hasOwnProperty(\"s\") && !(t.s && typeof t.s.length == \"number\" || b.isString(t.s))) return \"s: buffer expected\";\n        if (t.t != null && t.hasOwnProperty(\"t\")) {\n          var r = h.onnx.TensorProto.verify(t.t);\n          if (r) return \"t.\" + r;\n        }\n        if (t.g != null && t.hasOwnProperty(\"g\")) {\n          var r = h.onnx.GraphProto.verify(t.g);\n          if (r) return \"g.\" + r;\n        }\n        if (t.sparseTensor != null && t.hasOwnProperty(\"sparseTensor\")) {\n          var r = h.onnx.SparseTensorProto.verify(t.sparseTensor);\n          if (r) return \"sparseTensor.\" + r;\n        }\n        if (t.tp != null && t.hasOwnProperty(\"tp\")) {\n          var r = h.onnx.TypeProto.verify(t.tp);\n          if (r) return \"tp.\" + r;\n        }\n        if (t.floats != null && t.hasOwnProperty(\"floats\")) {\n          if (!Array.isArray(t.floats)) return \"floats: array expected\";\n          for (var n = 0; n < t.floats.length; ++n) if (typeof t.floats[n] != \"number\") return \"floats: number[] expected\";\n        }\n        if (t.ints != null && t.hasOwnProperty(\"ints\")) {\n          if (!Array.isArray(t.ints)) return \"ints: array expected\";\n          for (var n = 0; n < t.ints.length; ++n) if (!b.isInteger(t.ints[n]) && !(t.ints[n] && b.isInteger(t.ints[n].low) && b.isInteger(t.ints[n].high))) return \"ints: integer|Long[] expected\";\n        }\n        if (t.strings != null && t.hasOwnProperty(\"strings\")) {\n          if (!Array.isArray(t.strings)) return \"strings: array expected\";\n          for (var n = 0; n < t.strings.length; ++n) if (!(t.strings[n] && typeof t.strings[n].length == \"number\" || b.isString(t.strings[n]))) return \"strings: buffer[] expected\";\n        }\n        if (t.tensors != null && t.hasOwnProperty(\"tensors\")) {\n          if (!Array.isArray(t.tensors)) return \"tensors: array expected\";\n          for (var n = 0; n < t.tensors.length; ++n) {\n            var r = h.onnx.TensorProto.verify(t.tensors[n]);\n            if (r) return \"tensors.\" + r;\n          }\n        }\n        if (t.graphs != null && t.hasOwnProperty(\"graphs\")) {\n          if (!Array.isArray(t.graphs)) return \"graphs: array expected\";\n          for (var n = 0; n < t.graphs.length; ++n) {\n            var r = h.onnx.GraphProto.verify(t.graphs[n]);\n            if (r) return \"graphs.\" + r;\n          }\n        }\n        if (t.sparseTensors != null && t.hasOwnProperty(\"sparseTensors\")) {\n          if (!Array.isArray(t.sparseTensors)) return \"sparseTensors: array expected\";\n          for (var n = 0; n < t.sparseTensors.length; ++n) {\n            var r = h.onnx.SparseTensorProto.verify(t.sparseTensors[n]);\n            if (r) return \"sparseTensors.\" + r;\n          }\n        }\n        if (t.typeProtos != null && t.hasOwnProperty(\"typeProtos\")) {\n          if (!Array.isArray(t.typeProtos)) return \"typeProtos: array expected\";\n          for (var n = 0; n < t.typeProtos.length; ++n) {\n            var r = h.onnx.TypeProto.verify(t.typeProtos[n]);\n            if (r) return \"typeProtos.\" + r;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.AttributeProto) return t;\n        var r = new h.onnx.AttributeProto();\n        switch (t.name != null && (r.name = String(t.name)), t.refAttrName != null && (r.refAttrName = String(t.refAttrName)), t.docString != null && (r.docString = String(t.docString)), t.type) {\n          default:\n            if (typeof t.type == \"number\") {\n              r.type = t.type;\n              break;\n            }\n            break;\n          case \"UNDEFINED\":\n          case 0:\n            r.type = 0;\n            break;\n          case \"FLOAT\":\n          case 1:\n            r.type = 1;\n            break;\n          case \"INT\":\n          case 2:\n            r.type = 2;\n            break;\n          case \"STRING\":\n          case 3:\n            r.type = 3;\n            break;\n          case \"TENSOR\":\n          case 4:\n            r.type = 4;\n            break;\n          case \"GRAPH\":\n          case 5:\n            r.type = 5;\n            break;\n          case \"SPARSE_TENSOR\":\n          case 11:\n            r.type = 11;\n            break;\n          case \"TYPE_PROTO\":\n          case 13:\n            r.type = 13;\n            break;\n          case \"FLOATS\":\n          case 6:\n            r.type = 6;\n            break;\n          case \"INTS\":\n          case 7:\n            r.type = 7;\n            break;\n          case \"STRINGS\":\n          case 8:\n            r.type = 8;\n            break;\n          case \"TENSORS\":\n          case 9:\n            r.type = 9;\n            break;\n          case \"GRAPHS\":\n          case 10:\n            r.type = 10;\n            break;\n          case \"SPARSE_TENSORS\":\n          case 12:\n            r.type = 12;\n            break;\n          case \"TYPE_PROTOS\":\n          case 14:\n            r.type = 14;\n            break;\n        }\n        if (t.f != null && (r.f = Number(t.f)), t.i != null && (b.Long ? (r.i = b.Long.fromValue(t.i)).unsigned = !1 : typeof t.i == \"string\" ? r.i = parseInt(t.i, 10) : typeof t.i == \"number\" ? r.i = t.i : typeof t.i == \"object\" && (r.i = new b.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber())), t.s != null && (typeof t.s == \"string\" ? b.base64.decode(t.s, r.s = b.newBuffer(b.base64.length(t.s)), 0) : t.s.length >= 0 && (r.s = t.s)), t.t != null) {\n          if (typeof t.t != \"object\") throw TypeError(\".onnx.AttributeProto.t: object expected\");\n          r.t = h.onnx.TensorProto.fromObject(t.t);\n        }\n        if (t.g != null) {\n          if (typeof t.g != \"object\") throw TypeError(\".onnx.AttributeProto.g: object expected\");\n          r.g = h.onnx.GraphProto.fromObject(t.g);\n        }\n        if (t.sparseTensor != null) {\n          if (typeof t.sparseTensor != \"object\") throw TypeError(\".onnx.AttributeProto.sparseTensor: object expected\");\n          r.sparseTensor = h.onnx.SparseTensorProto.fromObject(t.sparseTensor);\n        }\n        if (t.tp != null) {\n          if (typeof t.tp != \"object\") throw TypeError(\".onnx.AttributeProto.tp: object expected\");\n          r.tp = h.onnx.TypeProto.fromObject(t.tp);\n        }\n        if (t.floats) {\n          if (!Array.isArray(t.floats)) throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n          r.floats = [];\n          for (var n = 0; n < t.floats.length; ++n) r.floats[n] = Number(t.floats[n]);\n        }\n        if (t.ints) {\n          if (!Array.isArray(t.ints)) throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n          r.ints = [];\n          for (var n = 0; n < t.ints.length; ++n) b.Long ? (r.ints[n] = b.Long.fromValue(t.ints[n])).unsigned = !1 : typeof t.ints[n] == \"string\" ? r.ints[n] = parseInt(t.ints[n], 10) : typeof t.ints[n] == \"number\" ? r.ints[n] = t.ints[n] : typeof t.ints[n] == \"object\" && (r.ints[n] = new b.LongBits(t.ints[n].low >>> 0, t.ints[n].high >>> 0).toNumber());\n        }\n        if (t.strings) {\n          if (!Array.isArray(t.strings)) throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n          r.strings = [];\n          for (var n = 0; n < t.strings.length; ++n) typeof t.strings[n] == \"string\" ? b.base64.decode(t.strings[n], r.strings[n] = b.newBuffer(b.base64.length(t.strings[n])), 0) : t.strings[n].length >= 0 && (r.strings[n] = t.strings[n]);\n        }\n        if (t.tensors) {\n          if (!Array.isArray(t.tensors)) throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n          r.tensors = [];\n          for (var n = 0; n < t.tensors.length; ++n) {\n            if (typeof t.tensors[n] != \"object\") throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n            r.tensors[n] = h.onnx.TensorProto.fromObject(t.tensors[n]);\n          }\n        }\n        if (t.graphs) {\n          if (!Array.isArray(t.graphs)) throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n          r.graphs = [];\n          for (var n = 0; n < t.graphs.length; ++n) {\n            if (typeof t.graphs[n] != \"object\") throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n            r.graphs[n] = h.onnx.GraphProto.fromObject(t.graphs[n]);\n          }\n        }\n        if (t.sparseTensors) {\n          if (!Array.isArray(t.sparseTensors)) throw TypeError(\".onnx.AttributeProto.sparseTensors: array expected\");\n          r.sparseTensors = [];\n          for (var n = 0; n < t.sparseTensors.length; ++n) {\n            if (typeof t.sparseTensors[n] != \"object\") throw TypeError(\".onnx.AttributeProto.sparseTensors: object expected\");\n            r.sparseTensors[n] = h.onnx.SparseTensorProto.fromObject(t.sparseTensors[n]);\n          }\n        }\n        if (t.typeProtos) {\n          if (!Array.isArray(t.typeProtos)) throw TypeError(\".onnx.AttributeProto.typeProtos: array expected\");\n          r.typeProtos = [];\n          for (var n = 0; n < t.typeProtos.length; ++n) {\n            if (typeof t.typeProtos[n] != \"object\") throw TypeError(\".onnx.AttributeProto.typeProtos: object expected\");\n            r.typeProtos[n] = h.onnx.TypeProto.fromObject(t.typeProtos[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.floats = [], n.ints = [], n.strings = [], n.tensors = [], n.graphs = [], n.typeProtos = [], n.sparseTensors = []), r.defaults) {\n          if (n.name = \"\", n.f = 0, b.Long) {\n            var s = new b.Long(0, 0, !1);\n            n.i = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n          } else n.i = r.longs === String ? \"0\" : 0;\n          r.bytes === String ? n.s = \"\" : (n.s = [], r.bytes !== Array && (n.s = b.newBuffer(n.s))), n.t = null, n.g = null, n.docString = \"\", n.tp = null, n.type = r.enums === String ? \"UNDEFINED\" : 0, n.refAttrName = \"\", n.sparseTensor = null;\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.f != null && t.hasOwnProperty(\"f\") && (n.f = r.json && !isFinite(t.f) ? String(t.f) : t.f), t.i != null && t.hasOwnProperty(\"i\") && (typeof t.i == \"number\" ? n.i = r.longs === String ? String(t.i) : t.i : n.i = r.longs === String ? b.Long.prototype.toString.call(t.i) : r.longs === Number ? new b.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber() : t.i), t.s != null && t.hasOwnProperty(\"s\") && (n.s = r.bytes === String ? b.base64.encode(t.s, 0, t.s.length) : r.bytes === Array ? Array.prototype.slice.call(t.s) : t.s), t.t != null && t.hasOwnProperty(\"t\") && (n.t = h.onnx.TensorProto.toObject(t.t, r)), t.g != null && t.hasOwnProperty(\"g\") && (n.g = h.onnx.GraphProto.toObject(t.g, r)), t.floats && t.floats.length) {\n          n.floats = [];\n          for (var a = 0; a < t.floats.length; ++a) n.floats[a] = r.json && !isFinite(t.floats[a]) ? String(t.floats[a]) : t.floats[a];\n        }\n        if (t.ints && t.ints.length) {\n          n.ints = [];\n          for (var a = 0; a < t.ints.length; ++a) typeof t.ints[a] == \"number\" ? n.ints[a] = r.longs === String ? String(t.ints[a]) : t.ints[a] : n.ints[a] = r.longs === String ? b.Long.prototype.toString.call(t.ints[a]) : r.longs === Number ? new b.LongBits(t.ints[a].low >>> 0, t.ints[a].high >>> 0).toNumber() : t.ints[a];\n        }\n        if (t.strings && t.strings.length) {\n          n.strings = [];\n          for (var a = 0; a < t.strings.length; ++a) n.strings[a] = r.bytes === String ? b.base64.encode(t.strings[a], 0, t.strings[a].length) : r.bytes === Array ? Array.prototype.slice.call(t.strings[a]) : t.strings[a];\n        }\n        if (t.tensors && t.tensors.length) {\n          n.tensors = [];\n          for (var a = 0; a < t.tensors.length; ++a) n.tensors[a] = h.onnx.TensorProto.toObject(t.tensors[a], r);\n        }\n        if (t.graphs && t.graphs.length) {\n          n.graphs = [];\n          for (var a = 0; a < t.graphs.length; ++a) n.graphs[a] = h.onnx.GraphProto.toObject(t.graphs[a], r);\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.tp != null && t.hasOwnProperty(\"tp\") && (n.tp = h.onnx.TypeProto.toObject(t.tp, r)), t.typeProtos && t.typeProtos.length) {\n          n.typeProtos = [];\n          for (var a = 0; a < t.typeProtos.length; ++a) n.typeProtos[a] = h.onnx.TypeProto.toObject(t.typeProtos[a], r);\n        }\n        if (t.type != null && t.hasOwnProperty(\"type\") && (n.type = r.enums === String ? h.onnx.AttributeProto.AttributeType[t.type] === void 0 ? t.type : h.onnx.AttributeProto.AttributeType[t.type] : t.type), t.refAttrName != null && t.hasOwnProperty(\"refAttrName\") && (n.refAttrName = t.refAttrName), t.sparseTensor != null && t.hasOwnProperty(\"sparseTensor\") && (n.sparseTensor = h.onnx.SparseTensorProto.toObject(t.sparseTensor, r)), t.sparseTensors && t.sparseTensors.length) {\n          n.sparseTensors = [];\n          for (var a = 0; a < t.sparseTensors.length; ++a) n.sparseTensors[a] = h.onnx.SparseTensorProto.toObject(t.sparseTensors[a], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.AttributeProto\";\n      }, e.AttributeType = function () {\n        var o = {},\n          t = Object.create(o);\n        return t[o[0] = \"UNDEFINED\"] = 0, t[o[1] = \"FLOAT\"] = 1, t[o[2] = \"INT\"] = 2, t[o[3] = \"STRING\"] = 3, t[o[4] = \"TENSOR\"] = 4, t[o[5] = \"GRAPH\"] = 5, t[o[11] = \"SPARSE_TENSOR\"] = 11, t[o[13] = \"TYPE_PROTO\"] = 13, t[o[6] = \"FLOATS\"] = 6, t[o[7] = \"INTS\"] = 7, t[o[8] = \"STRINGS\"] = 8, t[o[9] = \"TENSORS\"] = 9, t[o[10] = \"GRAPHS\"] = 10, t[o[12] = \"SPARSE_TENSORS\"] = 12, t[o[14] = \"TYPE_PROTOS\"] = 14, t;\n      }(), e;\n    }(), i.ValueInfoProto = function () {\n      function e(o) {\n        if (o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.name = \"\", e.prototype.type = null, e.prototype.docString = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        return r || (r = pt.create()), t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(10).string(t.name), t.type != null && Object.hasOwnProperty.call(t, \"type\") && h.onnx.TypeProto.encode(t.type, r.uint32(18).fork()).ldelim(), t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(26).string(t.docString), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.ValueInfoProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.type = h.onnx.TypeProto.decode(t, t.uint32());\n                break;\n              }\n            case 3:\n              {\n                s.docString = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.type != null && t.hasOwnProperty(\"type\")) {\n          var r = h.onnx.TypeProto.verify(t.type);\n          if (r) return \"type.\" + r;\n        }\n        return t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString) ? \"docString: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.ValueInfoProto) return t;\n        var r = new h.onnx.ValueInfoProto();\n        if (t.name != null && (r.name = String(t.name)), t.type != null) {\n          if (typeof t.type != \"object\") throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n          r.type = h.onnx.TypeProto.fromObject(t.type);\n        }\n        return t.docString != null && (r.docString = String(t.docString)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        return r.defaults && (n.name = \"\", n.type = null, n.docString = \"\"), t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.type != null && t.hasOwnProperty(\"type\") && (n.type = h.onnx.TypeProto.toObject(t.type, r)), t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.ValueInfoProto\";\n      }, e;\n    }(), i.NodeProto = function () {\n      function e(o) {\n        if (this.input = [], this.output = [], this.attribute = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.input = b.emptyArray, e.prototype.output = b.emptyArray, e.prototype.name = \"\", e.prototype.opType = \"\", e.prototype.domain = \"\", e.prototype.attribute = b.emptyArray, e.prototype.docString = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.input != null && t.input.length) for (var n = 0; n < t.input.length; ++n) r.uint32(10).string(t.input[n]);\n        if (t.output != null && t.output.length) for (var n = 0; n < t.output.length; ++n) r.uint32(18).string(t.output[n]);\n        if (t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(26).string(t.name), t.opType != null && Object.hasOwnProperty.call(t, \"opType\") && r.uint32(34).string(t.opType), t.attribute != null && t.attribute.length) for (var n = 0; n < t.attribute.length; ++n) h.onnx.AttributeProto.encode(t.attribute[n], r.uint32(42).fork()).ldelim();\n        return t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(50).string(t.docString), t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(58).string(t.domain), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.NodeProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.input && s.input.length || (s.input = []), s.input.push(t.string());\n                break;\n              }\n            case 2:\n              {\n                s.output && s.output.length || (s.output = []), s.output.push(t.string());\n                break;\n              }\n            case 3:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 4:\n              {\n                s.opType = t.string();\n                break;\n              }\n            case 7:\n              {\n                s.domain = t.string();\n                break;\n              }\n            case 5:\n              {\n                s.attribute && s.attribute.length || (s.attribute = []), s.attribute.push(h.onnx.AttributeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 6:\n              {\n                s.docString = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.input != null && t.hasOwnProperty(\"input\")) {\n          if (!Array.isArray(t.input)) return \"input: array expected\";\n          for (var r = 0; r < t.input.length; ++r) if (!b.isString(t.input[r])) return \"input: string[] expected\";\n        }\n        if (t.output != null && t.hasOwnProperty(\"output\")) {\n          if (!Array.isArray(t.output)) return \"output: array expected\";\n          for (var r = 0; r < t.output.length; ++r) if (!b.isString(t.output[r])) return \"output: string[] expected\";\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.opType != null && t.hasOwnProperty(\"opType\") && !b.isString(t.opType)) return \"opType: string expected\";\n        if (t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain)) return \"domain: string expected\";\n        if (t.attribute != null && t.hasOwnProperty(\"attribute\")) {\n          if (!Array.isArray(t.attribute)) return \"attribute: array expected\";\n          for (var r = 0; r < t.attribute.length; ++r) {\n            var n = h.onnx.AttributeProto.verify(t.attribute[r]);\n            if (n) return \"attribute.\" + n;\n          }\n        }\n        return t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString) ? \"docString: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.NodeProto) return t;\n        var r = new h.onnx.NodeProto();\n        if (t.input) {\n          if (!Array.isArray(t.input)) throw TypeError(\".onnx.NodeProto.input: array expected\");\n          r.input = [];\n          for (var n = 0; n < t.input.length; ++n) r.input[n] = String(t.input[n]);\n        }\n        if (t.output) {\n          if (!Array.isArray(t.output)) throw TypeError(\".onnx.NodeProto.output: array expected\");\n          r.output = [];\n          for (var n = 0; n < t.output.length; ++n) r.output[n] = String(t.output[n]);\n        }\n        if (t.name != null && (r.name = String(t.name)), t.opType != null && (r.opType = String(t.opType)), t.domain != null && (r.domain = String(t.domain)), t.attribute) {\n          if (!Array.isArray(t.attribute)) throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n          r.attribute = [];\n          for (var n = 0; n < t.attribute.length; ++n) {\n            if (typeof t.attribute[n] != \"object\") throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n            r.attribute[n] = h.onnx.AttributeProto.fromObject(t.attribute[n]);\n          }\n        }\n        return t.docString != null && (r.docString = String(t.docString)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.input = [], n.output = [], n.attribute = []), r.defaults && (n.name = \"\", n.opType = \"\", n.docString = \"\", n.domain = \"\"), t.input && t.input.length) {\n          n.input = [];\n          for (var s = 0; s < t.input.length; ++s) n.input[s] = t.input[s];\n        }\n        if (t.output && t.output.length) {\n          n.output = [];\n          for (var s = 0; s < t.output.length; ++s) n.output[s] = t.output[s];\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.opType != null && t.hasOwnProperty(\"opType\") && (n.opType = t.opType), t.attribute && t.attribute.length) {\n          n.attribute = [];\n          for (var s = 0; s < t.attribute.length; ++s) n.attribute[s] = h.onnx.AttributeProto.toObject(t.attribute[s], r);\n        }\n        return t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.NodeProto\";\n      }, e;\n    }(), i.TrainingInfoProto = function () {\n      function e(o) {\n        if (this.initializationBinding = [], this.updateBinding = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.initialization = null, e.prototype.algorithm = null, e.prototype.initializationBinding = b.emptyArray, e.prototype.updateBinding = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.initialization != null && Object.hasOwnProperty.call(t, \"initialization\") && h.onnx.GraphProto.encode(t.initialization, r.uint32(10).fork()).ldelim(), t.algorithm != null && Object.hasOwnProperty.call(t, \"algorithm\") && h.onnx.GraphProto.encode(t.algorithm, r.uint32(18).fork()).ldelim(), t.initializationBinding != null && t.initializationBinding.length) for (var n = 0; n < t.initializationBinding.length; ++n) h.onnx.StringStringEntryProto.encode(t.initializationBinding[n], r.uint32(26).fork()).ldelim();\n        if (t.updateBinding != null && t.updateBinding.length) for (var n = 0; n < t.updateBinding.length; ++n) h.onnx.StringStringEntryProto.encode(t.updateBinding[n], r.uint32(34).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TrainingInfoProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.initialization = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 2:\n              {\n                s.algorithm = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 3:\n              {\n                s.initializationBinding && s.initializationBinding.length || (s.initializationBinding = []), s.initializationBinding.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            case 4:\n              {\n                s.updateBinding && s.updateBinding.length || (s.updateBinding = []), s.updateBinding.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.initialization != null && t.hasOwnProperty(\"initialization\")) {\n          var r = h.onnx.GraphProto.verify(t.initialization);\n          if (r) return \"initialization.\" + r;\n        }\n        if (t.algorithm != null && t.hasOwnProperty(\"algorithm\")) {\n          var r = h.onnx.GraphProto.verify(t.algorithm);\n          if (r) return \"algorithm.\" + r;\n        }\n        if (t.initializationBinding != null && t.hasOwnProperty(\"initializationBinding\")) {\n          if (!Array.isArray(t.initializationBinding)) return \"initializationBinding: array expected\";\n          for (var n = 0; n < t.initializationBinding.length; ++n) {\n            var r = h.onnx.StringStringEntryProto.verify(t.initializationBinding[n]);\n            if (r) return \"initializationBinding.\" + r;\n          }\n        }\n        if (t.updateBinding != null && t.hasOwnProperty(\"updateBinding\")) {\n          if (!Array.isArray(t.updateBinding)) return \"updateBinding: array expected\";\n          for (var n = 0; n < t.updateBinding.length; ++n) {\n            var r = h.onnx.StringStringEntryProto.verify(t.updateBinding[n]);\n            if (r) return \"updateBinding.\" + r;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TrainingInfoProto) return t;\n        var r = new h.onnx.TrainingInfoProto();\n        if (t.initialization != null) {\n          if (typeof t.initialization != \"object\") throw TypeError(\".onnx.TrainingInfoProto.initialization: object expected\");\n          r.initialization = h.onnx.GraphProto.fromObject(t.initialization);\n        }\n        if (t.algorithm != null) {\n          if (typeof t.algorithm != \"object\") throw TypeError(\".onnx.TrainingInfoProto.algorithm: object expected\");\n          r.algorithm = h.onnx.GraphProto.fromObject(t.algorithm);\n        }\n        if (t.initializationBinding) {\n          if (!Array.isArray(t.initializationBinding)) throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: array expected\");\n          r.initializationBinding = [];\n          for (var n = 0; n < t.initializationBinding.length; ++n) {\n            if (typeof t.initializationBinding[n] != \"object\") throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: object expected\");\n            r.initializationBinding[n] = h.onnx.StringStringEntryProto.fromObject(t.initializationBinding[n]);\n          }\n        }\n        if (t.updateBinding) {\n          if (!Array.isArray(t.updateBinding)) throw TypeError(\".onnx.TrainingInfoProto.updateBinding: array expected\");\n          r.updateBinding = [];\n          for (var n = 0; n < t.updateBinding.length; ++n) {\n            if (typeof t.updateBinding[n] != \"object\") throw TypeError(\".onnx.TrainingInfoProto.updateBinding: object expected\");\n            r.updateBinding[n] = h.onnx.StringStringEntryProto.fromObject(t.updateBinding[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.initializationBinding = [], n.updateBinding = []), r.defaults && (n.initialization = null, n.algorithm = null), t.initialization != null && t.hasOwnProperty(\"initialization\") && (n.initialization = h.onnx.GraphProto.toObject(t.initialization, r)), t.algorithm != null && t.hasOwnProperty(\"algorithm\") && (n.algorithm = h.onnx.GraphProto.toObject(t.algorithm, r)), t.initializationBinding && t.initializationBinding.length) {\n          n.initializationBinding = [];\n          for (var s = 0; s < t.initializationBinding.length; ++s) n.initializationBinding[s] = h.onnx.StringStringEntryProto.toObject(t.initializationBinding[s], r);\n        }\n        if (t.updateBinding && t.updateBinding.length) {\n          n.updateBinding = [];\n          for (var s = 0; s < t.updateBinding.length; ++s) n.updateBinding[s] = h.onnx.StringStringEntryProto.toObject(t.updateBinding[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TrainingInfoProto\";\n      }, e;\n    }(), i.ModelProto = function () {\n      function e(o) {\n        if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.irVersion = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.prototype.opsetImport = b.emptyArray, e.prototype.producerName = \"\", e.prototype.producerVersion = \"\", e.prototype.domain = \"\", e.prototype.modelVersion = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.prototype.docString = \"\", e.prototype.graph = null, e.prototype.metadataProps = b.emptyArray, e.prototype.trainingInfo = b.emptyArray, e.prototype.functions = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.irVersion != null && Object.hasOwnProperty.call(t, \"irVersion\") && r.uint32(8).int64(t.irVersion), t.producerName != null && Object.hasOwnProperty.call(t, \"producerName\") && r.uint32(18).string(t.producerName), t.producerVersion != null && Object.hasOwnProperty.call(t, \"producerVersion\") && r.uint32(26).string(t.producerVersion), t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(34).string(t.domain), t.modelVersion != null && Object.hasOwnProperty.call(t, \"modelVersion\") && r.uint32(40).int64(t.modelVersion), t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(50).string(t.docString), t.graph != null && Object.hasOwnProperty.call(t, \"graph\") && h.onnx.GraphProto.encode(t.graph, r.uint32(58).fork()).ldelim(), t.opsetImport != null && t.opsetImport.length) for (var n = 0; n < t.opsetImport.length; ++n) h.onnx.OperatorSetIdProto.encode(t.opsetImport[n], r.uint32(66).fork()).ldelim();\n        if (t.metadataProps != null && t.metadataProps.length) for (var n = 0; n < t.metadataProps.length; ++n) h.onnx.StringStringEntryProto.encode(t.metadataProps[n], r.uint32(114).fork()).ldelim();\n        if (t.trainingInfo != null && t.trainingInfo.length) for (var n = 0; n < t.trainingInfo.length; ++n) h.onnx.TrainingInfoProto.encode(t.trainingInfo[n], r.uint32(162).fork()).ldelim();\n        if (t.functions != null && t.functions.length) for (var n = 0; n < t.functions.length; ++n) h.onnx.FunctionProto.encode(t.functions[n], r.uint32(202).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.ModelProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.irVersion = t.int64();\n                break;\n              }\n            case 8:\n              {\n                s.opsetImport && s.opsetImport.length || (s.opsetImport = []), s.opsetImport.push(h.onnx.OperatorSetIdProto.decode(t, t.uint32()));\n                break;\n              }\n            case 2:\n              {\n                s.producerName = t.string();\n                break;\n              }\n            case 3:\n              {\n                s.producerVersion = t.string();\n                break;\n              }\n            case 4:\n              {\n                s.domain = t.string();\n                break;\n              }\n            case 5:\n              {\n                s.modelVersion = t.int64();\n                break;\n              }\n            case 6:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 7:\n              {\n                s.graph = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 14:\n              {\n                s.metadataProps && s.metadataProps.length || (s.metadataProps = []), s.metadataProps.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            case 20:\n              {\n                s.trainingInfo && s.trainingInfo.length || (s.trainingInfo = []), s.trainingInfo.push(h.onnx.TrainingInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 25:\n              {\n                s.functions && s.functions.length || (s.functions = []), s.functions.push(h.onnx.FunctionProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.irVersion != null && t.hasOwnProperty(\"irVersion\") && !b.isInteger(t.irVersion) && !(t.irVersion && b.isInteger(t.irVersion.low) && b.isInteger(t.irVersion.high))) return \"irVersion: integer|Long expected\";\n        if (t.opsetImport != null && t.hasOwnProperty(\"opsetImport\")) {\n          if (!Array.isArray(t.opsetImport)) return \"opsetImport: array expected\";\n          for (var r = 0; r < t.opsetImport.length; ++r) {\n            var n = h.onnx.OperatorSetIdProto.verify(t.opsetImport[r]);\n            if (n) return \"opsetImport.\" + n;\n          }\n        }\n        if (t.producerName != null && t.hasOwnProperty(\"producerName\") && !b.isString(t.producerName)) return \"producerName: string expected\";\n        if (t.producerVersion != null && t.hasOwnProperty(\"producerVersion\") && !b.isString(t.producerVersion)) return \"producerVersion: string expected\";\n        if (t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain)) return \"domain: string expected\";\n        if (t.modelVersion != null && t.hasOwnProperty(\"modelVersion\") && !b.isInteger(t.modelVersion) && !(t.modelVersion && b.isInteger(t.modelVersion.low) && b.isInteger(t.modelVersion.high))) return \"modelVersion: integer|Long expected\";\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.graph != null && t.hasOwnProperty(\"graph\")) {\n          var n = h.onnx.GraphProto.verify(t.graph);\n          if (n) return \"graph.\" + n;\n        }\n        if (t.metadataProps != null && t.hasOwnProperty(\"metadataProps\")) {\n          if (!Array.isArray(t.metadataProps)) return \"metadataProps: array expected\";\n          for (var r = 0; r < t.metadataProps.length; ++r) {\n            var n = h.onnx.StringStringEntryProto.verify(t.metadataProps[r]);\n            if (n) return \"metadataProps.\" + n;\n          }\n        }\n        if (t.trainingInfo != null && t.hasOwnProperty(\"trainingInfo\")) {\n          if (!Array.isArray(t.trainingInfo)) return \"trainingInfo: array expected\";\n          for (var r = 0; r < t.trainingInfo.length; ++r) {\n            var n = h.onnx.TrainingInfoProto.verify(t.trainingInfo[r]);\n            if (n) return \"trainingInfo.\" + n;\n          }\n        }\n        if (t.functions != null && t.hasOwnProperty(\"functions\")) {\n          if (!Array.isArray(t.functions)) return \"functions: array expected\";\n          for (var r = 0; r < t.functions.length; ++r) {\n            var n = h.onnx.FunctionProto.verify(t.functions[r]);\n            if (n) return \"functions.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.ModelProto) return t;\n        var r = new h.onnx.ModelProto();\n        if (t.irVersion != null && (b.Long ? (r.irVersion = b.Long.fromValue(t.irVersion)).unsigned = !1 : typeof t.irVersion == \"string\" ? r.irVersion = parseInt(t.irVersion, 10) : typeof t.irVersion == \"number\" ? r.irVersion = t.irVersion : typeof t.irVersion == \"object\" && (r.irVersion = new b.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber())), t.opsetImport) {\n          if (!Array.isArray(t.opsetImport)) throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n          r.opsetImport = [];\n          for (var n = 0; n < t.opsetImport.length; ++n) {\n            if (typeof t.opsetImport[n] != \"object\") throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n            r.opsetImport[n] = h.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n]);\n          }\n        }\n        if (t.producerName != null && (r.producerName = String(t.producerName)), t.producerVersion != null && (r.producerVersion = String(t.producerVersion)), t.domain != null && (r.domain = String(t.domain)), t.modelVersion != null && (b.Long ? (r.modelVersion = b.Long.fromValue(t.modelVersion)).unsigned = !1 : typeof t.modelVersion == \"string\" ? r.modelVersion = parseInt(t.modelVersion, 10) : typeof t.modelVersion == \"number\" ? r.modelVersion = t.modelVersion : typeof t.modelVersion == \"object\" && (r.modelVersion = new b.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber())), t.docString != null && (r.docString = String(t.docString)), t.graph != null) {\n          if (typeof t.graph != \"object\") throw TypeError(\".onnx.ModelProto.graph: object expected\");\n          r.graph = h.onnx.GraphProto.fromObject(t.graph);\n        }\n        if (t.metadataProps) {\n          if (!Array.isArray(t.metadataProps)) throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n          r.metadataProps = [];\n          for (var n = 0; n < t.metadataProps.length; ++n) {\n            if (typeof t.metadataProps[n] != \"object\") throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n            r.metadataProps[n] = h.onnx.StringStringEntryProto.fromObject(t.metadataProps[n]);\n          }\n        }\n        if (t.trainingInfo) {\n          if (!Array.isArray(t.trainingInfo)) throw TypeError(\".onnx.ModelProto.trainingInfo: array expected\");\n          r.trainingInfo = [];\n          for (var n = 0; n < t.trainingInfo.length; ++n) {\n            if (typeof t.trainingInfo[n] != \"object\") throw TypeError(\".onnx.ModelProto.trainingInfo: object expected\");\n            r.trainingInfo[n] = h.onnx.TrainingInfoProto.fromObject(t.trainingInfo[n]);\n          }\n        }\n        if (t.functions) {\n          if (!Array.isArray(t.functions)) throw TypeError(\".onnx.ModelProto.functions: array expected\");\n          r.functions = [];\n          for (var n = 0; n < t.functions.length; ++n) {\n            if (typeof t.functions[n] != \"object\") throw TypeError(\".onnx.ModelProto.functions: object expected\");\n            r.functions[n] = h.onnx.FunctionProto.fromObject(t.functions[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.opsetImport = [], n.metadataProps = [], n.trainingInfo = [], n.functions = []), r.defaults) {\n          if (b.Long) {\n            var s = new b.Long(0, 0, !1);\n            n.irVersion = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n          } else n.irVersion = r.longs === String ? \"0\" : 0;\n          if (n.producerName = \"\", n.producerVersion = \"\", n.domain = \"\", b.Long) {\n            var s = new b.Long(0, 0, !1);\n            n.modelVersion = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n          } else n.modelVersion = r.longs === String ? \"0\" : 0;\n          n.docString = \"\", n.graph = null;\n        }\n        if (t.irVersion != null && t.hasOwnProperty(\"irVersion\") && (typeof t.irVersion == \"number\" ? n.irVersion = r.longs === String ? String(t.irVersion) : t.irVersion : n.irVersion = r.longs === String ? b.Long.prototype.toString.call(t.irVersion) : r.longs === Number ? new b.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber() : t.irVersion), t.producerName != null && t.hasOwnProperty(\"producerName\") && (n.producerName = t.producerName), t.producerVersion != null && t.hasOwnProperty(\"producerVersion\") && (n.producerVersion = t.producerVersion), t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), t.modelVersion != null && t.hasOwnProperty(\"modelVersion\") && (typeof t.modelVersion == \"number\" ? n.modelVersion = r.longs === String ? String(t.modelVersion) : t.modelVersion : n.modelVersion = r.longs === String ? b.Long.prototype.toString.call(t.modelVersion) : r.longs === Number ? new b.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber() : t.modelVersion), t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.graph != null && t.hasOwnProperty(\"graph\") && (n.graph = h.onnx.GraphProto.toObject(t.graph, r)), t.opsetImport && t.opsetImport.length) {\n          n.opsetImport = [];\n          for (var a = 0; a < t.opsetImport.length; ++a) n.opsetImport[a] = h.onnx.OperatorSetIdProto.toObject(t.opsetImport[a], r);\n        }\n        if (t.metadataProps && t.metadataProps.length) {\n          n.metadataProps = [];\n          for (var a = 0; a < t.metadataProps.length; ++a) n.metadataProps[a] = h.onnx.StringStringEntryProto.toObject(t.metadataProps[a], r);\n        }\n        if (t.trainingInfo && t.trainingInfo.length) {\n          n.trainingInfo = [];\n          for (var a = 0; a < t.trainingInfo.length; ++a) n.trainingInfo[a] = h.onnx.TrainingInfoProto.toObject(t.trainingInfo[a], r);\n        }\n        if (t.functions && t.functions.length) {\n          n.functions = [];\n          for (var a = 0; a < t.functions.length; ++a) n.functions[a] = h.onnx.FunctionProto.toObject(t.functions[a], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.ModelProto\";\n      }, e;\n    }(), i.StringStringEntryProto = function () {\n      function e(o) {\n        if (o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.key = \"\", e.prototype.value = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        return r || (r = pt.create()), t.key != null && Object.hasOwnProperty.call(t, \"key\") && r.uint32(10).string(t.key), t.value != null && Object.hasOwnProperty.call(t, \"value\") && r.uint32(18).string(t.value), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.StringStringEntryProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.key = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.value = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        return typeof t != \"object\" || t === null ? \"object expected\" : t.key != null && t.hasOwnProperty(\"key\") && !b.isString(t.key) ? \"key: string expected\" : t.value != null && t.hasOwnProperty(\"value\") && !b.isString(t.value) ? \"value: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.StringStringEntryProto) return t;\n        var r = new h.onnx.StringStringEntryProto();\n        return t.key != null && (r.key = String(t.key)), t.value != null && (r.value = String(t.value)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        return r.defaults && (n.key = \"\", n.value = \"\"), t.key != null && t.hasOwnProperty(\"key\") && (n.key = t.key), t.value != null && t.hasOwnProperty(\"value\") && (n.value = t.value), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.StringStringEntryProto\";\n      }, e;\n    }(), i.TensorAnnotation = function () {\n      function e(o) {\n        if (this.quantParameterTensorNames = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.tensorName = \"\", e.prototype.quantParameterTensorNames = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.tensorName != null && Object.hasOwnProperty.call(t, \"tensorName\") && r.uint32(10).string(t.tensorName), t.quantParameterTensorNames != null && t.quantParameterTensorNames.length) for (var n = 0; n < t.quantParameterTensorNames.length; ++n) h.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n], r.uint32(18).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TensorAnnotation(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.tensorName = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.quantParameterTensorNames && s.quantParameterTensorNames.length || (s.quantParameterTensorNames = []), s.quantParameterTensorNames.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.tensorName != null && t.hasOwnProperty(\"tensorName\") && !b.isString(t.tensorName)) return \"tensorName: string expected\";\n        if (t.quantParameterTensorNames != null && t.hasOwnProperty(\"quantParameterTensorNames\")) {\n          if (!Array.isArray(t.quantParameterTensorNames)) return \"quantParameterTensorNames: array expected\";\n          for (var r = 0; r < t.quantParameterTensorNames.length; ++r) {\n            var n = h.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[r]);\n            if (n) return \"quantParameterTensorNames.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TensorAnnotation) return t;\n        var r = new h.onnx.TensorAnnotation();\n        if (t.tensorName != null && (r.tensorName = String(t.tensorName)), t.quantParameterTensorNames) {\n          if (!Array.isArray(t.quantParameterTensorNames)) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n          r.quantParameterTensorNames = [];\n          for (var n = 0; n < t.quantParameterTensorNames.length; ++n) {\n            if (typeof t.quantParameterTensorNames[n] != \"object\") throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n            r.quantParameterTensorNames[n] = h.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.quantParameterTensorNames = []), r.defaults && (n.tensorName = \"\"), t.tensorName != null && t.hasOwnProperty(\"tensorName\") && (n.tensorName = t.tensorName), t.quantParameterTensorNames && t.quantParameterTensorNames.length) {\n          n.quantParameterTensorNames = [];\n          for (var s = 0; s < t.quantParameterTensorNames.length; ++s) n.quantParameterTensorNames[s] = h.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TensorAnnotation\";\n      }, e;\n    }(), i.GraphProto = function () {\n      function e(o) {\n        if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.node = b.emptyArray, e.prototype.name = \"\", e.prototype.initializer = b.emptyArray, e.prototype.sparseInitializer = b.emptyArray, e.prototype.docString = \"\", e.prototype.input = b.emptyArray, e.prototype.output = b.emptyArray, e.prototype.valueInfo = b.emptyArray, e.prototype.quantizationAnnotation = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.node != null && t.node.length) for (var n = 0; n < t.node.length; ++n) h.onnx.NodeProto.encode(t.node[n], r.uint32(10).fork()).ldelim();\n        if (t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(18).string(t.name), t.initializer != null && t.initializer.length) for (var n = 0; n < t.initializer.length; ++n) h.onnx.TensorProto.encode(t.initializer[n], r.uint32(42).fork()).ldelim();\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(82).string(t.docString), t.input != null && t.input.length) for (var n = 0; n < t.input.length; ++n) h.onnx.ValueInfoProto.encode(t.input[n], r.uint32(90).fork()).ldelim();\n        if (t.output != null && t.output.length) for (var n = 0; n < t.output.length; ++n) h.onnx.ValueInfoProto.encode(t.output[n], r.uint32(98).fork()).ldelim();\n        if (t.valueInfo != null && t.valueInfo.length) for (var n = 0; n < t.valueInfo.length; ++n) h.onnx.ValueInfoProto.encode(t.valueInfo[n], r.uint32(106).fork()).ldelim();\n        if (t.quantizationAnnotation != null && t.quantizationAnnotation.length) for (var n = 0; n < t.quantizationAnnotation.length; ++n) h.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n], r.uint32(114).fork()).ldelim();\n        if (t.sparseInitializer != null && t.sparseInitializer.length) for (var n = 0; n < t.sparseInitializer.length; ++n) h.onnx.SparseTensorProto.encode(t.sparseInitializer[n], r.uint32(122).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.GraphProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.node && s.node.length || (s.node = []), s.node.push(h.onnx.NodeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 2:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 5:\n              {\n                s.initializer && s.initializer.length || (s.initializer = []), s.initializer.push(h.onnx.TensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 15:\n              {\n                s.sparseInitializer && s.sparseInitializer.length || (s.sparseInitializer = []), s.sparseInitializer.push(h.onnx.SparseTensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 10:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 11:\n              {\n                s.input && s.input.length || (s.input = []), s.input.push(h.onnx.ValueInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 12:\n              {\n                s.output && s.output.length || (s.output = []), s.output.push(h.onnx.ValueInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 13:\n              {\n                s.valueInfo && s.valueInfo.length || (s.valueInfo = []), s.valueInfo.push(h.onnx.ValueInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 14:\n              {\n                s.quantizationAnnotation && s.quantizationAnnotation.length || (s.quantizationAnnotation = []), s.quantizationAnnotation.push(h.onnx.TensorAnnotation.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.node != null && t.hasOwnProperty(\"node\")) {\n          if (!Array.isArray(t.node)) return \"node: array expected\";\n          for (var r = 0; r < t.node.length; ++r) {\n            var n = h.onnx.NodeProto.verify(t.node[r]);\n            if (n) return \"node.\" + n;\n          }\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.initializer != null && t.hasOwnProperty(\"initializer\")) {\n          if (!Array.isArray(t.initializer)) return \"initializer: array expected\";\n          for (var r = 0; r < t.initializer.length; ++r) {\n            var n = h.onnx.TensorProto.verify(t.initializer[r]);\n            if (n) return \"initializer.\" + n;\n          }\n        }\n        if (t.sparseInitializer != null && t.hasOwnProperty(\"sparseInitializer\")) {\n          if (!Array.isArray(t.sparseInitializer)) return \"sparseInitializer: array expected\";\n          for (var r = 0; r < t.sparseInitializer.length; ++r) {\n            var n = h.onnx.SparseTensorProto.verify(t.sparseInitializer[r]);\n            if (n) return \"sparseInitializer.\" + n;\n          }\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.input != null && t.hasOwnProperty(\"input\")) {\n          if (!Array.isArray(t.input)) return \"input: array expected\";\n          for (var r = 0; r < t.input.length; ++r) {\n            var n = h.onnx.ValueInfoProto.verify(t.input[r]);\n            if (n) return \"input.\" + n;\n          }\n        }\n        if (t.output != null && t.hasOwnProperty(\"output\")) {\n          if (!Array.isArray(t.output)) return \"output: array expected\";\n          for (var r = 0; r < t.output.length; ++r) {\n            var n = h.onnx.ValueInfoProto.verify(t.output[r]);\n            if (n) return \"output.\" + n;\n          }\n        }\n        if (t.valueInfo != null && t.hasOwnProperty(\"valueInfo\")) {\n          if (!Array.isArray(t.valueInfo)) return \"valueInfo: array expected\";\n          for (var r = 0; r < t.valueInfo.length; ++r) {\n            var n = h.onnx.ValueInfoProto.verify(t.valueInfo[r]);\n            if (n) return \"valueInfo.\" + n;\n          }\n        }\n        if (t.quantizationAnnotation != null && t.hasOwnProperty(\"quantizationAnnotation\")) {\n          if (!Array.isArray(t.quantizationAnnotation)) return \"quantizationAnnotation: array expected\";\n          for (var r = 0; r < t.quantizationAnnotation.length; ++r) {\n            var n = h.onnx.TensorAnnotation.verify(t.quantizationAnnotation[r]);\n            if (n) return \"quantizationAnnotation.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.GraphProto) return t;\n        var r = new h.onnx.GraphProto();\n        if (t.node) {\n          if (!Array.isArray(t.node)) throw TypeError(\".onnx.GraphProto.node: array expected\");\n          r.node = [];\n          for (var n = 0; n < t.node.length; ++n) {\n            if (typeof t.node[n] != \"object\") throw TypeError(\".onnx.GraphProto.node: object expected\");\n            r.node[n] = h.onnx.NodeProto.fromObject(t.node[n]);\n          }\n        }\n        if (t.name != null && (r.name = String(t.name)), t.initializer) {\n          if (!Array.isArray(t.initializer)) throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n          r.initializer = [];\n          for (var n = 0; n < t.initializer.length; ++n) {\n            if (typeof t.initializer[n] != \"object\") throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n            r.initializer[n] = h.onnx.TensorProto.fromObject(t.initializer[n]);\n          }\n        }\n        if (t.sparseInitializer) {\n          if (!Array.isArray(t.sparseInitializer)) throw TypeError(\".onnx.GraphProto.sparseInitializer: array expected\");\n          r.sparseInitializer = [];\n          for (var n = 0; n < t.sparseInitializer.length; ++n) {\n            if (typeof t.sparseInitializer[n] != \"object\") throw TypeError(\".onnx.GraphProto.sparseInitializer: object expected\");\n            r.sparseInitializer[n] = h.onnx.SparseTensorProto.fromObject(t.sparseInitializer[n]);\n          }\n        }\n        if (t.docString != null && (r.docString = String(t.docString)), t.input) {\n          if (!Array.isArray(t.input)) throw TypeError(\".onnx.GraphProto.input: array expected\");\n          r.input = [];\n          for (var n = 0; n < t.input.length; ++n) {\n            if (typeof t.input[n] != \"object\") throw TypeError(\".onnx.GraphProto.input: object expected\");\n            r.input[n] = h.onnx.ValueInfoProto.fromObject(t.input[n]);\n          }\n        }\n        if (t.output) {\n          if (!Array.isArray(t.output)) throw TypeError(\".onnx.GraphProto.output: array expected\");\n          r.output = [];\n          for (var n = 0; n < t.output.length; ++n) {\n            if (typeof t.output[n] != \"object\") throw TypeError(\".onnx.GraphProto.output: object expected\");\n            r.output[n] = h.onnx.ValueInfoProto.fromObject(t.output[n]);\n          }\n        }\n        if (t.valueInfo) {\n          if (!Array.isArray(t.valueInfo)) throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n          r.valueInfo = [];\n          for (var n = 0; n < t.valueInfo.length; ++n) {\n            if (typeof t.valueInfo[n] != \"object\") throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n            r.valueInfo[n] = h.onnx.ValueInfoProto.fromObject(t.valueInfo[n]);\n          }\n        }\n        if (t.quantizationAnnotation) {\n          if (!Array.isArray(t.quantizationAnnotation)) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n          r.quantizationAnnotation = [];\n          for (var n = 0; n < t.quantizationAnnotation.length; ++n) {\n            if (typeof t.quantizationAnnotation[n] != \"object\") throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n            r.quantizationAnnotation[n] = h.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.node = [], n.initializer = [], n.input = [], n.output = [], n.valueInfo = [], n.quantizationAnnotation = [], n.sparseInitializer = []), r.defaults && (n.name = \"\", n.docString = \"\"), t.node && t.node.length) {\n          n.node = [];\n          for (var s = 0; s < t.node.length; ++s) n.node[s] = h.onnx.NodeProto.toObject(t.node[s], r);\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.initializer && t.initializer.length) {\n          n.initializer = [];\n          for (var s = 0; s < t.initializer.length; ++s) n.initializer[s] = h.onnx.TensorProto.toObject(t.initializer[s], r);\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.input && t.input.length) {\n          n.input = [];\n          for (var s = 0; s < t.input.length; ++s) n.input[s] = h.onnx.ValueInfoProto.toObject(t.input[s], r);\n        }\n        if (t.output && t.output.length) {\n          n.output = [];\n          for (var s = 0; s < t.output.length; ++s) n.output[s] = h.onnx.ValueInfoProto.toObject(t.output[s], r);\n        }\n        if (t.valueInfo && t.valueInfo.length) {\n          n.valueInfo = [];\n          for (var s = 0; s < t.valueInfo.length; ++s) n.valueInfo[s] = h.onnx.ValueInfoProto.toObject(t.valueInfo[s], r);\n        }\n        if (t.quantizationAnnotation && t.quantizationAnnotation.length) {\n          n.quantizationAnnotation = [];\n          for (var s = 0; s < t.quantizationAnnotation.length; ++s) n.quantizationAnnotation[s] = h.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[s], r);\n        }\n        if (t.sparseInitializer && t.sparseInitializer.length) {\n          n.sparseInitializer = [];\n          for (var s = 0; s < t.sparseInitializer.length; ++s) n.sparseInitializer[s] = h.onnx.SparseTensorProto.toObject(t.sparseInitializer[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.GraphProto\";\n      }, e;\n    }(), i.TensorProto = function () {\n      function e(o) {\n        if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.dims = b.emptyArray, e.prototype.dataType = 0, e.prototype.segment = null, e.prototype.floatData = b.emptyArray, e.prototype.int32Data = b.emptyArray, e.prototype.stringData = b.emptyArray, e.prototype.int64Data = b.emptyArray, e.prototype.name = \"\", e.prototype.docString = \"\", e.prototype.rawData = b.newBuffer([]), e.prototype.externalData = b.emptyArray, e.prototype.dataLocation = 0, e.prototype.doubleData = b.emptyArray, e.prototype.uint64Data = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.dims != null && t.dims.length) {\n          r.uint32(10).fork();\n          for (var n = 0; n < t.dims.length; ++n) r.int64(t.dims[n]);\n          r.ldelim();\n        }\n        if (t.dataType != null && Object.hasOwnProperty.call(t, \"dataType\") && r.uint32(16).int32(t.dataType), t.segment != null && Object.hasOwnProperty.call(t, \"segment\") && h.onnx.TensorProto.Segment.encode(t.segment, r.uint32(26).fork()).ldelim(), t.floatData != null && t.floatData.length) {\n          r.uint32(34).fork();\n          for (var n = 0; n < t.floatData.length; ++n) r.float(t.floatData[n]);\n          r.ldelim();\n        }\n        if (t.int32Data != null && t.int32Data.length) {\n          r.uint32(42).fork();\n          for (var n = 0; n < t.int32Data.length; ++n) r.int32(t.int32Data[n]);\n          r.ldelim();\n        }\n        if (t.stringData != null && t.stringData.length) for (var n = 0; n < t.stringData.length; ++n) r.uint32(50).bytes(t.stringData[n]);\n        if (t.int64Data != null && t.int64Data.length) {\n          r.uint32(58).fork();\n          for (var n = 0; n < t.int64Data.length; ++n) r.int64(t.int64Data[n]);\n          r.ldelim();\n        }\n        if (t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(66).string(t.name), t.rawData != null && Object.hasOwnProperty.call(t, \"rawData\") && r.uint32(74).bytes(t.rawData), t.doubleData != null && t.doubleData.length) {\n          r.uint32(82).fork();\n          for (var n = 0; n < t.doubleData.length; ++n) r.double(t.doubleData[n]);\n          r.ldelim();\n        }\n        if (t.uint64Data != null && t.uint64Data.length) {\n          r.uint32(90).fork();\n          for (var n = 0; n < t.uint64Data.length; ++n) r.uint64(t.uint64Data[n]);\n          r.ldelim();\n        }\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(98).string(t.docString), t.externalData != null && t.externalData.length) for (var n = 0; n < t.externalData.length; ++n) h.onnx.StringStringEntryProto.encode(t.externalData[n], r.uint32(106).fork()).ldelim();\n        return t.dataLocation != null && Object.hasOwnProperty.call(t, \"dataLocation\") && r.uint32(112).int32(t.dataLocation), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TensorProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                if (s.dims && s.dims.length || (s.dims = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.dims.push(t.int64());else s.dims.push(t.int64());\n                break;\n              }\n            case 2:\n              {\n                s.dataType = t.int32();\n                break;\n              }\n            case 3:\n              {\n                s.segment = h.onnx.TensorProto.Segment.decode(t, t.uint32());\n                break;\n              }\n            case 4:\n              {\n                if (s.floatData && s.floatData.length || (s.floatData = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.floatData.push(t.float());else s.floatData.push(t.float());\n                break;\n              }\n            case 5:\n              {\n                if (s.int32Data && s.int32Data.length || (s.int32Data = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.int32Data.push(t.int32());else s.int32Data.push(t.int32());\n                break;\n              }\n            case 6:\n              {\n                s.stringData && s.stringData.length || (s.stringData = []), s.stringData.push(t.bytes());\n                break;\n              }\n            case 7:\n              {\n                if (s.int64Data && s.int64Data.length || (s.int64Data = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.int64Data.push(t.int64());else s.int64Data.push(t.int64());\n                break;\n              }\n            case 8:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 12:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 9:\n              {\n                s.rawData = t.bytes();\n                break;\n              }\n            case 13:\n              {\n                s.externalData && s.externalData.length || (s.externalData = []), s.externalData.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            case 14:\n              {\n                s.dataLocation = t.int32();\n                break;\n              }\n            case 10:\n              {\n                if (s.doubleData && s.doubleData.length || (s.doubleData = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.doubleData.push(t.double());else s.doubleData.push(t.double());\n                break;\n              }\n            case 11:\n              {\n                if (s.uint64Data && s.uint64Data.length || (s.uint64Data = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.uint64Data.push(t.uint64());else s.uint64Data.push(t.uint64());\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.dims != null && t.hasOwnProperty(\"dims\")) {\n          if (!Array.isArray(t.dims)) return \"dims: array expected\";\n          for (var r = 0; r < t.dims.length; ++r) if (!b.isInteger(t.dims[r]) && !(t.dims[r] && b.isInteger(t.dims[r].low) && b.isInteger(t.dims[r].high))) return \"dims: integer|Long[] expected\";\n        }\n        if (t.dataType != null && t.hasOwnProperty(\"dataType\") && !b.isInteger(t.dataType)) return \"dataType: integer expected\";\n        if (t.segment != null && t.hasOwnProperty(\"segment\")) {\n          var n = h.onnx.TensorProto.Segment.verify(t.segment);\n          if (n) return \"segment.\" + n;\n        }\n        if (t.floatData != null && t.hasOwnProperty(\"floatData\")) {\n          if (!Array.isArray(t.floatData)) return \"floatData: array expected\";\n          for (var r = 0; r < t.floatData.length; ++r) if (typeof t.floatData[r] != \"number\") return \"floatData: number[] expected\";\n        }\n        if (t.int32Data != null && t.hasOwnProperty(\"int32Data\")) {\n          if (!Array.isArray(t.int32Data)) return \"int32Data: array expected\";\n          for (var r = 0; r < t.int32Data.length; ++r) if (!b.isInteger(t.int32Data[r])) return \"int32Data: integer[] expected\";\n        }\n        if (t.stringData != null && t.hasOwnProperty(\"stringData\")) {\n          if (!Array.isArray(t.stringData)) return \"stringData: array expected\";\n          for (var r = 0; r < t.stringData.length; ++r) if (!(t.stringData[r] && typeof t.stringData[r].length == \"number\" || b.isString(t.stringData[r]))) return \"stringData: buffer[] expected\";\n        }\n        if (t.int64Data != null && t.hasOwnProperty(\"int64Data\")) {\n          if (!Array.isArray(t.int64Data)) return \"int64Data: array expected\";\n          for (var r = 0; r < t.int64Data.length; ++r) if (!b.isInteger(t.int64Data[r]) && !(t.int64Data[r] && b.isInteger(t.int64Data[r].low) && b.isInteger(t.int64Data[r].high))) return \"int64Data: integer|Long[] expected\";\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.rawData != null && t.hasOwnProperty(\"rawData\") && !(t.rawData && typeof t.rawData.length == \"number\" || b.isString(t.rawData))) return \"rawData: buffer expected\";\n        if (t.externalData != null && t.hasOwnProperty(\"externalData\")) {\n          if (!Array.isArray(t.externalData)) return \"externalData: array expected\";\n          for (var r = 0; r < t.externalData.length; ++r) {\n            var n = h.onnx.StringStringEntryProto.verify(t.externalData[r]);\n            if (n) return \"externalData.\" + n;\n          }\n        }\n        if (t.dataLocation != null && t.hasOwnProperty(\"dataLocation\")) switch (t.dataLocation) {\n          default:\n            return \"dataLocation: enum value expected\";\n          case 0:\n          case 1:\n            break;\n        }\n        if (t.doubleData != null && t.hasOwnProperty(\"doubleData\")) {\n          if (!Array.isArray(t.doubleData)) return \"doubleData: array expected\";\n          for (var r = 0; r < t.doubleData.length; ++r) if (typeof t.doubleData[r] != \"number\") return \"doubleData: number[] expected\";\n        }\n        if (t.uint64Data != null && t.hasOwnProperty(\"uint64Data\")) {\n          if (!Array.isArray(t.uint64Data)) return \"uint64Data: array expected\";\n          for (var r = 0; r < t.uint64Data.length; ++r) if (!b.isInteger(t.uint64Data[r]) && !(t.uint64Data[r] && b.isInteger(t.uint64Data[r].low) && b.isInteger(t.uint64Data[r].high))) return \"uint64Data: integer|Long[] expected\";\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TensorProto) return t;\n        var r = new h.onnx.TensorProto();\n        if (t.dims) {\n          if (!Array.isArray(t.dims)) throw TypeError(\".onnx.TensorProto.dims: array expected\");\n          r.dims = [];\n          for (var n = 0; n < t.dims.length; ++n) b.Long ? (r.dims[n] = b.Long.fromValue(t.dims[n])).unsigned = !1 : typeof t.dims[n] == \"string\" ? r.dims[n] = parseInt(t.dims[n], 10) : typeof t.dims[n] == \"number\" ? r.dims[n] = t.dims[n] : typeof t.dims[n] == \"object\" && (r.dims[n] = new b.LongBits(t.dims[n].low >>> 0, t.dims[n].high >>> 0).toNumber());\n        }\n        if (t.dataType != null && (r.dataType = t.dataType | 0), t.segment != null) {\n          if (typeof t.segment != \"object\") throw TypeError(\".onnx.TensorProto.segment: object expected\");\n          r.segment = h.onnx.TensorProto.Segment.fromObject(t.segment);\n        }\n        if (t.floatData) {\n          if (!Array.isArray(t.floatData)) throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n          r.floatData = [];\n          for (var n = 0; n < t.floatData.length; ++n) r.floatData[n] = Number(t.floatData[n]);\n        }\n        if (t.int32Data) {\n          if (!Array.isArray(t.int32Data)) throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n          r.int32Data = [];\n          for (var n = 0; n < t.int32Data.length; ++n) r.int32Data[n] = t.int32Data[n] | 0;\n        }\n        if (t.stringData) {\n          if (!Array.isArray(t.stringData)) throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n          r.stringData = [];\n          for (var n = 0; n < t.stringData.length; ++n) typeof t.stringData[n] == \"string\" ? b.base64.decode(t.stringData[n], r.stringData[n] = b.newBuffer(b.base64.length(t.stringData[n])), 0) : t.stringData[n].length >= 0 && (r.stringData[n] = t.stringData[n]);\n        }\n        if (t.int64Data) {\n          if (!Array.isArray(t.int64Data)) throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n          r.int64Data = [];\n          for (var n = 0; n < t.int64Data.length; ++n) b.Long ? (r.int64Data[n] = b.Long.fromValue(t.int64Data[n])).unsigned = !1 : typeof t.int64Data[n] == \"string\" ? r.int64Data[n] = parseInt(t.int64Data[n], 10) : typeof t.int64Data[n] == \"number\" ? r.int64Data[n] = t.int64Data[n] : typeof t.int64Data[n] == \"object\" && (r.int64Data[n] = new b.LongBits(t.int64Data[n].low >>> 0, t.int64Data[n].high >>> 0).toNumber());\n        }\n        if (t.name != null && (r.name = String(t.name)), t.docString != null && (r.docString = String(t.docString)), t.rawData != null && (typeof t.rawData == \"string\" ? b.base64.decode(t.rawData, r.rawData = b.newBuffer(b.base64.length(t.rawData)), 0) : t.rawData.length >= 0 && (r.rawData = t.rawData)), t.externalData) {\n          if (!Array.isArray(t.externalData)) throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n          r.externalData = [];\n          for (var n = 0; n < t.externalData.length; ++n) {\n            if (typeof t.externalData[n] != \"object\") throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n            r.externalData[n] = h.onnx.StringStringEntryProto.fromObject(t.externalData[n]);\n          }\n        }\n        switch (t.dataLocation) {\n          default:\n            if (typeof t.dataLocation == \"number\") {\n              r.dataLocation = t.dataLocation;\n              break;\n            }\n            break;\n          case \"DEFAULT\":\n          case 0:\n            r.dataLocation = 0;\n            break;\n          case \"EXTERNAL\":\n          case 1:\n            r.dataLocation = 1;\n            break;\n        }\n        if (t.doubleData) {\n          if (!Array.isArray(t.doubleData)) throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n          r.doubleData = [];\n          for (var n = 0; n < t.doubleData.length; ++n) r.doubleData[n] = Number(t.doubleData[n]);\n        }\n        if (t.uint64Data) {\n          if (!Array.isArray(t.uint64Data)) throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n          r.uint64Data = [];\n          for (var n = 0; n < t.uint64Data.length; ++n) b.Long ? (r.uint64Data[n] = b.Long.fromValue(t.uint64Data[n])).unsigned = !0 : typeof t.uint64Data[n] == \"string\" ? r.uint64Data[n] = parseInt(t.uint64Data[n], 10) : typeof t.uint64Data[n] == \"number\" ? r.uint64Data[n] = t.uint64Data[n] : typeof t.uint64Data[n] == \"object\" && (r.uint64Data[n] = new b.LongBits(t.uint64Data[n].low >>> 0, t.uint64Data[n].high >>> 0).toNumber(!0));\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.dims = [], n.floatData = [], n.int32Data = [], n.stringData = [], n.int64Data = [], n.doubleData = [], n.uint64Data = [], n.externalData = []), r.defaults && (n.dataType = 0, n.segment = null, n.name = \"\", r.bytes === String ? n.rawData = \"\" : (n.rawData = [], r.bytes !== Array && (n.rawData = b.newBuffer(n.rawData))), n.docString = \"\", n.dataLocation = r.enums === String ? \"DEFAULT\" : 0), t.dims && t.dims.length) {\n          n.dims = [];\n          for (var s = 0; s < t.dims.length; ++s) typeof t.dims[s] == \"number\" ? n.dims[s] = r.longs === String ? String(t.dims[s]) : t.dims[s] : n.dims[s] = r.longs === String ? b.Long.prototype.toString.call(t.dims[s]) : r.longs === Number ? new b.LongBits(t.dims[s].low >>> 0, t.dims[s].high >>> 0).toNumber() : t.dims[s];\n        }\n        if (t.dataType != null && t.hasOwnProperty(\"dataType\") && (n.dataType = t.dataType), t.segment != null && t.hasOwnProperty(\"segment\") && (n.segment = h.onnx.TensorProto.Segment.toObject(t.segment, r)), t.floatData && t.floatData.length) {\n          n.floatData = [];\n          for (var s = 0; s < t.floatData.length; ++s) n.floatData[s] = r.json && !isFinite(t.floatData[s]) ? String(t.floatData[s]) : t.floatData[s];\n        }\n        if (t.int32Data && t.int32Data.length) {\n          n.int32Data = [];\n          for (var s = 0; s < t.int32Data.length; ++s) n.int32Data[s] = t.int32Data[s];\n        }\n        if (t.stringData && t.stringData.length) {\n          n.stringData = [];\n          for (var s = 0; s < t.stringData.length; ++s) n.stringData[s] = r.bytes === String ? b.base64.encode(t.stringData[s], 0, t.stringData[s].length) : r.bytes === Array ? Array.prototype.slice.call(t.stringData[s]) : t.stringData[s];\n        }\n        if (t.int64Data && t.int64Data.length) {\n          n.int64Data = [];\n          for (var s = 0; s < t.int64Data.length; ++s) typeof t.int64Data[s] == \"number\" ? n.int64Data[s] = r.longs === String ? String(t.int64Data[s]) : t.int64Data[s] : n.int64Data[s] = r.longs === String ? b.Long.prototype.toString.call(t.int64Data[s]) : r.longs === Number ? new b.LongBits(t.int64Data[s].low >>> 0, t.int64Data[s].high >>> 0).toNumber() : t.int64Data[s];\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.rawData != null && t.hasOwnProperty(\"rawData\") && (n.rawData = r.bytes === String ? b.base64.encode(t.rawData, 0, t.rawData.length) : r.bytes === Array ? Array.prototype.slice.call(t.rawData) : t.rawData), t.doubleData && t.doubleData.length) {\n          n.doubleData = [];\n          for (var s = 0; s < t.doubleData.length; ++s) n.doubleData[s] = r.json && !isFinite(t.doubleData[s]) ? String(t.doubleData[s]) : t.doubleData[s];\n        }\n        if (t.uint64Data && t.uint64Data.length) {\n          n.uint64Data = [];\n          for (var s = 0; s < t.uint64Data.length; ++s) typeof t.uint64Data[s] == \"number\" ? n.uint64Data[s] = r.longs === String ? String(t.uint64Data[s]) : t.uint64Data[s] : n.uint64Data[s] = r.longs === String ? b.Long.prototype.toString.call(t.uint64Data[s]) : r.longs === Number ? new b.LongBits(t.uint64Data[s].low >>> 0, t.uint64Data[s].high >>> 0).toNumber(!0) : t.uint64Data[s];\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.externalData && t.externalData.length) {\n          n.externalData = [];\n          for (var s = 0; s < t.externalData.length; ++s) n.externalData[s] = h.onnx.StringStringEntryProto.toObject(t.externalData[s], r);\n        }\n        return t.dataLocation != null && t.hasOwnProperty(\"dataLocation\") && (n.dataLocation = r.enums === String ? h.onnx.TensorProto.DataLocation[t.dataLocation] === void 0 ? t.dataLocation : h.onnx.TensorProto.DataLocation[t.dataLocation] : t.dataLocation), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TensorProto\";\n      }, e.DataType = function () {\n        var o = {},\n          t = Object.create(o);\n        return t[o[0] = \"UNDEFINED\"] = 0, t[o[1] = \"FLOAT\"] = 1, t[o[2] = \"UINT8\"] = 2, t[o[3] = \"INT8\"] = 3, t[o[4] = \"UINT16\"] = 4, t[o[5] = \"INT16\"] = 5, t[o[6] = \"INT32\"] = 6, t[o[7] = \"INT64\"] = 7, t[o[8] = \"STRING\"] = 8, t[o[9] = \"BOOL\"] = 9, t[o[10] = \"FLOAT16\"] = 10, t[o[11] = \"DOUBLE\"] = 11, t[o[12] = \"UINT32\"] = 12, t[o[13] = \"UINT64\"] = 13, t[o[14] = \"COMPLEX64\"] = 14, t[o[15] = \"COMPLEX128\"] = 15, t[o[16] = \"BFLOAT16\"] = 16, t[o[17] = \"FLOAT8E4M3FN\"] = 17, t[o[18] = \"FLOAT8E4M3FNUZ\"] = 18, t[o[19] = \"FLOAT8E5M2\"] = 19, t[o[20] = \"FLOAT8E5M2FNUZ\"] = 20, t;\n      }(), e.Segment = function () {\n        function o(t) {\n          if (t) for (var r = Object.keys(t), n = 0; n < r.length; ++n) t[r[n]] != null && (this[r[n]] = t[r[n]]);\n        }\n        return o.prototype.begin = b.Long ? b.Long.fromBits(0, 0, !1) : 0, o.prototype.end = b.Long ? b.Long.fromBits(0, 0, !1) : 0, o.create = function (r) {\n          return new o(r);\n        }, o.encode = function (r, n) {\n          return n || (n = pt.create()), r.begin != null && Object.hasOwnProperty.call(r, \"begin\") && n.uint32(8).int64(r.begin), r.end != null && Object.hasOwnProperty.call(r, \"end\") && n.uint32(16).int64(r.end), n;\n        }, o.encodeDelimited = function (r, n) {\n          return this.encode(r, n).ldelim();\n        }, o.decode = function (r, n) {\n          r instanceof $ || (r = $.create(r));\n          for (var s = n === void 0 ? r.len : r.pos + n, a = new h.onnx.TensorProto.Segment(); r.pos < s;) {\n            var u = r.uint32();\n            switch (u >>> 3) {\n              case 1:\n                {\n                  a.begin = r.int64();\n                  break;\n                }\n              case 2:\n                {\n                  a.end = r.int64();\n                  break;\n                }\n              default:\n                r.skipType(u & 7);\n                break;\n            }\n          }\n          return a;\n        }, o.decodeDelimited = function (r) {\n          return r instanceof $ || (r = new $(r)), this.decode(r, r.uint32());\n        }, o.verify = function (r) {\n          return typeof r != \"object\" || r === null ? \"object expected\" : r.begin != null && r.hasOwnProperty(\"begin\") && !b.isInteger(r.begin) && !(r.begin && b.isInteger(r.begin.low) && b.isInteger(r.begin.high)) ? \"begin: integer|Long expected\" : r.end != null && r.hasOwnProperty(\"end\") && !b.isInteger(r.end) && !(r.end && b.isInteger(r.end.low) && b.isInteger(r.end.high)) ? \"end: integer|Long expected\" : null;\n        }, o.fromObject = function (r) {\n          if (r instanceof h.onnx.TensorProto.Segment) return r;\n          var n = new h.onnx.TensorProto.Segment();\n          return r.begin != null && (b.Long ? (n.begin = b.Long.fromValue(r.begin)).unsigned = !1 : typeof r.begin == \"string\" ? n.begin = parseInt(r.begin, 10) : typeof r.begin == \"number\" ? n.begin = r.begin : typeof r.begin == \"object\" && (n.begin = new b.LongBits(r.begin.low >>> 0, r.begin.high >>> 0).toNumber())), r.end != null && (b.Long ? (n.end = b.Long.fromValue(r.end)).unsigned = !1 : typeof r.end == \"string\" ? n.end = parseInt(r.end, 10) : typeof r.end == \"number\" ? n.end = r.end : typeof r.end == \"object\" && (n.end = new b.LongBits(r.end.low >>> 0, r.end.high >>> 0).toNumber())), n;\n        }, o.toObject = function (r, n) {\n          n || (n = {});\n          var s = {};\n          if (n.defaults) {\n            if (b.Long) {\n              var a = new b.Long(0, 0, !1);\n              s.begin = n.longs === String ? a.toString() : n.longs === Number ? a.toNumber() : a;\n            } else s.begin = n.longs === String ? \"0\" : 0;\n            if (b.Long) {\n              var a = new b.Long(0, 0, !1);\n              s.end = n.longs === String ? a.toString() : n.longs === Number ? a.toNumber() : a;\n            } else s.end = n.longs === String ? \"0\" : 0;\n          }\n          return r.begin != null && r.hasOwnProperty(\"begin\") && (typeof r.begin == \"number\" ? s.begin = n.longs === String ? String(r.begin) : r.begin : s.begin = n.longs === String ? b.Long.prototype.toString.call(r.begin) : n.longs === Number ? new b.LongBits(r.begin.low >>> 0, r.begin.high >>> 0).toNumber() : r.begin), r.end != null && r.hasOwnProperty(\"end\") && (typeof r.end == \"number\" ? s.end = n.longs === String ? String(r.end) : r.end : s.end = n.longs === String ? b.Long.prototype.toString.call(r.end) : n.longs === Number ? new b.LongBits(r.end.low >>> 0, r.end.high >>> 0).toNumber() : r.end), s;\n        }, o.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, o.getTypeUrl = function (r) {\n          return r === void 0 && (r = \"type.googleapis.com\"), r + \"/onnx.TensorProto.Segment\";\n        }, o;\n      }(), e.DataLocation = function () {\n        var o = {},\n          t = Object.create(o);\n        return t[o[0] = \"DEFAULT\"] = 0, t[o[1] = \"EXTERNAL\"] = 1, t;\n      }(), e;\n    }(), i.SparseTensorProto = function () {\n      function e(o) {\n        if (this.dims = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.values = null, e.prototype.indices = null, e.prototype.dims = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.values != null && Object.hasOwnProperty.call(t, \"values\") && h.onnx.TensorProto.encode(t.values, r.uint32(10).fork()).ldelim(), t.indices != null && Object.hasOwnProperty.call(t, \"indices\") && h.onnx.TensorProto.encode(t.indices, r.uint32(18).fork()).ldelim(), t.dims != null && t.dims.length) {\n          r.uint32(26).fork();\n          for (var n = 0; n < t.dims.length; ++n) r.int64(t.dims[n]);\n          r.ldelim();\n        }\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.SparseTensorProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.values = h.onnx.TensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 2:\n              {\n                s.indices = h.onnx.TensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 3:\n              {\n                if (s.dims && s.dims.length || (s.dims = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.dims.push(t.int64());else s.dims.push(t.int64());\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.values != null && t.hasOwnProperty(\"values\")) {\n          var r = h.onnx.TensorProto.verify(t.values);\n          if (r) return \"values.\" + r;\n        }\n        if (t.indices != null && t.hasOwnProperty(\"indices\")) {\n          var r = h.onnx.TensorProto.verify(t.indices);\n          if (r) return \"indices.\" + r;\n        }\n        if (t.dims != null && t.hasOwnProperty(\"dims\")) {\n          if (!Array.isArray(t.dims)) return \"dims: array expected\";\n          for (var n = 0; n < t.dims.length; ++n) if (!b.isInteger(t.dims[n]) && !(t.dims[n] && b.isInteger(t.dims[n].low) && b.isInteger(t.dims[n].high))) return \"dims: integer|Long[] expected\";\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.SparseTensorProto) return t;\n        var r = new h.onnx.SparseTensorProto();\n        if (t.values != null) {\n          if (typeof t.values != \"object\") throw TypeError(\".onnx.SparseTensorProto.values: object expected\");\n          r.values = h.onnx.TensorProto.fromObject(t.values);\n        }\n        if (t.indices != null) {\n          if (typeof t.indices != \"object\") throw TypeError(\".onnx.SparseTensorProto.indices: object expected\");\n          r.indices = h.onnx.TensorProto.fromObject(t.indices);\n        }\n        if (t.dims) {\n          if (!Array.isArray(t.dims)) throw TypeError(\".onnx.SparseTensorProto.dims: array expected\");\n          r.dims = [];\n          for (var n = 0; n < t.dims.length; ++n) b.Long ? (r.dims[n] = b.Long.fromValue(t.dims[n])).unsigned = !1 : typeof t.dims[n] == \"string\" ? r.dims[n] = parseInt(t.dims[n], 10) : typeof t.dims[n] == \"number\" ? r.dims[n] = t.dims[n] : typeof t.dims[n] == \"object\" && (r.dims[n] = new b.LongBits(t.dims[n].low >>> 0, t.dims[n].high >>> 0).toNumber());\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.dims = []), r.defaults && (n.values = null, n.indices = null), t.values != null && t.hasOwnProperty(\"values\") && (n.values = h.onnx.TensorProto.toObject(t.values, r)), t.indices != null && t.hasOwnProperty(\"indices\") && (n.indices = h.onnx.TensorProto.toObject(t.indices, r)), t.dims && t.dims.length) {\n          n.dims = [];\n          for (var s = 0; s < t.dims.length; ++s) typeof t.dims[s] == \"number\" ? n.dims[s] = r.longs === String ? String(t.dims[s]) : t.dims[s] : n.dims[s] = r.longs === String ? b.Long.prototype.toString.call(t.dims[s]) : r.longs === Number ? new b.LongBits(t.dims[s].low >>> 0, t.dims[s].high >>> 0).toNumber() : t.dims[s];\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.SparseTensorProto\";\n      }, e;\n    }(), i.TensorShapeProto = function () {\n      function e(o) {\n        if (this.dim = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.dim = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.dim != null && t.dim.length) for (var n = 0; n < t.dim.length; ++n) h.onnx.TensorShapeProto.Dimension.encode(t.dim[n], r.uint32(10).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TensorShapeProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.dim && s.dim.length || (s.dim = []), s.dim.push(h.onnx.TensorShapeProto.Dimension.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.dim != null && t.hasOwnProperty(\"dim\")) {\n          if (!Array.isArray(t.dim)) return \"dim: array expected\";\n          for (var r = 0; r < t.dim.length; ++r) {\n            var n = h.onnx.TensorShapeProto.Dimension.verify(t.dim[r]);\n            if (n) return \"dim.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TensorShapeProto) return t;\n        var r = new h.onnx.TensorShapeProto();\n        if (t.dim) {\n          if (!Array.isArray(t.dim)) throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n          r.dim = [];\n          for (var n = 0; n < t.dim.length; ++n) {\n            if (typeof t.dim[n] != \"object\") throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n            r.dim[n] = h.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.dim = []), t.dim && t.dim.length) {\n          n.dim = [];\n          for (var s = 0; s < t.dim.length; ++s) n.dim[s] = h.onnx.TensorShapeProto.Dimension.toObject(t.dim[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TensorShapeProto\";\n      }, e.Dimension = function () {\n        function o(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        o.prototype.dimValue = null, o.prototype.dimParam = null, o.prototype.denotation = \"\";\n        var t;\n        return Object.defineProperty(o.prototype, \"value\", {\n          get: b.oneOfGetter(t = [\"dimValue\", \"dimParam\"]),\n          set: b.oneOfSetter(t)\n        }), o.create = function (n) {\n          return new o(n);\n        }, o.encode = function (n, s) {\n          return s || (s = pt.create()), n.dimValue != null && Object.hasOwnProperty.call(n, \"dimValue\") && s.uint32(8).int64(n.dimValue), n.dimParam != null && Object.hasOwnProperty.call(n, \"dimParam\") && s.uint32(18).string(n.dimParam), n.denotation != null && Object.hasOwnProperty.call(n, \"denotation\") && s.uint32(26).string(n.denotation), s;\n        }, o.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, o.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TensorShapeProto.Dimension(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.dimValue = n.int64();\n                  break;\n                }\n              case 2:\n                {\n                  u.dimParam = n.string();\n                  break;\n                }\n              case 3:\n                {\n                  u.denotation = n.string();\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, o.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, o.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          var s = {};\n          if (n.dimValue != null && n.hasOwnProperty(\"dimValue\") && (s.value = 1, !b.isInteger(n.dimValue) && !(n.dimValue && b.isInteger(n.dimValue.low) && b.isInteger(n.dimValue.high)))) return \"dimValue: integer|Long expected\";\n          if (n.dimParam != null && n.hasOwnProperty(\"dimParam\")) {\n            if (s.value === 1) return \"value: multiple values\";\n            if (s.value = 1, !b.isString(n.dimParam)) return \"dimParam: string expected\";\n          }\n          return n.denotation != null && n.hasOwnProperty(\"denotation\") && !b.isString(n.denotation) ? \"denotation: string expected\" : null;\n        }, o.fromObject = function (n) {\n          if (n instanceof h.onnx.TensorShapeProto.Dimension) return n;\n          var s = new h.onnx.TensorShapeProto.Dimension();\n          return n.dimValue != null && (b.Long ? (s.dimValue = b.Long.fromValue(n.dimValue)).unsigned = !1 : typeof n.dimValue == \"string\" ? s.dimValue = parseInt(n.dimValue, 10) : typeof n.dimValue == \"number\" ? s.dimValue = n.dimValue : typeof n.dimValue == \"object\" && (s.dimValue = new b.LongBits(n.dimValue.low >>> 0, n.dimValue.high >>> 0).toNumber())), n.dimParam != null && (s.dimParam = String(n.dimParam)), n.denotation != null && (s.denotation = String(n.denotation)), s;\n        }, o.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.denotation = \"\"), n.dimValue != null && n.hasOwnProperty(\"dimValue\") && (typeof n.dimValue == \"number\" ? a.dimValue = s.longs === String ? String(n.dimValue) : n.dimValue : a.dimValue = s.longs === String ? b.Long.prototype.toString.call(n.dimValue) : s.longs === Number ? new b.LongBits(n.dimValue.low >>> 0, n.dimValue.high >>> 0).toNumber() : n.dimValue, s.oneofs && (a.value = \"dimValue\")), n.dimParam != null && n.hasOwnProperty(\"dimParam\") && (a.dimParam = n.dimParam, s.oneofs && (a.value = \"dimParam\")), n.denotation != null && n.hasOwnProperty(\"denotation\") && (a.denotation = n.denotation), a;\n        }, o.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, o.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TensorShapeProto.Dimension\";\n        }, o;\n      }(), e;\n    }(), i.TypeProto = function () {\n      function e(t) {\n        if (t) for (var r = Object.keys(t), n = 0; n < r.length; ++n) t[r[n]] != null && (this[r[n]] = t[r[n]]);\n      }\n      e.prototype.tensorType = null, e.prototype.sequenceType = null, e.prototype.mapType = null, e.prototype.optionalType = null, e.prototype.sparseTensorType = null, e.prototype.denotation = \"\";\n      var o;\n      return Object.defineProperty(e.prototype, \"value\", {\n        get: b.oneOfGetter(o = [\"tensorType\", \"sequenceType\", \"mapType\", \"optionalType\", \"sparseTensorType\"]),\n        set: b.oneOfSetter(o)\n      }), e.create = function (r) {\n        return new e(r);\n      }, e.encode = function (r, n) {\n        return n || (n = pt.create()), r.tensorType != null && Object.hasOwnProperty.call(r, \"tensorType\") && h.onnx.TypeProto.Tensor.encode(r.tensorType, n.uint32(10).fork()).ldelim(), r.sequenceType != null && Object.hasOwnProperty.call(r, \"sequenceType\") && h.onnx.TypeProto.Sequence.encode(r.sequenceType, n.uint32(34).fork()).ldelim(), r.mapType != null && Object.hasOwnProperty.call(r, \"mapType\") && h.onnx.TypeProto.Map.encode(r.mapType, n.uint32(42).fork()).ldelim(), r.denotation != null && Object.hasOwnProperty.call(r, \"denotation\") && n.uint32(50).string(r.denotation), r.sparseTensorType != null && Object.hasOwnProperty.call(r, \"sparseTensorType\") && h.onnx.TypeProto.SparseTensor.encode(r.sparseTensorType, n.uint32(66).fork()).ldelim(), r.optionalType != null && Object.hasOwnProperty.call(r, \"optionalType\") && h.onnx.TypeProto.Optional.encode(r.optionalType, n.uint32(74).fork()).ldelim(), n;\n      }, e.encodeDelimited = function (r, n) {\n        return this.encode(r, n).ldelim();\n      }, e.decode = function (r, n) {\n        r instanceof $ || (r = $.create(r));\n        for (var s = n === void 0 ? r.len : r.pos + n, a = new h.onnx.TypeProto(); r.pos < s;) {\n          var u = r.uint32();\n          switch (u >>> 3) {\n            case 1:\n              {\n                a.tensorType = h.onnx.TypeProto.Tensor.decode(r, r.uint32());\n                break;\n              }\n            case 4:\n              {\n                a.sequenceType = h.onnx.TypeProto.Sequence.decode(r, r.uint32());\n                break;\n              }\n            case 5:\n              {\n                a.mapType = h.onnx.TypeProto.Map.decode(r, r.uint32());\n                break;\n              }\n            case 9:\n              {\n                a.optionalType = h.onnx.TypeProto.Optional.decode(r, r.uint32());\n                break;\n              }\n            case 8:\n              {\n                a.sparseTensorType = h.onnx.TypeProto.SparseTensor.decode(r, r.uint32());\n                break;\n              }\n            case 6:\n              {\n                a.denotation = r.string();\n                break;\n              }\n            default:\n              r.skipType(u & 7);\n              break;\n          }\n        }\n        return a;\n      }, e.decodeDelimited = function (r) {\n        return r instanceof $ || (r = new $(r)), this.decode(r, r.uint32());\n      }, e.verify = function (r) {\n        if (typeof r != \"object\" || r === null) return \"object expected\";\n        var n = {};\n        if (r.tensorType != null && r.hasOwnProperty(\"tensorType\")) {\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Tensor.verify(r.tensorType);\n            if (s) return \"tensorType.\" + s;\n          }\n        }\n        if (r.sequenceType != null && r.hasOwnProperty(\"sequenceType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Sequence.verify(r.sequenceType);\n            if (s) return \"sequenceType.\" + s;\n          }\n        }\n        if (r.mapType != null && r.hasOwnProperty(\"mapType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Map.verify(r.mapType);\n            if (s) return \"mapType.\" + s;\n          }\n        }\n        if (r.optionalType != null && r.hasOwnProperty(\"optionalType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Optional.verify(r.optionalType);\n            if (s) return \"optionalType.\" + s;\n          }\n        }\n        if (r.sparseTensorType != null && r.hasOwnProperty(\"sparseTensorType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.SparseTensor.verify(r.sparseTensorType);\n            if (s) return \"sparseTensorType.\" + s;\n          }\n        }\n        return r.denotation != null && r.hasOwnProperty(\"denotation\") && !b.isString(r.denotation) ? \"denotation: string expected\" : null;\n      }, e.fromObject = function (r) {\n        if (r instanceof h.onnx.TypeProto) return r;\n        var n = new h.onnx.TypeProto();\n        if (r.tensorType != null) {\n          if (typeof r.tensorType != \"object\") throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n          n.tensorType = h.onnx.TypeProto.Tensor.fromObject(r.tensorType);\n        }\n        if (r.sequenceType != null) {\n          if (typeof r.sequenceType != \"object\") throw TypeError(\".onnx.TypeProto.sequenceType: object expected\");\n          n.sequenceType = h.onnx.TypeProto.Sequence.fromObject(r.sequenceType);\n        }\n        if (r.mapType != null) {\n          if (typeof r.mapType != \"object\") throw TypeError(\".onnx.TypeProto.mapType: object expected\");\n          n.mapType = h.onnx.TypeProto.Map.fromObject(r.mapType);\n        }\n        if (r.optionalType != null) {\n          if (typeof r.optionalType != \"object\") throw TypeError(\".onnx.TypeProto.optionalType: object expected\");\n          n.optionalType = h.onnx.TypeProto.Optional.fromObject(r.optionalType);\n        }\n        if (r.sparseTensorType != null) {\n          if (typeof r.sparseTensorType != \"object\") throw TypeError(\".onnx.TypeProto.sparseTensorType: object expected\");\n          n.sparseTensorType = h.onnx.TypeProto.SparseTensor.fromObject(r.sparseTensorType);\n        }\n        return r.denotation != null && (n.denotation = String(r.denotation)), n;\n      }, e.toObject = function (r, n) {\n        n || (n = {});\n        var s = {};\n        return n.defaults && (s.denotation = \"\"), r.tensorType != null && r.hasOwnProperty(\"tensorType\") && (s.tensorType = h.onnx.TypeProto.Tensor.toObject(r.tensorType, n), n.oneofs && (s.value = \"tensorType\")), r.sequenceType != null && r.hasOwnProperty(\"sequenceType\") && (s.sequenceType = h.onnx.TypeProto.Sequence.toObject(r.sequenceType, n), n.oneofs && (s.value = \"sequenceType\")), r.mapType != null && r.hasOwnProperty(\"mapType\") && (s.mapType = h.onnx.TypeProto.Map.toObject(r.mapType, n), n.oneofs && (s.value = \"mapType\")), r.denotation != null && r.hasOwnProperty(\"denotation\") && (s.denotation = r.denotation), r.sparseTensorType != null && r.hasOwnProperty(\"sparseTensorType\") && (s.sparseTensorType = h.onnx.TypeProto.SparseTensor.toObject(r.sparseTensorType, n), n.oneofs && (s.value = \"sparseTensorType\")), r.optionalType != null && r.hasOwnProperty(\"optionalType\") && (s.optionalType = h.onnx.TypeProto.Optional.toObject(r.optionalType, n), n.oneofs && (s.value = \"optionalType\")), s;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (r) {\n        return r === void 0 && (r = \"type.googleapis.com\"), r + \"/onnx.TypeProto\";\n      }, e.Tensor = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = 0, t.prototype.shape = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && s.uint32(8).int32(n.elemType), n.shape != null && Object.hasOwnProperty.call(n, \"shape\") && h.onnx.TensorShapeProto.encode(n.shape, s.uint32(18).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Tensor(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = n.int32();\n                  break;\n                }\n              case 2:\n                {\n                  u.shape = h.onnx.TensorShapeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\") && !b.isInteger(n.elemType)) return \"elemType: integer expected\";\n          if (n.shape != null && n.hasOwnProperty(\"shape\")) {\n            var s = h.onnx.TensorShapeProto.verify(n.shape);\n            if (s) return \"shape.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Tensor) return n;\n          var s = new h.onnx.TypeProto.Tensor();\n          if (n.elemType != null && (s.elemType = n.elemType | 0), n.shape != null) {\n            if (typeof n.shape != \"object\") throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n            s.shape = h.onnx.TensorShapeProto.fromObject(n.shape);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = 0, a.shape = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = n.elemType), n.shape != null && n.hasOwnProperty(\"shape\") && (a.shape = h.onnx.TensorShapeProto.toObject(n.shape, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Tensor\";\n        }, t;\n      }(), e.Sequence = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && h.onnx.TypeProto.encode(n.elemType, s.uint32(10).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Sequence(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = h.onnx.TypeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\")) {\n            var s = h.onnx.TypeProto.verify(n.elemType);\n            if (s) return \"elemType.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Sequence) return n;\n          var s = new h.onnx.TypeProto.Sequence();\n          if (n.elemType != null) {\n            if (typeof n.elemType != \"object\") throw TypeError(\".onnx.TypeProto.Sequence.elemType: object expected\");\n            s.elemType = h.onnx.TypeProto.fromObject(n.elemType);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = h.onnx.TypeProto.toObject(n.elemType, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Sequence\";\n        }, t;\n      }(), e.Map = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.keyType = 0, t.prototype.valueType = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.keyType != null && Object.hasOwnProperty.call(n, \"keyType\") && s.uint32(8).int32(n.keyType), n.valueType != null && Object.hasOwnProperty.call(n, \"valueType\") && h.onnx.TypeProto.encode(n.valueType, s.uint32(18).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Map(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.keyType = n.int32();\n                  break;\n                }\n              case 2:\n                {\n                  u.valueType = h.onnx.TypeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.keyType != null && n.hasOwnProperty(\"keyType\") && !b.isInteger(n.keyType)) return \"keyType: integer expected\";\n          if (n.valueType != null && n.hasOwnProperty(\"valueType\")) {\n            var s = h.onnx.TypeProto.verify(n.valueType);\n            if (s) return \"valueType.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Map) return n;\n          var s = new h.onnx.TypeProto.Map();\n          if (n.keyType != null && (s.keyType = n.keyType | 0), n.valueType != null) {\n            if (typeof n.valueType != \"object\") throw TypeError(\".onnx.TypeProto.Map.valueType: object expected\");\n            s.valueType = h.onnx.TypeProto.fromObject(n.valueType);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.keyType = 0, a.valueType = null), n.keyType != null && n.hasOwnProperty(\"keyType\") && (a.keyType = n.keyType), n.valueType != null && n.hasOwnProperty(\"valueType\") && (a.valueType = h.onnx.TypeProto.toObject(n.valueType, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Map\";\n        }, t;\n      }(), e.Optional = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && h.onnx.TypeProto.encode(n.elemType, s.uint32(10).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Optional(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = h.onnx.TypeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\")) {\n            var s = h.onnx.TypeProto.verify(n.elemType);\n            if (s) return \"elemType.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Optional) return n;\n          var s = new h.onnx.TypeProto.Optional();\n          if (n.elemType != null) {\n            if (typeof n.elemType != \"object\") throw TypeError(\".onnx.TypeProto.Optional.elemType: object expected\");\n            s.elemType = h.onnx.TypeProto.fromObject(n.elemType);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = h.onnx.TypeProto.toObject(n.elemType, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Optional\";\n        }, t;\n      }(), e.SparseTensor = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = 0, t.prototype.shape = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && s.uint32(8).int32(n.elemType), n.shape != null && Object.hasOwnProperty.call(n, \"shape\") && h.onnx.TensorShapeProto.encode(n.shape, s.uint32(18).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.SparseTensor(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = n.int32();\n                  break;\n                }\n              case 2:\n                {\n                  u.shape = h.onnx.TensorShapeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\") && !b.isInteger(n.elemType)) return \"elemType: integer expected\";\n          if (n.shape != null && n.hasOwnProperty(\"shape\")) {\n            var s = h.onnx.TensorShapeProto.verify(n.shape);\n            if (s) return \"shape.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.SparseTensor) return n;\n          var s = new h.onnx.TypeProto.SparseTensor();\n          if (n.elemType != null && (s.elemType = n.elemType | 0), n.shape != null) {\n            if (typeof n.shape != \"object\") throw TypeError(\".onnx.TypeProto.SparseTensor.shape: object expected\");\n            s.shape = h.onnx.TensorShapeProto.fromObject(n.shape);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = 0, a.shape = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = n.elemType), n.shape != null && n.hasOwnProperty(\"shape\") && (a.shape = h.onnx.TensorShapeProto.toObject(n.shape, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.SparseTensor\";\n        }, t;\n      }(), e;\n    }(), i.OperatorSetIdProto = function () {\n      function e(o) {\n        if (o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.domain = \"\", e.prototype.version = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        return r || (r = pt.create()), t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(10).string(t.domain), t.version != null && Object.hasOwnProperty.call(t, \"version\") && r.uint32(16).int64(t.version), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.OperatorSetIdProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.domain = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.version = t.int64();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        return typeof t != \"object\" || t === null ? \"object expected\" : t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain) ? \"domain: string expected\" : t.version != null && t.hasOwnProperty(\"version\") && !b.isInteger(t.version) && !(t.version && b.isInteger(t.version.low) && b.isInteger(t.version.high)) ? \"version: integer|Long expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.OperatorSetIdProto) return t;\n        var r = new h.onnx.OperatorSetIdProto();\n        return t.domain != null && (r.domain = String(t.domain)), t.version != null && (b.Long ? (r.version = b.Long.fromValue(t.version)).unsigned = !1 : typeof t.version == \"string\" ? r.version = parseInt(t.version, 10) : typeof t.version == \"number\" ? r.version = t.version : typeof t.version == \"object\" && (r.version = new b.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber())), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if (r.defaults) if (n.domain = \"\", b.Long) {\n          var s = new b.Long(0, 0, !1);\n          n.version = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n        } else n.version = r.longs === String ? \"0\" : 0;\n        return t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), t.version != null && t.hasOwnProperty(\"version\") && (typeof t.version == \"number\" ? n.version = r.longs === String ? String(t.version) : t.version : n.version = r.longs === String ? b.Long.prototype.toString.call(t.version) : r.longs === Number ? new b.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber() : t.version), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.OperatorSetIdProto\";\n      }, e;\n    }(), i.OperatorStatus = function () {\n      var e = {},\n        o = Object.create(e);\n      return o[e[0] = \"EXPERIMENTAL\"] = 0, o[e[1] = \"STABLE\"] = 1, o;\n    }(), i.FunctionProto = function () {\n      function e(o) {\n        if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.name = \"\", e.prototype.input = b.emptyArray, e.prototype.output = b.emptyArray, e.prototype.attribute = b.emptyArray, e.prototype.attributeProto = b.emptyArray, e.prototype.node = b.emptyArray, e.prototype.docString = \"\", e.prototype.opsetImport = b.emptyArray, e.prototype.domain = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(10).string(t.name), t.input != null && t.input.length) for (var n = 0; n < t.input.length; ++n) r.uint32(34).string(t.input[n]);\n        if (t.output != null && t.output.length) for (var n = 0; n < t.output.length; ++n) r.uint32(42).string(t.output[n]);\n        if (t.attribute != null && t.attribute.length) for (var n = 0; n < t.attribute.length; ++n) r.uint32(50).string(t.attribute[n]);\n        if (t.node != null && t.node.length) for (var n = 0; n < t.node.length; ++n) h.onnx.NodeProto.encode(t.node[n], r.uint32(58).fork()).ldelim();\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(66).string(t.docString), t.opsetImport != null && t.opsetImport.length) for (var n = 0; n < t.opsetImport.length; ++n) h.onnx.OperatorSetIdProto.encode(t.opsetImport[n], r.uint32(74).fork()).ldelim();\n        if (t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(82).string(t.domain), t.attributeProto != null && t.attributeProto.length) for (var n = 0; n < t.attributeProto.length; ++n) h.onnx.AttributeProto.encode(t.attributeProto[n], r.uint32(90).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.FunctionProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 4:\n              {\n                s.input && s.input.length || (s.input = []), s.input.push(t.string());\n                break;\n              }\n            case 5:\n              {\n                s.output && s.output.length || (s.output = []), s.output.push(t.string());\n                break;\n              }\n            case 6:\n              {\n                s.attribute && s.attribute.length || (s.attribute = []), s.attribute.push(t.string());\n                break;\n              }\n            case 11:\n              {\n                s.attributeProto && s.attributeProto.length || (s.attributeProto = []), s.attributeProto.push(h.onnx.AttributeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 7:\n              {\n                s.node && s.node.length || (s.node = []), s.node.push(h.onnx.NodeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 8:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 9:\n              {\n                s.opsetImport && s.opsetImport.length || (s.opsetImport = []), s.opsetImport.push(h.onnx.OperatorSetIdProto.decode(t, t.uint32()));\n                break;\n              }\n            case 10:\n              {\n                s.domain = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.input != null && t.hasOwnProperty(\"input\")) {\n          if (!Array.isArray(t.input)) return \"input: array expected\";\n          for (var r = 0; r < t.input.length; ++r) if (!b.isString(t.input[r])) return \"input: string[] expected\";\n        }\n        if (t.output != null && t.hasOwnProperty(\"output\")) {\n          if (!Array.isArray(t.output)) return \"output: array expected\";\n          for (var r = 0; r < t.output.length; ++r) if (!b.isString(t.output[r])) return \"output: string[] expected\";\n        }\n        if (t.attribute != null && t.hasOwnProperty(\"attribute\")) {\n          if (!Array.isArray(t.attribute)) return \"attribute: array expected\";\n          for (var r = 0; r < t.attribute.length; ++r) if (!b.isString(t.attribute[r])) return \"attribute: string[] expected\";\n        }\n        if (t.attributeProto != null && t.hasOwnProperty(\"attributeProto\")) {\n          if (!Array.isArray(t.attributeProto)) return \"attributeProto: array expected\";\n          for (var r = 0; r < t.attributeProto.length; ++r) {\n            var n = h.onnx.AttributeProto.verify(t.attributeProto[r]);\n            if (n) return \"attributeProto.\" + n;\n          }\n        }\n        if (t.node != null && t.hasOwnProperty(\"node\")) {\n          if (!Array.isArray(t.node)) return \"node: array expected\";\n          for (var r = 0; r < t.node.length; ++r) {\n            var n = h.onnx.NodeProto.verify(t.node[r]);\n            if (n) return \"node.\" + n;\n          }\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.opsetImport != null && t.hasOwnProperty(\"opsetImport\")) {\n          if (!Array.isArray(t.opsetImport)) return \"opsetImport: array expected\";\n          for (var r = 0; r < t.opsetImport.length; ++r) {\n            var n = h.onnx.OperatorSetIdProto.verify(t.opsetImport[r]);\n            if (n) return \"opsetImport.\" + n;\n          }\n        }\n        return t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain) ? \"domain: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.FunctionProto) return t;\n        var r = new h.onnx.FunctionProto();\n        if (t.name != null && (r.name = String(t.name)), t.input) {\n          if (!Array.isArray(t.input)) throw TypeError(\".onnx.FunctionProto.input: array expected\");\n          r.input = [];\n          for (var n = 0; n < t.input.length; ++n) r.input[n] = String(t.input[n]);\n        }\n        if (t.output) {\n          if (!Array.isArray(t.output)) throw TypeError(\".onnx.FunctionProto.output: array expected\");\n          r.output = [];\n          for (var n = 0; n < t.output.length; ++n) r.output[n] = String(t.output[n]);\n        }\n        if (t.attribute) {\n          if (!Array.isArray(t.attribute)) throw TypeError(\".onnx.FunctionProto.attribute: array expected\");\n          r.attribute = [];\n          for (var n = 0; n < t.attribute.length; ++n) r.attribute[n] = String(t.attribute[n]);\n        }\n        if (t.attributeProto) {\n          if (!Array.isArray(t.attributeProto)) throw TypeError(\".onnx.FunctionProto.attributeProto: array expected\");\n          r.attributeProto = [];\n          for (var n = 0; n < t.attributeProto.length; ++n) {\n            if (typeof t.attributeProto[n] != \"object\") throw TypeError(\".onnx.FunctionProto.attributeProto: object expected\");\n            r.attributeProto[n] = h.onnx.AttributeProto.fromObject(t.attributeProto[n]);\n          }\n        }\n        if (t.node) {\n          if (!Array.isArray(t.node)) throw TypeError(\".onnx.FunctionProto.node: array expected\");\n          r.node = [];\n          for (var n = 0; n < t.node.length; ++n) {\n            if (typeof t.node[n] != \"object\") throw TypeError(\".onnx.FunctionProto.node: object expected\");\n            r.node[n] = h.onnx.NodeProto.fromObject(t.node[n]);\n          }\n        }\n        if (t.docString != null && (r.docString = String(t.docString)), t.opsetImport) {\n          if (!Array.isArray(t.opsetImport)) throw TypeError(\".onnx.FunctionProto.opsetImport: array expected\");\n          r.opsetImport = [];\n          for (var n = 0; n < t.opsetImport.length; ++n) {\n            if (typeof t.opsetImport[n] != \"object\") throw TypeError(\".onnx.FunctionProto.opsetImport: object expected\");\n            r.opsetImport[n] = h.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n]);\n          }\n        }\n        return t.domain != null && (r.domain = String(t.domain)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.input = [], n.output = [], n.attribute = [], n.node = [], n.opsetImport = [], n.attributeProto = []), r.defaults && (n.name = \"\", n.docString = \"\", n.domain = \"\"), t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.input && t.input.length) {\n          n.input = [];\n          for (var s = 0; s < t.input.length; ++s) n.input[s] = t.input[s];\n        }\n        if (t.output && t.output.length) {\n          n.output = [];\n          for (var s = 0; s < t.output.length; ++s) n.output[s] = t.output[s];\n        }\n        if (t.attribute && t.attribute.length) {\n          n.attribute = [];\n          for (var s = 0; s < t.attribute.length; ++s) n.attribute[s] = t.attribute[s];\n        }\n        if (t.node && t.node.length) {\n          n.node = [];\n          for (var s = 0; s < t.node.length; ++s) n.node[s] = h.onnx.NodeProto.toObject(t.node[s], r);\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.opsetImport && t.opsetImport.length) {\n          n.opsetImport = [];\n          for (var s = 0; s < t.opsetImport.length; ++s) n.opsetImport[s] = h.onnx.OperatorSetIdProto.toObject(t.opsetImport[s], r);\n        }\n        if (t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), t.attributeProto && t.attributeProto.length) {\n          n.attributeProto = [];\n          for (var s = 0; s < t.attributeProto.length; ++s) n.attributeProto[s] = h.onnx.AttributeProto.toObject(t.attributeProto[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.FunctionProto\";\n      }, e;\n    }(), i;\n  }();\n  zu.exports = h;\n});\nfunction ur(i, e) {\n  if (!i) throw new Error(typeof e == \"string\" ? e : e());\n}\nfunction kr(i) {\n  return new TextDecoder().decode(i);\n}\nvar ot,\n  Me,\n  ai,\n  kt,\n  Sn,\n  At,\n  Rt,\n  B,\n  $r,\n  Ue,\n  Ve,\n  ze,\n  Y = O(() => {\n    \"use strict\";\n\n    wn();\n    qo();\n    ot = rr(sr());\n    We();\n    Me = class {\n      static arraysEqual(e, o) {\n        if (e.length !== o.length) return !1;\n        for (let t = 0; t < e.length; t++) if (e[t] !== o[t]) return !1;\n        return !0;\n      }\n    }, ai = class {\n      static preprocessInputShapes(e, o) {\n        let t = e.length === 1 ? [1, e[0]] : e,\n          r = o.length === 1 ? [o[0], 1] : o;\n        return [t, r];\n      }\n      static postprocessOutputShape(e, o, t) {\n        o === 1 && e.splice(e.length - 2, 1), t === 1 && e.pop();\n      }\n      static calcMatMulShape(e, o) {\n        return e[1] !== o[0] ? void 0 : [e[0], o[1]];\n      }\n    }, kt = class i {\n      static calcShape(e, o, t = !1) {\n        let r = e.length,\n          n = o.length;\n        if (r === 0) return o;\n        if (n === 0) return e;\n        let s = Math.max(e.length, o.length),\n          a = new Array(s);\n        if (t) {\n          if (r < 2 || n < 2) return;\n          let u = ai.calcMatMulShape([e[r - 2], e[r - 1]], [o[n - 2], o[n - 1]]);\n          if (u === void 0) return;\n          [a[s - 2], a[s - 1]] = u;\n        }\n        for (let u = t ? 3 : 1; u <= s; u++) {\n          let l = r - u < 0 ? 1 : e[r - u],\n            f = n - u < 0 ? 1 : o[n - u];\n          if (l !== f && l > 1 && f > 1) return;\n          a[s - u] = Math.max(l, f);\n        }\n        return a;\n      }\n      static index(e, o) {\n        let t = new Array(o.length);\n        return i.fillIndex(e, o, t), t;\n      }\n      static fillIndex(e, o, t) {\n        let r = e.length - o.length;\n        for (let n = 0; n < o.length; n++) t[n] = e[r + n] % o[n];\n      }\n      static calc(e, o, t, r, n) {\n        let s = i.calcShape(e.dims, o.dims);\n        if (s) {\n          if (r && !B.areEqual(s, e.dims)) return;\n          let a = B.size(s),\n            u = r ? e : new bt(s, n || e.type);\n          if (s.length === 0) u.set([], t(e.get([]), o.get([])));else {\n            let l = new Array(s.length),\n              f = new Array(e.dims.length),\n              p = new Array(o.dims.length),\n              d = 0,\n              y = 0,\n              T = !1,\n              v = !1;\n            e.dims.length === 0 && (d = e.get([]), T = !0), o.dims.length === 0 && (y = o.get([]), v = !0);\n            let S;\n            for (let L = 0; L < a; L++) {\n              S = L;\n              for (let P = s.length - 1; P >= 0; P--) l[P] = S % s[P], S = Math.floor(S / s[P]);\n              T || (i.fillIndex(l, e.dims, f), d = e.get(f)), v || (i.fillIndex(l, o.dims, p), y = o.get(p)), u.set(l, t(d, y));\n            }\n          }\n          return u;\n        }\n      }\n      static isValidBroadcast(e, o) {\n        let t = e.length,\n          r = o.length;\n        if (t > r) return !1;\n        for (let n = 1; n <= t; n++) if (e[t - n] !== 1 && e[t - n] !== o[r - n]) return !1;\n        return !0;\n      }\n      static getBroadcastDims(e, o) {\n        let t = e.length,\n          r = [];\n        for (let n = 0; n < t; n++) {\n          let s = t - 1 - n,\n            a = e[s] || 1;\n          (o[o.length - 1 - n] || 1) > 1 && a === 1 && r.unshift(s);\n        }\n        return r;\n      }\n    }, Sn = class {\n      static getShapeOfGemmResult(e, o, t, r, n) {\n        if (e.length !== 2 || t.length !== 2) throw new Error(\"shape need to be of size 2\");\n        let s, a, u;\n        o ? (s = e[1], a = e[0]) : (s = e[0], a = e[1]);\n        let l = -1;\n        if (r ? (u = t[0], l = 1) : (u = t[1], l = 0), t[l] !== a) throw new Error(\"dimension mismatch\");\n        if (s <= 0 || u <= 0 || a <= 0) throw new Error(\"invalid shape specified\");\n        if (n && !kt.isValidBroadcast(n, [s, u])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n        return [s, u, a];\n      }\n    }, At = class i {\n      static tensorDataTypeFromProto(e) {\n        switch (e) {\n          case ot.onnx.TensorProto.DataType.INT8:\n            return \"int8\";\n          case ot.onnx.TensorProto.DataType.UINT8:\n            return \"uint8\";\n          case ot.onnx.TensorProto.DataType.BOOL:\n            return \"bool\";\n          case ot.onnx.TensorProto.DataType.INT16:\n            return \"int16\";\n          case ot.onnx.TensorProto.DataType.UINT16:\n            return \"uint16\";\n          case ot.onnx.TensorProto.DataType.INT32:\n            return \"int32\";\n          case ot.onnx.TensorProto.DataType.UINT32:\n            return \"uint32\";\n          case ot.onnx.TensorProto.DataType.FLOAT:\n            return \"float32\";\n          case ot.onnx.TensorProto.DataType.DOUBLE:\n            return \"float64\";\n          case ot.onnx.TensorProto.DataType.STRING:\n            return \"string\";\n          case ot.onnx.TensorProto.DataType.INT64:\n            return \"int32\";\n          case ot.onnx.TensorProto.DataType.UINT64:\n            return \"uint32\";\n          default:\n            throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[e]}`);\n        }\n      }\n      static tensorDataTypeStringToEnum(e) {\n        switch (e) {\n          case \"int8\":\n            return ot.onnx.TensorProto.DataType.INT8;\n          case \"uint8\":\n            return ot.onnx.TensorProto.DataType.UINT8;\n          case \"bool\":\n            return ot.onnx.TensorProto.DataType.BOOL;\n          case \"int16\":\n            return ot.onnx.TensorProto.DataType.INT16;\n          case \"uint16\":\n            return ot.onnx.TensorProto.DataType.UINT16;\n          case \"int32\":\n            return ot.onnx.TensorProto.DataType.INT32;\n          case \"uint32\":\n            return ot.onnx.TensorProto.DataType.UINT32;\n          case \"float32\":\n            return ot.onnx.TensorProto.DataType.FLOAT;\n          case \"float64\":\n            return ot.onnx.TensorProto.DataType.DOUBLE;\n          case \"string\":\n            return ot.onnx.TensorProto.DataType.STRING;\n          case \"int64\":\n            return ot.onnx.TensorProto.DataType.INT64;\n          case \"uint64\":\n            return ot.onnx.TensorProto.DataType.UINT64;\n          default:\n            throw new Error(`unsupported data type: ${e}`);\n        }\n      }\n      static tensorDimsFromProto(e) {\n        return e.map(o => xe.isLong(o) ? o.toNumber() : o);\n      }\n      static tensorValueTypeFromProto(e) {\n        return {\n          tensorType: i.tensorDataTypeFromProto(e.elemType),\n          shape: {\n            dims: i.tensorDimsFromProto(e.shape.dim.map(o => o.dimValue))\n          }\n        };\n      }\n      static tensorDimsFromORTFormat(e) {\n        let o = [];\n        for (let t = 0; t < e.dimsLength(); t++) o.push(Rt.longToNumber(e.dims(t)));\n        return o;\n      }\n      static tensorAttributesFromORTFormat(e) {\n        let o = [];\n        for (let t = 0; t < e.attributesLength(); t++) o.push(e.attributes(t));\n        return o;\n      }\n    }, Rt = class {\n      static longToNumber(e, o) {\n        return xe.isLong(e) ? e.toNumber() : e instanceof w.Long ? xe.fromValue({\n          low: e.low,\n          high: e.high,\n          unsigned: o ?? !1\n        }).toNumber() : e;\n      }\n      static isLong(e) {\n        return xe.isLong(e) || e instanceof w.Long;\n      }\n    }, B = class i {\n      static size(e) {\n        return i.getSizeFromDimensionRange(e, 0, e.length);\n      }\n      static sizeFromDimension(e, o) {\n        if (o < 0 || o > e.length) throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${e.length} dimensions.`);\n        return i.getSizeFromDimensionRange(e, o, e.length);\n      }\n      static sizeToDimension(e, o) {\n        if (o < 0 || o > e.length) throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${e.length} dimensions.`);\n        return i.getSizeFromDimensionRange(e, 0, o);\n      }\n      static getSizeFromDimensionRange(e, o, t) {\n        let r = 1;\n        for (let n = o; n < t; n++) {\n          if (e[n] <= 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");\n          r *= e[n];\n        }\n        return r;\n      }\n      static computeStrides(e) {\n        let o = e.length;\n        if (o === 0) return [];\n        if (o === 1) return [1];\n        let t = new Array(o);\n        t[o - 1] = 1, t[o - 2] = e[o - 1];\n        for (let r = o - 3; r >= 0; --r) t[r] = t[r + 1] * e[r + 1];\n        return t;\n      }\n      static transpose(e) {\n        return e.slice().reverse();\n      }\n      static indicesToOffset(e, o, t) {\n        t === void 0 && (t = e.length);\n        let r = 0;\n        for (let n = 0; n < t; ++n) r += o[n] * e[n];\n        return r;\n      }\n      static offsetToIndices(e, o) {\n        let t = o.length;\n        if (t === 0) return [];\n        if (t === 1) return [e * o[0]];\n        let r = new Array(o.length);\n        for (let n = 0; n < r.length - 1; ++n) r[n] = Math.floor(e / o[n]), e -= r[n] * o[n];\n        return r[r.length - 1] = e, r;\n      }\n      static normalizeAxis(e, o) {\n        if (e < -o && e >= o) throw new Error(\"unsupported axis for this operation.\");\n        return e < 0 ? e + o : e;\n      }\n      static normalizeAxes(e, o) {\n        return e.map(t => this.normalizeAxis(t, o));\n      }\n      static incrementIndex(e, o, t) {\n        if (o.length === 0 || e.length === 0) throw new Error(\"Index incrementing unsupported for scalar Tensor\");\n        if (t === void 0) t = o.length;else if (t <= 0 || t > o.length) throw new Error(\"Incorrect axis to increment on\");\n        for (let r = t - 1; r >= 0 && (e[r]++, !(e[r] < o[r])); --r) e[r] = 0;\n      }\n      static calculateReshapedDims(e, o) {\n        if (o.length === 0) {\n          if (e.length === 0 || i.size(e) === 1) return [];\n          throw new Error(\"cannot reshape to a scalar Tensor\");\n        }\n        let t = o.length,\n          r = new Array(t),\n          n = -1,\n          s = 1;\n        for (let u = 0; u < t; u++) {\n          if (o[u] < -1) throw new Error(\"a dimension in shape hints cannot be less than -1\");\n          if (o[u] === -1) {\n            if (n !== -1) throw new Error(\"at most one dimension in shape hints can be -1\");\n            n = u;\n          } else {\n            if (o[u] === 0) {\n              if (u >= e.length) throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");\n              r[u] = e[u];\n            } else r[u] = o[u];\n            s *= r[u];\n          }\n        }\n        let a = i.size(e);\n        if (n !== -1) {\n          if (a % s !== 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${o}]`);\n          r[n] = a / s;\n        } else if (s !== a) throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n        return r;\n      }\n      static sortBasedOnPerm(e, o) {\n        return o ? o.map(t => e[t]) : e.slice().reverse();\n      }\n      static padShape(e, o) {\n        let t = e.length;\n        return e.map((r, n) => r + o[n] + o[n + t]);\n      }\n      static areEqual(e, o) {\n        return e.length !== o.length ? !1 : e.every((t, r) => t === o[r]);\n      }\n      static validateDimsAndCalcSize(e) {\n        if (e.length > 6) throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");\n        let o = 1;\n        for (let t of e) {\n          if (!Number.isInteger(t)) throw new TypeError(`Invalid shape: ${t} is not an integer`);\n          if (t < 0 || t > 2147483647) throw new TypeError(`Invalid shape: length ${t} is not allowed`);\n          o *= t;\n        }\n        return o;\n      }\n      static flattenShape(e, o) {\n        o < 0 && (o += e.length);\n        let t = e.reduce((s, a) => s * a, 1),\n          r = e.slice(o).reduce((s, a) => s * a, 1);\n        return [t / r, r];\n      }\n      static squeezeShape(e, o) {\n        let t = new Array();\n        o = i.normalizeAxes(o, e.length);\n        for (let r = 0; r < e.length; r++) {\n          let n = o.indexOf(r) >= 0;\n          if (n && e[r] !== 1) throw new Error(\"squeeze an axis of size different than 1\");\n          (o.length === 0 && e[r] > 1 || o.length > 0 && !n) && t.push(e[r]);\n        }\n        return t;\n      }\n      static unsqueezeShape(e, o) {\n        let t = new Array(e.length + o.length);\n        t.fill(0);\n        for (let n = 0; n < o.length; n++) {\n          let s = i.normalizeAxis(o[n], t.length);\n          if (s >= t.length) throw new Error(\"'axes' has an out of range axis\");\n          if (t[s] !== 0) throw new Error(\"'axes' has a duplicate axis\");\n          t[s] = 1;\n        }\n        let r = 0;\n        for (let n = 0; n < t.length; n++) t[n] === 0 && (t[n] = e[r++]);\n        if (r !== e.length) throw new Error(\"the unsqueezed dimension could not be established\");\n        return t;\n      }\n    }, $r = class i {\n      static splitShape(e, o, t, r) {\n        if (t.length === 0) {\n          if (!r) throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n          i.determineSplit(e[o], r, t);\n        }\n        let n = [],\n          s = [0];\n        for (let a = 0; a < t.length; ++a) {\n          a !== 0 && s.push(s[a - 1] + t[a - 1]);\n          let u = e.slice();\n          u[o] = t[a], n.push(u);\n        }\n        return [n, s];\n      }\n      static determineSplit(e, o, t) {\n        if (e % o !== 0) throw new Error(\"cannot split tensor to equal sized parts\");\n        for (let r = 0; r < o; ++r) t.push(e / o);\n      }\n    }, Ue = class i {\n      static adjustPoolAttributes(e, o, t, r, n, s) {\n        if (!e && t.length !== o.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n        if (e) for (let a = 0; a < o.length - 2; a++) a >= t.length ? t.push(o[a + 2]) : t[a] = o[a + 2];\n        for (let a = 0; a < t.length; a++) if (a < r.length) {\n          if (r[a] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n        } else r.push(1);\n        for (let a = 0; a < t.length; a++) if (a < n.length) {\n          if (n[a] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n        } else n.push(1);\n        for (let a = 0; a < t.length * 2; a++) if (a < s.length) {\n          if (s[a] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n        } else s.push(0);\n        for (let a = 0; a < t.length; a++) {\n          if (t[a] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n          if (s[a] >= t[a] || s[a + t.length] >= t[a]) throw new Error(\"pads should be smaller than kernel\");\n        }\n      }\n      static adjustPadsBasedOnAutoPad(e, o, t, r, n, s) {\n        if (s) {\n          if (n.length !== 2 * (e.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n          if (o.length !== e.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n          if (r.length !== e.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n          for (let a = 0; a < e.length - 2; a++) i.adjustPadAndReturnShape(e[a + 2], o[a], t[a], r[a], n, a, a + e.length - 2, s);\n        }\n      }\n      static computePoolOutputShape(e, o, t, r, n, s, a) {\n        if (o.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n        let u = [o[0], o[1]];\n        return i.computeShapeHelper(e, o, u, t, r, n, s, a), u;\n      }\n      static computeConvOutputShape(e, o, t, r, n, s, a) {\n        if (e.length <= 0 || o.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n        let u = [e[0], o[0]];\n        return i.computeShapeHelper(!1, e, u, t, r, n, s, a), u;\n      }\n      static computeShapeHelper(e, o, t, r, n, s, a, u) {\n        if (e) for (let l = 0; l < o.length - 2; l++) t.push(1);else for (let l = 0; l < o.length - 2; l++) t.push(i.adjustPadAndReturnShape(o[l + 2], r[l], n[l], s[l], a, l, l + o.length - 2, u));\n      }\n      static adjustPadAndReturnShape(e, o, t, r, n, s, a, u) {\n        let l = t * (r - 1) + 1;\n        if (u && u !== \"NOTSET\") switch (u) {\n          case \"VALID\":\n            return n[s] = 0, n[a] = 0, Math.floor((e - l) / o + 1);\n          case \"SAME_LOWER\":\n          case \"SAME_UPPER\":\n            if (t !== 1) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n            {\n              let p = ((e + o - 1) / o - 1) * o + r - e;\n              return n[s] = Math.floor(u === \"SAME_LOWER\" ? (p + 1) / 2 : p / 2), n[a] = p - n[s], Math.floor((e + p - r) / o + 1);\n            }\n          default:\n            throw new Error(\"Unsupported AutoPad type\");\n        } else return Math.floor((e + n[s] + n[a] - l) / o + 1);\n      }\n    }, Ve = -34028234663852886e22, ze = 34028234663852886e22;\n  });\nfunction hh(i) {\n  switch (i) {\n    case \"bool\":\n    case \"int8\":\n    case \"uint8\":\n      return 1;\n    case \"int16\":\n    case \"uint16\":\n      return 2;\n    case \"int32\":\n    case \"uint32\":\n    case \"float32\":\n      return 4;\n    case \"float64\":\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${i}`);\n  }\n}\nfunction Wu(i) {\n  switch (i) {\n    case H.onnx.TensorProto.DataType.UINT8:\n    case H.onnx.TensorProto.DataType.INT8:\n    case H.onnx.TensorProto.DataType.BOOL:\n      return 1;\n    case H.onnx.TensorProto.DataType.UINT16:\n    case H.onnx.TensorProto.DataType.INT16:\n      return 2;\n    case H.onnx.TensorProto.DataType.FLOAT:\n    case H.onnx.TensorProto.DataType.INT32:\n    case H.onnx.TensorProto.DataType.UINT32:\n      return 4;\n    case H.onnx.TensorProto.DataType.INT64:\n    case H.onnx.TensorProto.DataType.DOUBLE:\n    case H.onnx.TensorProto.DataType.UINT64:\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${H.onnx.TensorProto.DataType[i]}`);\n  }\n}\nfunction mh(i, e) {\n  return new (ju(e))(i);\n}\nfunction ju(i) {\n  switch (i) {\n    case \"bool\":\n    case \"uint8\":\n      return Uint8Array;\n    case \"int8\":\n      return Int8Array;\n    case \"int16\":\n      return Int16Array;\n    case \"uint16\":\n      return Uint16Array;\n    case \"int32\":\n      return Int32Array;\n    case \"uint32\":\n      return Uint32Array;\n    case \"int64\":\n      return BigInt64Array;\n    case \"float32\":\n      return Float32Array;\n    case \"float64\":\n      return Float64Array;\n    default:\n      throw new Error(\"unspecified error\");\n  }\n}\nfunction ui(i, e) {\n  if (e === H.onnx.TensorProto.DataType.INT64 || e === si.TensorDataType.INT64) {\n    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) throw new TypeError(\"int64 is not supported\");\n  } else if (e === H.onnx.TensorProto.DataType.UINT32 || e === si.TensorDataType.UINT32 || e === H.onnx.TensorProto.DataType.UINT64 || e === si.TensorDataType.UINT64) {\n    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) throw new TypeError(\"uint64 is not supported\");\n  } else throw new TypeError(`not a LONG type: ${H.onnx.TensorProto.DataType[e]}`);\n  return i.toNumber();\n}\nfunction Hu(i, e, o) {\n  switch (e) {\n    case H.onnx.TensorProto.DataType.BOOL:\n    case H.onnx.TensorProto.DataType.UINT8:\n      return i.getUint8(o);\n    case H.onnx.TensorProto.DataType.INT8:\n      return i.getInt8(o);\n    case H.onnx.TensorProto.DataType.UINT16:\n      return i.getUint16(o, !0);\n    case H.onnx.TensorProto.DataType.INT16:\n      return i.getInt16(o, !0);\n    case H.onnx.TensorProto.DataType.FLOAT:\n      return i.getFloat32(o, !0);\n    case H.onnx.TensorProto.DataType.INT32:\n      return i.getInt32(o, !0);\n    case H.onnx.TensorProto.DataType.UINT32:\n      return i.getUint32(o, !0);\n    case H.onnx.TensorProto.DataType.INT64:\n      return ui(xe.fromBits(i.getUint32(o, !0), i.getUint32(o + 4, !0), !1), e);\n    case H.onnx.TensorProto.DataType.DOUBLE:\n      return i.getFloat64(o, !0);\n    case H.onnx.TensorProto.DataType.UINT64:\n      return ui(xe.fromBits(i.getUint32(o, !0), i.getUint32(o + 4, !0), !0), e);\n    default:\n      throw new Error(`cannot read from DataView for type ${H.onnx.TensorProto.DataType[e]}`);\n  }\n}\nvar qu,\n  H,\n  si,\n  bt,\n  We = O(() => {\n    \"use strict\";\n\n    qu = rr(Fs());\n    qo();\n    Pr();\n    H = rr(sr());\n    Y();\n    si = F.experimental.fbs, bt = class i {\n      constructor(e, o, t, r, n, s = qu.Guid.create()) {\n        this.dims = e;\n        this.type = o;\n        this.dataProvider = t;\n        this.asyncDataProvider = r;\n        this.cache = n;\n        this.dataId = s;\n        this.size = B.validateDimsAndCalcSize(e);\n        let a = this.size,\n          u = t === void 0 && r === void 0 && n === void 0;\n        if (n !== void 0 && n.length !== a) throw new RangeError(\"Input dims doesn't match data length.\");\n        if (o === \"string\") {\n          if (n !== void 0 && (!Array.isArray(n) || !n.every(l => typeof l == \"string\"))) throw new TypeError(\"cache should be a string array\");\n          u && (this.cache = new Array(a));\n        } else {\n          if (n !== void 0) {\n            let l = ju(o);\n            if (!(n instanceof l)) throw new TypeError(`cache should be type ${l.name}`);\n          }\n          if (u) {\n            let l = new ArrayBuffer(a * hh(o));\n            this.cache = mh(l, o);\n          }\n        }\n      }\n      get data() {\n        if (this.cache === void 0) {\n          let e = this.dataProvider(this.dataId);\n          if (e.length !== this.size) throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");\n          this.cache = e;\n        }\n        return this.cache;\n      }\n      get stringData() {\n        if (this.type !== \"string\") throw new TypeError(\"data type is not string\");\n        return this.data;\n      }\n      get integerData() {\n        switch (this.type) {\n          case \"uint8\":\n          case \"int8\":\n          case \"uint16\":\n          case \"int16\":\n          case \"int32\":\n          case \"uint32\":\n          case \"bool\":\n            return this.data;\n          default:\n            throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\");\n        }\n      }\n      get floatData() {\n        switch (this.type) {\n          case \"float32\":\n          case \"float64\":\n            return this.data;\n          default:\n            throw new TypeError(\"data type is not float (float32, float64)\");\n        }\n      }\n      get numberData() {\n        if (this.type !== \"string\") return this.data;\n        throw new TypeError(\"type cannot be non-number (string)\");\n      }\n      get(e) {\n        return this.data[B.indicesToOffset(e, this.strides)];\n      }\n      set(e, o) {\n        this.data[B.indicesToOffset(e, this.strides)] = o;\n      }\n      getData() {\n        var _this14 = this;\n        return _asyncToGenerator(function* () {\n          return _this14.cache === void 0 && (_this14.cache = yield _this14.asyncDataProvider(_this14.dataId)), _this14.cache;\n        })();\n      }\n      get strides() {\n        return this._strides || (this._strides = B.computeStrides(this.dims)), this._strides;\n      }\n      static fromProto(e) {\n        if (!e) throw new Error(\"cannot construct Value from an empty tensor\");\n        let o = At.tensorDataTypeFromProto(e.dataType),\n          t = At.tensorDimsFromProto(e.dims),\n          r = new i(t, o);\n        if (o === \"string\") e.stringData.forEach((n, s) => {\n          r.data[s] = kr(n);\n        });else if (e.rawData && typeof e.rawData.byteLength == \"number\" && e.rawData.byteLength > 0) {\n          let n = r.data,\n            s = new DataView(e.rawData.buffer, e.rawData.byteOffset, e.rawData.byteLength),\n            a = Wu(e.dataType),\n            u = e.rawData.byteLength / a;\n          if (e.rawData.byteLength % a !== 0) throw new Error(\"invalid buffer length\");\n          if (n.length !== u) throw new Error(\"buffer length mismatch\");\n          for (let l = 0; l < u; l++) {\n            let f = Hu(s, e.dataType, l * a);\n            n[l] = f;\n          }\n        } else {\n          let n;\n          switch (e.dataType) {\n            case H.onnx.TensorProto.DataType.FLOAT:\n              n = e.floatData;\n              break;\n            case H.onnx.TensorProto.DataType.INT32:\n            case H.onnx.TensorProto.DataType.INT16:\n            case H.onnx.TensorProto.DataType.UINT16:\n            case H.onnx.TensorProto.DataType.INT8:\n            case H.onnx.TensorProto.DataType.UINT8:\n            case H.onnx.TensorProto.DataType.BOOL:\n              n = e.int32Data;\n              break;\n            case H.onnx.TensorProto.DataType.INT64:\n              n = e.int64Data;\n              break;\n            case H.onnx.TensorProto.DataType.DOUBLE:\n              n = e.doubleData;\n              break;\n            case H.onnx.TensorProto.DataType.UINT32:\n            case H.onnx.TensorProto.DataType.UINT64:\n              n = e.uint64Data;\n              break;\n            default:\n              throw new Error(\"unspecific error\");\n          }\n          if (n == null) throw new Error(\"failed to populate data from a tensorproto value\");\n          let s = r.data;\n          if (s.length !== n.length) throw new Error(\"array length mismatch\");\n          for (let a = 0; a < n.length; a++) {\n            let u = n[a];\n            xe.isLong(u) ? s[a] = ui(u, e.dataType) : s[a] = u;\n          }\n        }\n        return r;\n      }\n      static fromData(e, o, t) {\n        return new i(o, t, void 0, void 0, e);\n      }\n      static fromOrtTensor(e) {\n        if (!e) throw new Error(\"cannot construct Value from an empty tensor\");\n        let o = At.tensorDimsFromORTFormat(e),\n          t = At.tensorDataTypeFromProto(e.dataType()),\n          r = new i(o, t);\n        if (t === \"string\") for (let n = 0; n < e.stringDataLength(); n++) r.data[n] = e.stringData(n);else if (e.rawDataArray() && typeof e.rawDataLength() == \"number\" && e.rawDataLength() > 0) {\n          let n = r.data,\n            s = new DataView(e.rawDataArray().buffer, e.rawDataArray().byteOffset, e.rawDataLength()),\n            a = Wu(e.dataType()),\n            u = e.rawDataLength() / a;\n          if (e.rawDataLength() % a !== 0) throw new Error(\"invalid buffer length\");\n          if (n.length !== u) throw new Error(\"buffer length mismatch\");\n          for (let l = 0; l < u; l++) {\n            let f = Hu(s, e.dataType(), l * a);\n            n[l] = f;\n          }\n        }\n        return r;\n      }\n    };\n  });\nfunction G(i) {\n  return i === 1 ? bh : gh;\n}\nfunction Xu(i) {\n  let e = G(i);\n  return `${e.version}\n      precision highp float;\n      ${e.attribute} vec3 position;\n      ${e.attribute} vec2 textureCoord;\n\n      ${e.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;\n}\nfunction Ku(i) {\n  let e = G(i);\n  return `${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFrag} vec2 TexCoords;\n    ${e.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;\n}\nfunction Ju(i, e) {\n  let o = G(i);\n  return `\n  void main() {\n    int indices[${e}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${o.output} = result;\n  }\n  `;\n}\nvar bh,\n  gh,\n  ut = O(() => {\n    \"use strict\";\n\n    bh = {\n      version: \"\",\n      attribute: \"attribute\",\n      varyingVertex: \"varying\",\n      varyingFrag: \"varying\",\n      texture2D: \"texture2D\",\n      output: \"gl_FragColor\",\n      outputDeclaration: \"\"\n    }, gh = {\n      version: \"#version 300 es\",\n      attribute: \"in\",\n      varyingVertex: \"out\",\n      varyingFrag: \"in\",\n      texture2D: \"texture\",\n      output: \"outputColor\",\n      outputDeclaration: \"out vec4 outputColor;\"\n    };\n  });\nvar j = O(() => {\n  \"use strict\";\n});\nfunction li(_x9) {\n  return _li.apply(this, arguments);\n}\nfunction _li() {\n  _li = _asyncToGenerator(function* (i, e = t => 0, o) {\n    return new Promise((t, r) => {\n      let n = 0,\n        s = () => {\n          if (i()) {\n            t();\n            return;\n          }\n          n++;\n          let a = e(n);\n          if (o != null && n >= o) {\n            r();\n            return;\n          }\n          setTimeout(s, a);\n        };\n      s();\n    });\n  });\n  return _li.apply(this, arguments);\n}\nfunction An(i) {\n  return ur(typeof i < \"u\" && i.length !== 0, () => \"empty string found for sampler name\"), \"get\" + i.charAt(0).toUpperCase() + i.slice(1);\n}\nfunction Yu(i) {\n  return ur(typeof i < \"u\" && i.length !== 0, () => \"empty string found for sampler name\"), \"get\" + i.charAt(0).toUpperCase() + i.slice(1) + \"AtOutCoords\";\n}\nfunction lr(i, e) {\n  let o = JSON.parse(JSON.stringify(i));\n  return o = e, o;\n}\nfunction fr(i, e) {\n  return e.map(o => i[o]).join(\", \");\n}\nfunction Bt(i) {\n  if (i <= 1) return \"int\";\n  if (i === 2) return \"ivec2\";\n  if (i === 3) return \"ivec3\";\n  if (i === 4) return \"ivec4\";\n  if (i === 5) return \"ivec5\";\n  if (i === 6) return \"ivec6\";\n  throw Error(`GPU for rank ${i} is not yet supported`);\n}\nfunction ne(i = 6) {\n  return [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, i);\n}\nvar pe = O(() => {\n  \"use strict\";\n\n  Y();\n});\nfunction yh(i, e) {\n  return ne(e).map(o => `${i}.${o}`);\n}\nfunction cr(i, e) {\n  return e === 1 ? [i] : yh(i, e);\n}\nfunction de() {\n  return `\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `;\n}\nvar He = O(() => {\n  \"use strict\";\n\n  pe();\n});\nfunction Th(i, e, o) {\n  if (i === 0) return \"false\";\n  if (i === 1) return `rc > ${e[0]}`;\n  let t = \"\";\n  for (let r = i - 2; r < i; r++) t += `${o[r]} >= ${e[r - i + 2]}`, r < i - 1 && (t += \"||\");\n  return t;\n}\nfunction wh(i, e) {\n  let o = i.length;\n  if (o === 0) return \"getA(), 0, 0, 0\";\n  if (o === 1) return `getA(rc),\n            rc + 1 >= ${i[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  let t = \"r, c\",\n    r = \"r, cp1\",\n    n = \"rp1, c\",\n    s = \"rp1, cp1\",\n    a = \"\";\n  if (o > 2) for (let u = 0; u < o - 2; ++u) a = a + `${e[u]},`;\n  return `getA(${a}${t}),\n          rEdge ? 0. : getA(${a}${n}),\n          cEdge ? 0. : getA(${a}${r}),\n          rEdge || cEdge ? 0. : getA(${a}${s})`;\n}\nfunction vh(i, e, o, t) {\n  return i === 0 || i === 1 ? \"\" : `\n    int r = ${e[i - 2]};\n    int c = ${e[i - 1]};\n    int rp1 = ${e[i - 2]} + 1;\n    int cp1 = ${e[i - 1]} + 1;\n    bool rEdge = rp1 >= ${t};\n    bool cEdge = cp1 >= ${o};\n    `;\n}\nvar Zu,\n  xh,\n  Qu,\n  tl = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    Zu = {\n      name: \"pack\",\n      inputNames: [\"A\"],\n      inputTypes: [1]\n    }, xh = (i, e) => {\n      let o = G(i.session.backend.glContext.version),\n        t = e.dims,\n        r = t.length,\n        n = e.dims.length,\n        s = Bt(n),\n        a = cr(\"rc\", n),\n        u = vh(n, a, t[t.length - 2], t[t.length - 1]),\n        l;\n      r === 0 ? l = [1, 1] : r === 1 ? l = [t[0], 1] : l = [t[n - 1], t[n - 2]];\n      let f = Th(n, l, a),\n        p = wh(t, a),\n        d = `\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${f}) {\n            ${o.output} = vec4(0);\n          } else {\n            ${u}\n\n            ${o.output} = vec4(${p});\n          }\n        }\n      `;\n      return {\n        ...Zu,\n        hasMain: !0,\n        output: {\n          dims: e.dims,\n          type: e.type,\n          textureType: 2\n        },\n        shaderSource: d\n      };\n    }, Qu = (i, e) => ({\n      ...Zu,\n      get: () => xh(i, e)\n    });\n  });\nfunction fi(i) {\n  if (i.length === 0) return [1, 1, 1];\n  let e = 1;\n  for (let o = 0; o < i.length - 2; ++o) e *= i[o];\n  return [e, i.length > 1 ? i[i.length - 2] : 1, i[i.length - 1]];\n}\nfunction rl(i, e) {\n  let o = !1;\n  return i.length === 0 || e.length === 0 ? o = !0 : i.length < 2 || e.length < 2 ? o = i[i.length - 1] === e[e.length - 1] : o = i[i.length - 1] === e[e.length - 1] && i[i.length - 2] === e[e.length - 2], o;\n}\nfunction Oh(i) {\n  let e = B.computeStrides(i),\n    o = [\"b\", \"r\", \"c\"],\n    t = \"index\";\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e.map((n, s) => {\n    let a = `int ${o[s]} = ${t} / ${n}`,\n      u = s === e.length - 1 ? `int ${o[s + 1]} = ${t} - ${o[s]} * ${n}` : `index -= ${o[s]} * ${n}`;\n    return `${a}; ${u};`;\n  }).join(\"\")}\n      return ivec3(b, r, c);\n    }\n  `;\n}\nfunction Sh(i) {\n  let e = B.computeStrides(i);\n  return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\n  }\n`;\n}\nvar Ih,\n  _h,\n  el,\n  nl = O(() => {\n    \"use strict\";\n\n    Y();\n    ut();\n    j();\n    He();\n    Ih = i => ({\n      name: \"Reshape (packed)\",\n      inputTypes: [2],\n      inputNames: [\"A\"],\n      cacheHint: `${i}`\n    }), _h = (i, e, o, t) => {\n      let r = e.dims,\n        n = t,\n        s = \"\";\n      for (let l = 0; l < 4; l++) {\n        let f = \"\";\n        switch (l) {\n          case 0:\n            f = \"outputCoords = rc;\";\n            break;\n          case 1:\n            f = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";\n            break;\n          case 2:\n            f = \"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";\n            break;\n          case 3:\n            f = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";\n            break;\n          default:\n            throw new Error();\n        }\n        s += `\n        ${f}\n        ${l > 0 ? \"if(outputCoords.y < rows && outputCoords.z < cols){\" : \"\"}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${l > 0 ? \"}\" : \"\"}\n      `;\n      }\n      let a = G(i.session.backend.glContext.version),\n        u = `\n      ${Oh(r)}\n      ${Sh(n)}\n      ${de()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${n[2]};\n        int cols = ${n[1]};\n\n        ${s}\n        ${a.output} = result;\n      }\n    `;\n      return {\n        ...o,\n        output: {\n          dims: n,\n          type: e.type,\n          textureType: 2\n        },\n        shaderSource: u,\n        hasMain: !0\n      };\n    }, el = (i, e, o) => {\n      let t = Ih(o);\n      return {\n        ...t,\n        get: () => _h(i, e, t, o)\n      };\n    };\n  });\nvar ci,\n  ol = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    ci = (i, e) => {\n      let o = e.shape,\n        t = G(i.session.backend.glContext.version),\n        r = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${t.texture2D}(X,TexCoords).r;\n      ${t.output} = encodeAsUint8(value);\n    }`,\n        n = {\n          name: \"Uint8Encode\",\n          inputTypes: [0],\n          inputNames: [\"X\"],\n          output: {\n            dims: o,\n            type: e.tensor.type,\n            textureType: 3\n          },\n          shaderSource: r,\n          hasMain: !0\n        };\n      return i.executeProgram(n, [e.tensor]);\n    };\n  });\nfunction Ph(i, e) {\n  if (i === 1) return \"rc\";\n  let o = \"\";\n  for (let t = 0; t < i; t++) o += e[t], t < i - 1 && (o += \",\");\n  return o;\n}\nvar il,\n  Ah,\n  al,\n  sl = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    il = {\n      name: \"unpack\",\n      inputNames: [\"A\"],\n      inputTypes: [2]\n    }, Ah = (i, e) => {\n      let o = e.dims.length,\n        t = cr(\"rc\", o),\n        r = t.slice(-2),\n        n = Bt(o),\n        s = de(),\n        u = e.dims.length === 0 ? \"\" : Ph(o, t),\n        l = o <= 1 ? \"rc\" : `vec2(${r.join(\",\")})`,\n        f = G(i.session.backend.glContext.version),\n        p = `\n    ${s}\n    void main() {\n      ${n} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${u});\n\n       ${f.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);\n     }\n   `;\n      return {\n        ...il,\n        hasMain: !0,\n        output: {\n          dims: e.dims,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: p\n      };\n    }, al = (i, e) => ({\n      ...il,\n      get: () => Ah(i, e)\n    });\n  });\nvar Pn,\n  Br,\n  En,\n  Fr = O(() => {\n    \"use strict\";\n\n    Ut();\n    Pn = class {\n      constructor(e, o = 1) {\n        if (o === 1) this.internalFormat = e.R32F, this.format = e.RED, this.textureType = e.FLOAT, this.channelSize = o;else if (o === 4) this.internalFormat = e.RGBA32F, this.format = e.RGBA, this.textureType = e.FLOAT, this.channelSize = o;else throw new Error(`Invalid number of channels: ${o}`);\n      }\n      encode(e, o) {\n        let t, r;\n        return e.constructor !== Float32Array && (tt.warning(\"Encoder\", \"data was not of type Float32; creating new Float32Array\"), r = new Float32Array(e)), o * this.channelSize > e.length ? (tt.warning(\"Encoder\", \"Source data too small. Allocating larger array\"), r = e, t = this.allocate(o * this.channelSize), r.forEach((n, s) => t[s] = n)) : (r = e, t = r), t;\n      }\n      allocate(e) {\n        return new Float32Array(e * 4);\n      }\n      decode(e, o) {\n        return this.channelSize === 1 ? e.filter((r, n) => n % 4 === 0).subarray(0, o) : e.subarray(0, o);\n      }\n    }, Br = class {\n      constructor(e, o = 1, t) {\n        if (o !== 1 && o !== 4) throw new Error(`Invalid number of channels: ${o}`);\n        this.internalFormat = e.RGBA, this.format = e.RGBA, this.channelSize = o, this.textureType = t || e.FLOAT;\n      }\n      encode(e, o) {\n        let t = e;\n        return this.channelSize === 1 && (tt.verbose(\"Encoder\", \"Exploding into a larger array\"), t = this.allocate(o), e.forEach((r, n) => t[n * 4] = r)), t;\n      }\n      allocate(e) {\n        return new Float32Array(e * 4);\n      }\n      decode(e, o) {\n        return this.channelSize === 1 ? e.filter((r, n) => n % 4 === 0).subarray(0, o) : e.subarray(0, o);\n      }\n    }, En = class {\n      constructor(e, o = 1) {\n        this.channelSize = 4;\n        if (o === 1) this.internalFormat = e.ALPHA, this.format = e.ALPHA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = o;else if (o === 4) this.internalFormat = e.RGBA, this.format = e.RGBA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = o;else throw new Error(`Invalid number of channels: ${o}`);\n      }\n      encode(e, o) {\n        return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n      }\n      allocate(e) {\n        return new Uint8Array(e * this.channelSize);\n      }\n      decode(e, o) {\n        if (e instanceof Uint8Array) return e.subarray(0, o);\n        throw new Error(`Invalid array type: ${e.constructor}`);\n      }\n    };\n  });\nvar Cr,\n  ul,\n  pi,\n  ll = O(() => {\n    \"use strict\";\n\n    Y();\n    j();\n    Cr = (i, e, o) => {\n      let t = o === 0 || o === 1 ? 1 : 4,\n        r = o === 2,\n        n = o === 1 || o === 2,\n        s = o === 4 ? e.length - 1 : void 0,\n        a = o === 4 ? e.map((u, l) => l === e.length - 1 ? u * 4 : u) : void 0;\n      return pi(i, e, t, a, {\n        isPacked: r,\n        reverseWH: n,\n        breakAxis: s\n      });\n    }, ul = (i, e, o) => {\n      let t = Cr(i, e, o);\n      return [t.width, t.height];\n    }, pi = (i, e, o = 1, t, r) => {\n      let n = !!(r && r.isPacked),\n        [s, a] = i.computeTextureWH(n && t || e, r),\n        u = e.length,\n        l = e.slice(0);\n      if (u === 0 && (l = [1]), o === 1) t = e;else if (n) {\n        if (o !== 4) throw new Error(\"a packed texture must be 4-channel\");\n        t = e, u > 0 && (l[u - 1] = Math.ceil(l[u - 1] / 2)), u > 1 && (l[u - 2] = Math.ceil(l[u - 2] / 2));\n      } else if (!t) throw new Error(\"Unpacked shape is needed when using channels > 1\");\n      return {\n        width: s,\n        height: a,\n        channels: o,\n        isPacked: n,\n        shape: l,\n        strides: B.computeStrides(l),\n        unpackedShape: t,\n        reversedWH: r && r.reverseWH\n      };\n    };\n  });\nvar Dh,\n  Dn,\n  cl = O(() => {\n    \"use strict\";\n\n    Ut();\n    We();\n    Y();\n    tl();\n    nl();\n    ol();\n    sl();\n    Fr();\n    ll();\n    j();\n    Dh = (i, e) => {\n      let o = e.map(r => `${r.unpackedShape.join(\",\")};${r.width}x${r.height}`).join(\"_\"),\n        t = i.name;\n      return i.cacheHint && (t += \"[\" + i.cacheHint + \"]\"), t += \":\" + o, t;\n    }, Dn = class {\n      constructor(e) {\n        this.session = e;\n        this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map();\n      }\n      calculateTextureWidthAndHeight(e, o) {\n        return ul(this.session.layoutStrategy, e, o);\n      }\n      executeProgram(e, o) {\n        if (o.length < e.inputNames.length) throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);\n        if (e.inputNames.length !== e.inputTypes.length) throw new Error(\"input names size does not match input types\");\n        let t = [];\n        for (let l = 0; l < e.inputNames.length; ++l) t[l] = this.getOrCreateTextureData(o[l], e.inputTypes[l]);\n        let r = Dh(e, t),\n          n = this.session.programManager.getArtifact(r),\n          s = n ? n.programInfo : typeof e.get == \"function\" ? e.get() : e,\n          a = Cr(this.session.layoutStrategy, s.output.dims, s.output.textureType),\n          u = this.createTextureData(a, s.output.type);\n        return n || (n = this.session.programManager.build(s, t, u), this.session.programManager.setArtifact(r, n)), this.runProgram(n, t, u), u;\n      }\n      run(e, o) {\n        return this.executeProgram(e, o).tensor;\n      }\n      runProgram(e, o, t) {\n        for (let r = 0; r < o.length; ++r) if (!!o[r].isPacked != (e.programInfo.inputTypes[r] === 2)) throw new Error(`input[${r}] property packed inconsistent`);\n        if (!!t.isPacked != (e.programInfo.output.textureType === 2)) throw new Error(\"output property packed inconsistent\");\n        this.session.programManager.run(e, o, t);\n      }\n      getOrCreateTextureData(e, o) {\n        let t = this.getTextureData(e.dataId, o === 2);\n        if (!t && (t = this.getTextureData(e.dataId, o !== 2), t)) return o === 2 ? this.pack(t) : this.unpack(t);\n        if (!t) {\n          let r = Cr(this.session.layoutStrategy, e.dims, o);\n          if (o === 4) {\n            let a = e.dims;\n            if (a.length === 4) {\n              let u = [a[0], Math.ceil(a[1] * a[2] * a[3] / 4)],\n                l = Cr(this.session.layoutStrategy, u, o),\n                f = e.numberData;\n              if (a[1] * a[2] * a[3] % 4 !== 0) {\n                let p = a[0],\n                  d = a[1] * a[2] * a[3],\n                  y = Math.ceil(d * 1 / 4) * 4,\n                  T = p * y;\n                f = new Float32Array(T);\n                for (let v = 0; v < p; ++v) {\n                  let S = v * d,\n                    L = v * y + v % 1 * d;\n                  f.set(e.numberData.subarray(S, S + d), L);\n                }\n              }\n              return this.createTextureData(l, e.type, f, e, 1);\n            }\n          }\n          if (o === 2) {\n            let n = pi(this.session.layoutStrategy, e.dims, 1, [], {\n                reverseWH: !0\n              }),\n              s = this.createTextureData(n, e.type, e.numberData, e, 1);\n            t = this.pack(s);\n          } else t = this.createTextureData(r, e.type, e.numberData, e, 1);\n        }\n        return t;\n      }\n      createTextureDataFromLayoutBindTensor(e, o, t, r) {\n        return this.createTextureData(e, o, t, r, 1);\n      }\n      createTextureData(e, o, t, r, n) {\n        tt.verbose(\"InferenceHandler\", `Creating TextureData: layout:[${JSON.stringify(e)}]`);\n        let s = this.session.textureManager.createTextureFromLayout(o, e, t, n);\n        return this.createTextureDataFromTexture(e, o, s, r);\n      }\n      reshapeUnpacked(e, o) {\n        let t = this.getOrCreateTextureData(e, 0),\n          r = {\n            channels: t.channels,\n            height: t.height,\n            width: t.width,\n            shape: o.length !== 0 ? o : [1],\n            strides: B.computeStrides(o),\n            unpackedShape: o\n          };\n        return this.createTextureDataFromTexture(r, e.type, t.texture).tensor;\n      }\n      reshapePacked(e, o) {\n        let t = this.getOrCreateTextureData(e, 2);\n        if (rl(e.dims, o)) {\n          let l = {\n            channels: t.channels,\n            height: t.height,\n            width: t.width,\n            shape: o.length !== 0 ? o : [1],\n            strides: B.computeStrides(o),\n            unpackedShape: o,\n            isPacked: !0\n          };\n          return this.createTextureDataFromTexture(l, e.type, t.texture).tensor;\n        }\n        let r = fi(e.dims),\n          n = fi(o),\n          s = this.reshapePacked(e, r),\n          a = this.run(el(this, s, n), [s]);\n        return this.reshapePacked(a, o);\n      }\n      cast(e, o) {\n        let t = this.getOrCreateTextureData(e, 0);\n        return this.createTextureDataFromTexture(t, o, t.texture).tensor;\n      }\n      createTextureDataFromTexture(e, o, t, r, n) {\n        var _this15 = this;\n        let s = {\n          ...e,\n          tensor: r || new bt(e.unpackedShape, o, a => this.readTexture(s), /*#__PURE__*/function () {\n            var _ref7 = _asyncToGenerator(function* (a) {\n              return _this15.readTextureAsync(s);\n            });\n            return function (_x0) {\n              return _ref7.apply(this, arguments);\n            };\n          }(), void 0, n),\n          texture: t\n        };\n        return this.setTextureData(s.tensor.dataId, s, e.isPacked), s;\n      }\n      getTextureData(e, o = !1) {\n        return this.session.isInitializer(e) ? this.session.getTextureData(e, o) : o ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);\n      }\n      setTextureData(e, o, t = !1) {\n        this.session.isInitializer(e) ? this.session.setTextureData(e, o, t) : (t ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e, o);\n      }\n      isTextureLayoutCached(e, o = !1) {\n        return !!this.getTextureData(e.dataId, o);\n      }\n      dispose() {\n        this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(e => this.session.textureManager.releaseTexture(e)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(e => this.session.textureManager.releaseTexture(e)), this.unpackedTextureDataCache = new Map();\n      }\n      readTexture(e) {\n        return e.isPacked ? this.readTexture(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat(ci(this, e));\n      }\n      readTextureAsync(e) {\n        var _this16 = this;\n        return _asyncToGenerator(function* () {\n          return e.isPacked ? _this16.readTextureAsync(_this16.unpack(e)) : _this16.session.backend.glContext.isFloat32DownloadSupported ? _this16.session.textureManager.readTextureAsync(e, e.tensor.type, e.channels) : _this16.session.textureManager.readUint8TextureAsFloat(ci(_this16, e));\n        })();\n      }\n      pack(e) {\n        return this.executeProgram(Qu(this, e.tensor), [e.tensor]);\n      }\n      unpack(e) {\n        return this.executeProgram(al(this, e.tensor), [e.tensor]);\n      }\n    };\n  });\nvar di,\n  W,\n  It = O(() => {\n    \"use strict\";\n\n    di = class {\n      constructor(e) {\n        Object.assign(this, e);\n      }\n      get cacheKey() {\n        return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map(e => `${this[e]}`).join(\";\")), this.key;\n      }\n    }, W = i => new di(i);\n  });\nvar pl,\n  dl,\n  hl,\n  Lh,\n  $h,\n  ml = O(() => {\n    \"use strict\";\n\n    It();\n    ut();\n    j();\n    pl = {\n      name: \"BatchNormalization\",\n      inputNames: [\"A\", \"Scale\", \"B\", \"Mean\", \"Variance\"],\n      inputTypes: [0, 0, 0, 0, 0]\n    }, dl = (i, e, o) => ($h(e), [i.run({\n      ...pl,\n      cacheHint: o.cacheKey,\n      get: () => Lh(i, e, o)\n    }, e)]), hl = i => {\n      let e = i.attributes.getFloat(\"epsilon\", 1e-5),\n        o = i.attributes.getFloat(\"momentum\", .9),\n        t = i.attributes.getInt(\"spatial\", 1);\n      return W({\n        epsilon: e,\n        momentum: o,\n        spatial: t\n      });\n    }, Lh = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        r = e[0].dims.length,\n        [n, s] = i.calculateTextureWidthAndHeight(e[1].dims, 0),\n        a = `\n  float process(int[${r}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${n}, ${s});\n    float scale = getColorAsFloat(${t.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${t.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${t.texture2D}(Variance, position));\n    float b = getColorAsFloat(${t.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;\n  }`;\n      return {\n        ...pl,\n        output: {\n          dims: e[0].dims,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: a\n      };\n    }, $h = i => {\n      if (!i || i.length !== 5) throw new Error(\"BatchNormalization requires 5 inputs.\");\n      let e = i[0],\n        o = i[1],\n        t = i[2],\n        r = i[3],\n        n = i[4];\n      if (e.dims.length < 3 || o.dims.length !== 1 || t.dims.length !== 1 || r.dims.length !== 1 || n.dims.length !== 1) throw new Error(\"invalid input shape.\");\n      if (o.dims[0] !== e.dims[1] || t.dims[0] !== e.dims[1] || r.dims[0] !== e.dims[1] || n.dims[0] !== e.dims[1]) throw new Error(\"invalid input shape.\");\n      if (e.type !== \"float32\" && e.type !== \"float64\" || o.type !== \"float32\" && o.type !== \"float64\" || t.type !== \"float32\" && t.type !== \"float64\" || r.type !== \"float32\" && r.type !== \"float64\" || n.type !== \"float32\" && n.type !== \"float64\") throw new Error(\"invalid input tensor types.\");\n    };\n  });\nvar Ln,\n  Ht,\n  k,\n  Nr,\n  $n,\n  Te = O(() => {\n    \"use strict\";\n\n    Ln = class {\n      constructor(e, o, t, r) {\n        this.glContext = e;\n        this.programInfo = o;\n        this.inputTextureLayouts = t;\n        this.outputTextureLayout = r;\n      }\n    }, Ht = class {\n      constructor(e) {\n        this.context = e;\n      }\n    }, k = class {\n      constructor(e, o) {\n        this.routineBody = e;\n        this.dependencies = o;\n      }\n    }, Nr = class {\n      constructor(e, o, t) {\n        this.name = e;\n        t ? this.dependencies = t : this.dependencies = [], o && (this.routineBody = o);\n      }\n      addDependency(e) {\n        e && this.dependencies.push(e);\n      }\n    }, $n = class {\n      static returnOrderedNodes(e) {\n        if (!e || e.length === 0) return [];\n        if (e.length === 1) return e;\n        let o = new Set(),\n          t = new Set(),\n          r = new Array();\n        return this.createOrderedNodes(e, o, t, r), r;\n      }\n      static createOrderedNodes(e, o, t, r) {\n        for (let n = 0; n < e.length; ++n) this.dfsTraverse(e[n], o, t, r);\n      }\n      static dfsTraverse(e, o, t, r) {\n        if (!e || t.has(e.name)) return;\n        if (o.has(e.name)) throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n        o.add(e.name);\n        let n = e.dependencies;\n        if (n && n.length > 0) for (let s = 0; s < n.length; ++s) this.dfsTraverse(n[s], o, t, r);\n        r.push(e), t.add(e.name), o.delete(e.name);\n      }\n    };\n  });\nfunction Bh() {\n  let i = \"add_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Fh() {\n  let i = \"div_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Ch() {\n  let i = \"mul_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Nh() {\n  let i = \"sub_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Rh() {\n  let i = \"equal_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Gh() {\n  let i = \"greater_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Mh() {\n  let i = \"less_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Uh() {\n  let i = \"and_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Vh() {\n  let i = \"or_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction zh() {\n  let i = \"xor_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Wh() {\n  return qh(\"pow\");\n}\nfunction Hh() {\n  let i = \"prelu_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction qh(i) {\n  let e = `${i}_`;\n  return {\n    body: `\n  float ${e}(float a, float b) {\n    return ${i}(a, b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return ${i}(v1, v2);\n  }\n  `,\n    name: e,\n    type: 0\n  };\n}\nvar qt,\n  jh,\n  bl,\n  gl,\n  yl,\n  xl,\n  Tl,\n  wl,\n  vl,\n  Il,\n  _l,\n  Ol,\n  Sl,\n  Al,\n  Pl = O(() => {\n    \"use strict\";\n\n    Y();\n    Te();\n    ut();\n    j();\n    qt = (i, e, o, t = e[0].type, r) => {\n      let n = i.session.pack ? 2 : 0;\n      return {\n        name: o.name,\n        inputNames: [\"A\", \"B\"],\n        inputTypes: [n, n],\n        cacheHint: r,\n        get: () => jh(i, e, o, t)\n      };\n    }, jh = (i, e, o, t = e[0].type) => {\n      let r = i.session.pack ? 2 : 0,\n        n = !B.areEqual(e[0].dims, e[1].dims),\n        s = e[0].dims,\n        a = i.session.pack;\n      if (n) {\n        let f = kt.calcShape(e[0].dims, e[1].dims, !1);\n        if (!f) throw new Error(\"Can't perform binary op on the given tensors\");\n        s = f;\n        let p = s.length,\n          d = e[0].dims.length !== 0 ? e[0].dims.length : 1,\n          y = e[1].dims.length !== 0 ? e[1].dims.length : 1,\n          T = e[0].dims.length !== 0 ? \"bcastIndices_A(indices, aindices);\" : \"aindices[0] = 0;\",\n          v = e[1].dims.length !== 0 ? \"bcastIndices_B(indices, bindices);\" : \"bindices[0] = 0;\",\n          S = G(i.session.backend.glContext.version),\n          L = a ? `\n      ${o.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${o.name}(a, b);\n        ${S.output} = result;\n      }` : `\n      ${o.body}\n      float process(int indices[${p}]) {\n        int aindices[${d}];\n        int bindices[${y}];\n        ${T}\n        ${v}\n        return ${o.name}(_A(aindices), _B(bindices));\n      }`;\n        return {\n          name: o.name,\n          inputNames: [\"A\", \"B\"],\n          inputTypes: [r, r],\n          output: {\n            dims: s,\n            type: t,\n            textureType: r\n          },\n          shaderSource: L,\n          hasMain: a\n        };\n      }\n      let u = G(i.session.backend.glContext.version),\n        l = `\n    ${o.body}\n    void main() {\n      vec4 v1 = ${u.texture2D}(A, TexCoords);\n      vec4 v2 = ${u.texture2D}(B, TexCoords);\n      vec4 result = ${o.name}(v1, v2);\n      ${u.output} = result;\n    }\n    `;\n      return {\n        name: o.name,\n        inputNames: [\"A\", \"B\"],\n        inputTypes: [r, r],\n        output: {\n          dims: e[0].dims,\n          type: t,\n          textureType: r\n        },\n        shaderSource: l,\n        hasMain: !0\n      };\n    }, bl = (i, e) => [i.run(qt(i, e, Bh()), e)], gl = (i, e) => [i.run(qt(i, e, Uh(), \"bool\"), e)], yl = (i, e) => [i.run(qt(i, e, Fh()), e)], xl = (i, e) => [i.run(qt(i, e, Rh(), \"bool\"), e)], Tl = (i, e) => [i.run(qt(i, e, Gh(), \"bool\"), e)], wl = (i, e) => [i.run(qt(i, e, Mh(), \"bool\"), e)], vl = (i, e) => [i.run(qt(i, e, Ch()), e)], Il = (i, e) => [i.run(qt(i, e, Vh(), \"bool\"), e)], _l = (i, e) => [i.run(qt(i, e, Wh()), e)], Ol = (i, e) => [i.run(qt(i, e, Hh()), e)], Sl = (i, e) => [i.run(qt(i, e, Nh()), e)], Al = (i, e) => [i.run(qt(i, e, zh(), \"bool\"), e)];\n  });\nvar El,\n  Dl,\n  Kh,\n  Ll = O(() => {\n    \"use strict\";\n\n    Y();\n    El = (i, e, o) => (Kh(e), [i.cast(e[0], o)]), Dl = i => At.tensorDataTypeFromProto(i.attributes.getInt(\"to\")), Kh = i => {\n      if (!i || i.length !== 1) throw new Error(\"Cast requires 1 input.\");\n      if (i[0].type === \"string\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Jh,\n  Yh,\n  $l,\n  kn,\n  kl = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    Jh = (i, e) => ({\n      name: \"Concat (packed)\",\n      inputNames: Array.from({\n        length: i\n      }, (o, t) => `X${t}`),\n      inputTypes: Array(i).fill(2),\n      cacheHint: e\n    }), Yh = (i, e, o, t) => {\n      let r = o[0].dims.slice();\n      if (t >= r.length || t < -1 * r.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n      t < 0 && (t = r.length + t);\n      let n = r.slice(0);\n      for (let V = 1; V < o.length; V++) {\n        let lt = o[V].dims.slice();\n        for (let wt = 0; wt < r.length; wt++) if (wt === t) n[t] += lt[wt];else if (r[wt] !== lt[wt]) throw new Error(\"non concat dimensions must match\");\n      }\n      let s = n.length,\n        a = cr(\"coords\", s),\n        u = Bt(s),\n        l = de(),\n        f = o.map(V => V.dims),\n        p = ne(s),\n        d = new Array(f.length - 1);\n      d[0] = f[0][t];\n      for (let V = 1; V < d.length; V++) d[V] = d[V - 1] + f[V][t];\n      let y = p[t],\n        T = p.slice(-2),\n        v = p.join(),\n        S = `if (${y} < ${d[0]}) {\n        return getChannel(\n            getX0(${v}), vec2(${T.join()}));\n        }`;\n      for (let V = 1; V < d.length; V++) {\n        let lt = d[V - 1];\n        S += `\n            if (${y} < ${d[V]}  && ${y} >= ${d[V - 1]}) {\n              return getChannel(\n                getX${V}(${kn(p, y, lt)}),\n                vec2(${kn(T, y, lt)}));\n            }`;\n      }\n      let L = d.length,\n        P = d[d.length - 1];\n      S += `\n            return getChannel(\n              getX${L}(${kn(p, y, P)}),\n              vec2(${kn(T, y, P)}));`;\n      let A = G(i.session.backend.glContext.version),\n        M = `\n          ${l}\n          float getValue(${p.map(V => \"int \" + V)}) {\n            ${S}\n          }\n\n          void main() {\n            ${u} coords = getOutputCoords();\n            int lastDim = coords.${p[s - 1]};\n            coords.${p[s - 1]} = coords.${p[s - 2]};\n            coords.${p[s - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n            ${a[s - 1]} = ${a[s - 1]} + 1;\n            if (${a[s - 1]} < ${n[s - 1]}) {\n              result.g = getValue(${a});\n            }\n\n            ${a[s - 2]} = ${a[s - 2]} + 1;\n            if (${a[s - 2]} < ${n[s - 2]}) {\n              result.a = getValue(${a});\n            }\n\n            ${a[s - 1]} = ${a[s - 1]} - 1;\n            if (${a[s - 2]} < ${n[s - 2]} &&\n                ${a[s - 1]} < ${n[s - 1]}) {\n              result.b = getValue(${a});\n            }\n            ${A.output} = result;\n          }\n        `;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: o[0].type,\n          textureType: 2\n        },\n        shaderSource: M,\n        hasMain: !0\n      };\n    }, $l = (i, e, o) => {\n      let t = Jh(e.length, o.cacheKey);\n      return {\n        ...t,\n        get: () => Yh(i, t, e, o.axis)\n      };\n    }, kn = (i, e, o) => {\n      let t = i.indexOf(e);\n      return i.map((n, s) => s === t ? `${n} - ${o}` : n).join();\n    };\n  });\nvar Bl,\n  Zh,\n  Qh,\n  tm,\n  Fl,\n  em,\n  rm,\n  nm,\n  Cl,\n  om,\n  Nl = O(() => {\n    \"use strict\";\n\n    It();\n    j();\n    kl();\n    Bl = (i, e, o) => (om(e), i.session.pack && e[0].dims.length > 1 ? [i.run($l(i, e, o), e)] : [i.run(tm(i, e, o), e)]), Zh = (i, e) => ({\n      name: \"Concat\",\n      inputNames: Array.from({\n        length: i\n      }, (o, t) => `X${t}`),\n      inputTypes: Array(i).fill(0),\n      cacheHint: e\n    }), Qh = (i, e, o, t) => {\n      let r = o[0].dims.slice();\n      if (t >= r.length || t < -1 * r.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n      t < 0 && (t = r.length + t);\n      let n = r.slice(0);\n      for (let y = 1; y < o.length; y++) {\n        let T = o[y].dims.slice();\n        for (let v = 0; v < r.length; v++) if (v === t) n[t] += T[v];else if (r[v] !== T[v]) throw new Error(\"non concat dimensions must match\");\n      }\n      let s = n.length,\n        a = new Array(o.length),\n        u = 0;\n      for (let y = 0; y < a.length; ++y) u += o[y].dims[t], a[y] = u;\n      let l = \"\";\n      o.length < 5 ? l = Fl(a) : l = em(a);\n      let f = rm(o.length, s),\n        p = nm(a),\n        d = `\n        ${f}\n        ${p}\n        ${l}\n        float process(int indices[${s}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${t}]);\n\n          if(textureIndex != 0) {\n            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: o[0].type,\n          textureType: 0\n        },\n        shaderSource: d\n      };\n    }, tm = (i, e, o) => {\n      let t = Zh(e.length, o.cacheKey);\n      return {\n        ...t,\n        get: () => Qh(i, t, e, o.axis)\n      };\n    }, Fl = i => `int getTextureWhereDataResides(int index) {\n      ${i.map((o, t) => `if(index<${o}) {return ${t};}\n`).join(\"\")}\n    }`, em = i => Fl(i), rm = (i, e) => {\n      let o = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];\n      for (let t = 0; t < i; ++t) t === 0 ? o.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`) : t === i - 1 ? o.push(`\telse { return _X${t}(indices); }`) : o.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);\n      return o.push(\"\t}\"), o.join(`\n`);\n    }, nm = i => {\n      let e = [\"int getSizeInConcatAxisValueFromIndex(int index) {\"];\n      for (let o = 0; o < i.length; ++o) o === 0 ? e.push(`\tif (index == ${o}) { return ${i[o]}; }`) : o === i.length - 1 ? e.push(`\telse { return ${i[o]}; }`) : e.push(`\telse if (index == ${o}) { return ${i[o]}; }`);\n      return e.push(\"\t}\"), e.join(`\n`);\n    }, Cl = i => W({\n      axis: i.attributes.getInt(\"axis\")\n    }), om = i => {\n      if (!i || i.length < 1) throw new Error(\"too few inputs\");\n      let e = i[0].type,\n        o = i[0].dims.length;\n      if (e === \"string\") throw new Error(\"string tensor is not supported yet\");\n      for (let t of i) {\n        if (t.type !== e) throw new Error(\"input tensors should be one type\");\n        if (t.dims.length !== o) throw new Error(\"input tensors should have the same shape\");\n      }\n    };\n  });\nfunction im() {\n  return jt(\"abs\");\n}\nfunction am() {\n  return jt(\"acos\");\n}\nfunction sm() {\n  return jt(\"asin\");\n}\nfunction um() {\n  return jt(\"atan\");\n}\nfunction lm() {\n  return jt(\"ceil\");\n}\nfunction fm() {\n  return jt(\"cos\");\n}\nfunction cm(i) {\n  let e = \"elu\";\n  return {\n    body: `\n  const float alpha = float(${i});\n\n  float ${e}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,\n    name: e,\n    type: 0\n  };\n}\nfunction pm() {\n  return jt(\"exp\");\n}\nfunction dm() {\n  return jt(\"floor\");\n}\nfunction hi(i, e) {\n  let o = \"clip\";\n  return {\n    body: `\n  const float min = float(${i});\n  const float max = float(${e});\n\n  float ${o}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${o}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,\n    name: o,\n    type: 0\n  };\n}\nfunction hm() {\n  let i = \"indentity\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return a;\n  }\n  vec4 ${i}_(vec4 v) {\n    return v;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction mm(i) {\n  let e = \"leakyRelu\";\n  return {\n    body: `\n  const float alpha = float(${i});\n\n  float ${e}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,\n    name: e,\n    type: 0\n  };\n}\nfunction bm() {\n  return jt(\"log\");\n}\nfunction gm() {\n  let i = \"neg\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return -a;\n  }\n  vec4 ${i}_(vec4 v) {\n    return -v;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction ym() {\n  let i = \"not\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${i}_(bool a) {\n    return !a;\n  }\n  vec4 ${i}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${i}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction xm() {\n  return jt(\"sin\");\n}\nfunction mi() {\n  let i = \"relu\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${i}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction bi() {\n  let i = \"sigmoid\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${i}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Tm() {\n  return jt(\"sqrt\");\n}\nfunction wm() {\n  return jt(\"tan\");\n}\nfunction vm() {\n  let i = \"tanh\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${i}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction jt(i) {\n  return {\n    body: `\n  float ${i}_(float a) {\n    return ${i}(a);\n  }\n  vec4 ${i}_(vec4 v) {\n    return ${i}(v);\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nvar Im,\n  dt,\n  Rl,\n  Gl,\n  Ml,\n  Ul,\n  gi,\n  Vl,\n  zl,\n  _m,\n  Wl,\n  Hl,\n  ql,\n  jl,\n  Xl,\n  Kl,\n  yi,\n  Jl,\n  Yl,\n  Zl,\n  Ql,\n  tf,\n  ef,\n  rf,\n  nf,\n  of,\n  af,\n  sf,\n  xi = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    Te();\n    ut();\n    j();\n    Im = (i, e, o, t) => {\n      let r = i.session.pack ? 2 : 0,\n        n = G(i.session.backend.glContext.version);\n      return {\n        ...e,\n        output: {\n          dims: o.dims,\n          type: o.type,\n          textureType: r\n        },\n        shaderSource: `\n     ${t.body}\n     void main() {\n       vec4 v = ${n.texture2D}(A, TexCoords);\n       v = ${t.name}_(v);\n       ${n.output} = v;\n     }\n     `,\n        hasMain: !0\n      };\n    }, dt = (i, e, o, t) => {\n      let r = i.session.pack ? 2 : 0,\n        n = {\n          name: o.name,\n          inputTypes: [r],\n          inputNames: [\"A\"],\n          cacheHint: t\n        };\n      return {\n        ...n,\n        get: () => Im(i, n, e, o)\n      };\n    }, Rl = (i, e) => [i.run(dt(i, e[0], im()), e)], Gl = (i, e) => [i.run(dt(i, e[0], am()), e)], Ml = (i, e) => [i.run(dt(i, e[0], sm()), e)], Ul = (i, e) => [i.run(dt(i, e[0], um()), e)], gi = (i, e, o) => [i.run(dt(i, e[0], hi(o.min, o.max), o.cacheKey), e)], Vl = i => W({\n      min: i.attributes.getFloat(\"min\", Ve),\n      max: i.attributes.getFloat(\"max\", ze)\n    }), zl = (i, e) => {\n      let o = _m(i, e);\n      return gi(i, [e[0]], o);\n    }, _m = (i, e) => {\n      if (e.length >= 3 && (!i.session.isInitializer(e[1].dataId) || !i.session.isInitializer(e[2].dataId))) throw new Error(\"dynamic clip attributes are not allowed\");\n      let o = e.length >= 3 ? e[1].numberData[0] : Ve,\n        t = e.length >= 3 ? e[2].numberData[0] : ze;\n      return W({\n        min: o,\n        max: t\n      });\n    }, Wl = (i, e) => [i.run(dt(i, e[0], lm()), e)], Hl = (i, e) => [i.run(dt(i, e[0], fm()), e)], ql = (i, e, o) => [i.run(dt(i, e[0], cm(o.alpha), o.cacheKey), e)], jl = i => W({\n      alpha: i.attributes.getFloat(\"alpha\", 1)\n    }), Xl = (i, e) => [i.run(dt(i, e[0], pm()), e)], Kl = (i, e) => [i.run(dt(i, e[0], dm()), e)], yi = (i, e) => [i.run(dt(i, e[0], hm()), e)], Jl = (i, e, o) => [i.run(dt(i, e[0], mm(o.alpha), o.cacheKey), e)], Yl = i => W({\n      alpha: i.attributes.getFloat(\"alpha\", .01)\n    }), Zl = (i, e) => [i.run(dt(i, e[0], bm()), e)], Ql = (i, e) => [i.run(dt(i, e[0], gm()), e)], tf = (i, e) => [i.run(dt(i, e[0], ym()), e)], ef = (i, e) => [i.run(dt(i, e[0], mi()), e)], rf = (i, e) => [i.run(dt(i, e[0], bi()), e)], nf = (i, e) => [i.run(dt(i, e[0], xm()), e)], of = (i, e) => [i.run(dt(i, e[0], Tm()), e)], af = (i, e) => [i.run(dt(i, e[0], wm()), e)], sf = (i, e) => [i.run(dt(i, e[0], vm()), e)];\n  });\nfunction he(i) {\n  let e;\n  switch (i.activation) {\n    case \"Relu\":\n      e = mi();\n      break;\n    case \"Sigmoid\":\n      e = bi();\n      break;\n    case \"Clip\":\n      e = hi(i.clipMin, i.clipMax);\n      break;\n    default:\n      return {\n        activationFunction: \"\",\n        applyActivation: \"\"\n      };\n  }\n  let o = e.name,\n    t = e.body,\n    r = `value = ${o}_(value);`;\n  return {\n    activationFunction: t,\n    applyActivation: r\n  };\n}\nvar pr,\n  qe = O(() => {\n    \"use strict\";\n\n    Y();\n    xi();\n    pr = i => {\n      let e = i.getString(\"activation\", \"\");\n      if (e === \"Clip\") {\n        let [o, t] = i.getFloats(\"activation_params\", [Ve, ze]);\n        return {\n          activation: e,\n          clipMax: t,\n          clipMin: o,\n          activationCacheKey: `${e}:${o},${t}`\n        };\n      }\n      return {\n        activation: e,\n        activationCacheKey: e\n      };\n    };\n  });\nvar Sm,\n  Am,\n  uf,\n  lf = O(() => {\n    \"use strict\";\n\n    Ut();\n    ut();\n    j();\n    Bn();\n    qe();\n    Sm = (i, e) => ({\n      name: \"GroupedConv\",\n      inputNames: i ? [\"X\", \"W\", \"Bias\"] : [\"X\", \"W\"],\n      inputTypes: i ? [0, 0, 0] : [0, 0],\n      cacheHint: e\n    }), Am = (i, e, o, t) => {\n      let n = e.length > 2 ? \"value += getBias(output_channel);\" : \"\",\n        s = e[0].dims.slice(),\n        a = e[1].dims.slice(),\n        u = a[0] / t.group;\n      tt.verbose(\"GroupedConv\", `autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);\n      let l = dr(s, a, t.dilations, t.pads, t.strides),\n        f = G(i.session.backend.glContext.version),\n        {\n          activationFunction: p,\n          applyActivation: d\n        } = he(t),\n        y = `\n  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});\n  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});\n  ${p}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${u};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {\n      int input_channel = group_id * ${a[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${s[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${s[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${d}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...o,\n        output: {\n          dims: l,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: y,\n        hasMain: !0\n      };\n    }, uf = (i, e, o) => {\n      let t = Sm(e.length > 2, o.cacheKey);\n      return {\n        ...t,\n        get: () => Am(i, e, t, o)\n      };\n    };\n  });\nvar Pm,\n  Em,\n  ff,\n  cf = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    He();\n    Pm = i => ({\n      name: \"Im2Col (packed)\",\n      inputNames: [\"A\"],\n      inputTypes: [2],\n      cacheHint: i\n    }), Em = (i, e, o, t, r, n) => {\n      let s = o.dims,\n        a = t.dims,\n        u = 2,\n        l = 3,\n        f = r.length,\n        p = [a[1] * a[2] * a[3], r[2] * r[3]],\n        d = a[2] * a[3],\n        y = de(),\n        T = G(i.session.backend.glContext.version),\n        v = \"\";\n      for (let L = 0; L <= 1; L++) for (let P = 0; P <= 1; P++) v += `\n            blockIndex = rc.x + ${P};\n            pos = rc.y + ${L};\n\n            if(blockIndex < ${p[1]} && pos < ${p[0]}) {\n              offsetY = int(blockIndex / (${r[f - 1]})) * ${n.strides[0]} -\n                ${n.pads[0]};\n              d0 = offsetY + ${n.dilations[0]} * (imod(pos, ${d}) / ${a[2]});\n\n              if(d0 < ${s[u]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${r[f - 1]}) * ${n.strides[1]} -\n                  ${n.pads[1]};\n                d1 = offsetX + ${n.dilations[1]} * imod(imod(pos, ${d}), ${a[2]});\n\n                if(d1 < ${s[l]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${d}.);\n                    innerDims = vec2(d0, d1);\n                    result[${L * 2 + P}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;\n      let S = `\n      ${y}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${v}\n          ${T.output} = result;\n      }\n            `;\n      return {\n        ...e,\n        output: {\n          dims: p,\n          type: o.type,\n          textureType: 2\n        },\n        shaderSource: S,\n        hasMain: !0\n      };\n    }, ff = (i, e, o, t, r) => {\n      let n = Pm(r.cacheKey);\n      return {\n        ...n,\n        get: () => Em(i, n, e, o, t, r)\n      };\n    };\n  });\nfunction Lm(i, e, o) {\n  let t = e[0].dims,\n    r = e[1].dims,\n    n = kt.calcShape(t, r, !0);\n  if (!n) throw new Error(\"Can't use matmul on the given tensors\");\n  let s = Bt(n.length),\n    a = ne(),\n    {\n      activationFunction: u,\n      applyActivation: l\n    } = he(o),\n    f = e.length > 2,\n    p = f ? \"value += getBiasForMatmul();\" : \"\",\n    d = f ? `${wi(s, a, e[2].dims, n, !1)}` : \"\",\n    y = n.length,\n    T = t.length,\n    v = r.length,\n    S = t[t.length - 1],\n    L = `\n    ${u}\n    ${d}\n    float process(int indices[${y}]) {\n        int a[${T}];\n        int b[${v}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${S}; ++k) {\n            a[${T - 1}] = k;\n            b[${v - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${p}\n        ${l}\n        return value;\n    }`;\n  return {\n    ...i,\n    output: {\n      dims: n,\n      type: e[0].type,\n      textureType: 0\n    },\n    shaderSource: L\n  };\n}\nfunction Ti(i, e) {\n  let o = Dm(i.length > 2, e.activationCacheKey);\n  return {\n    ...o,\n    get: () => Lm(o, i, e)\n  };\n}\nfunction wi(i, e, o, t, r) {\n  let n = \"\",\n    s = o.length,\n    a = t.length,\n    u = a - s;\n  a < 2 && s > 0 ? n = \"coords\" : n = o.map((v, S) => `coords.${e[S + u]}`).join(\", \");\n  let f = kt.getBroadcastDims(o, t).map(v => `coords.${e[v + u]} = 0;`).join(`\n`),\n    d = B.size(o) === 1,\n    y = \"vec4(outputValue.xx, outputValue.yy)\";\n  return d && (y = \"vec4(outputValue.x)\"), r ? `\nvec4 getBiasForMatmul() {\n  ${i} coords = getOutputCoords();\n  ${f}\n  vec4 outputValue = getBias(${n});\n  return ${y};\n}` : `\nfloat getBiasForMatmul() {\n  ${i} coords = getOutputCoords();\n  ${f}\n  return getBias(coords.x);\n}`;\n}\nvar pf,\n  df,\n  Dm,\n  $m,\n  Fn = O(() => {\n    \"use strict\";\n\n    Y();\n    j();\n    pe();\n    qe();\n    vi();\n    pf = (i, e, o) => ($m(e), i.session.pack ? [i.run(Cn(i, e, o), e)] : [i.run(Ti(e, o), e)]), df = i => pr(i.attributes), Dm = (i, e) => ({\n      name: \"MatMul\",\n      inputNames: i ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n      inputTypes: i ? [0, 0, 0] : [0, 0],\n      cacheHint: e\n    });\n    $m = i => {\n      if (!i || i.length !== 2) throw new Error(\"MatMul requires 2 inputs.\");\n      if (i[0].dims[i[0].dims.length - 1] !== i[1].dims[i[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\" || i[1].type !== \"float32\" && i[1].type !== \"float64\") throw new Error(\"inputs should be float type\");\n      if (i[0].type !== i[1].type) throw new Error(\"inputs types should match\");\n    };\n  });\nfunction Fm(i, e, o, t) {\n  let r = [],\n    n = [],\n    s = o[0].dims,\n    a = o[1].dims,\n    u = s.length,\n    l = a.length,\n    f = t.length,\n    p = f - u,\n    d = f - l;\n  r = s.map((A, M) => `coords.${e[M + p]}`), r[u - 1] = \"i*2\", r.join(\", \"), n = a.map((A, M) => `coords.${e[M + d]}`), n[l - 2] = \"i*2\", n.join(\", \");\n  let y = kt.getBroadcastDims(s, t),\n    T = kt.getBroadcastDims(a, t),\n    v = y.map(A => `coords.${e[A + p]} = 0;`).join(`\n`),\n    S = T.map(A => `coords.${e[A + d]} = 0;`).join(`\n`),\n    L = `int lastDim = coords.${e[f - 1]};\n  coords.${e[f - 1]} = coords.${e[f - 2]};\n  coords.${e[f - 2]} = lastDim;`;\n  return `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${i} coords = getOutputCoords();\n  ${L}\n  ${v}\n  vec4 outputValue = getA(${r});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${i} coords = getOutputCoords();\n  ${L}\n  ${S}\n  vec4 outputValue = getB(${n});\n  return outputValue;\n}`;\n}\nfunction Cm(i, e) {\n  let o = \"\";\n  for (let t = 0; t < e - 2; t++) o += `rc.${i[t]}, `;\n  return o += `rc.${i[e - 2]}, i*2`, o;\n}\nfunction Nm(i, e) {\n  let o = \"\";\n  for (let t = 0; t < e - 2; t++) o += `rc.${i[t]}, `;\n  return o += `i*2, rc.${i[e - 1]}`, o;\n}\nvar km,\n  Bm,\n  Cn,\n  vi = O(() => {\n    \"use strict\";\n\n    Y();\n    ut();\n    j();\n    pe();\n    qe();\n    Fn();\n    km = (i, e) => ({\n      name: \"MatMul (packed)\",\n      inputNames: i ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n      inputTypes: i ? [2, 2, 2] : [2, 2],\n      cacheHint: e\n    }), Bm = (i, e, o, t) => {\n      let r = o.length > 2,\n        n = r ? \"value += getBiasForMatmul();\" : \"\",\n        s = o[0].dims,\n        a = o[1].dims,\n        u = kt.calcShape(s, a, !0),\n        l = !B.areEqual(o[0].dims, o[1].dims);\n      if (!u) throw new Error(\"Can't use matmul on the given tensors\");\n      let f = s[s.length - 1],\n        p = Math.ceil(f / 2),\n        d = s.length,\n        y = a.length,\n        T = G(i.session.backend.glContext.version),\n        v = Bt(u.length),\n        S = u.length,\n        L = ne(),\n        {\n          activationFunction: P,\n          applyActivation: A\n        } = he(t),\n        M = r ? `${wi(v, L, o[2].dims, u, !0)}` : \"\",\n        V = l ? `${Fm(v, L, o, u)}` : \"\",\n        lt = l ? \"getAAtOutCoordsMatmul(i)\" : `getA(${Cm(L, d)})`,\n        wt = l ? \"getBAtOutCoordsMatmul(i)\" : `getB(${Nm(L, y)})`,\n        et = l ? \"\" : `${v} rc =\n          getOutputCoords(); int lastDim = rc.${L[S - 1]}; rc.${L[S - 1]} =\n          rc.${L[S - 2]}; rc.${L[S - 2]} = lastDim;\n      `,\n        Dt = `\n            ${V}\n            ${M}\n            ${P}\n            void main() {\n              ${et}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${p}; i++) {\n                vec4 a = ${lt};\n                vec4 b = ${wt};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${n}\n              ${A}\n              ${T.output} = value;\n            }`;\n      return {\n        ...e,\n        output: {\n          dims: u,\n          type: o[0].type,\n          textureType: 2\n        },\n        shaderSource: Dt,\n        hasMain: !0\n      };\n    }, Cn = (i, e, o) => {\n      let t = km(e.length > 2, o.activationCacheKey);\n      return {\n        ...t,\n        get: () => Bm(i, t, e, o)\n      };\n    };\n  });\nvar hf,\n  mf = O(() => {\n    \"use strict\";\n\n    Bn();\n    cf();\n    vi();\n    hf = (i, e, o) => {\n      let t = e[0].dims,\n        r = e[1].dims,\n        n = dr(t, r, o.dilations, o.pads, o.strides),\n        s = i.run(ff(i, e[0], e[1], n, o), [e[0]]),\n        a = i.reshapePacked(e[1], [r[0], r[1] * r[2] * r[3]]),\n        u = e.length === 3 ? [a, s, e[2]] : [a, s],\n        l = i.run(Cn(i, u, o), u);\n      return i.reshapePacked(l, n);\n    };\n  });\nvar Rm,\n  Gm,\n  bf,\n  Ii,\n  _i = O(() => {\n    \"use strict\";\n\n    j();\n    Rm = i => ({\n      name: \"Im2Col\",\n      inputNames: [\"X\"],\n      inputTypes: [0],\n      cacheHint: i\n    }), Gm = (i, e, o, t, r, n) => {\n      let s = o.dims,\n        a = t.dims,\n        u = r.length,\n        l = Ii(s, a, r, 4),\n        f = `\n        const int XC = ${s[1]};\n        const int XH = ${s[2]};\n        const int XW = ${s[3]};\n        const int KH = ${n.kernelShape[0]};\n        const int KW = ${n.kernelShape[1]};\n        const int dilationH = ${n.dilations[0]};\n        const int dilationW = ${n.dilations[1]};\n        const int strideH = ${n.strides[0]};\n        const int strideW = ${n.strides[1]};\n        const int padH = ${n.pads[0]};\n        const int padW = ${n.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${u}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${s.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;\n      return {\n        ...e,\n        output: {\n          dims: l,\n          type: o.type,\n          textureType: 4\n        },\n        shaderSource: f\n      };\n    }, bf = (i, e, o, t, r) => {\n      let n = Rm(r.cacheKey);\n      return {\n        ...n,\n        get: () => Gm(i, n, e, o, t, r)\n      };\n    }, Ii = (i, e, o, t = 4) => [o[0], o[2], o[3], Math.ceil(i[1] * e[2] * e[3] / t)];\n  });\nvar Mm,\n  Um,\n  gf,\n  yf = O(() => {\n    \"use strict\";\n\n    Y();\n    ut();\n    j();\n    qe();\n    _i();\n    Mm = (i, e) => ({\n      name: \"ConvDotProduct\",\n      inputNames: i ? [\"Im2Col\", \"K\", \"B\"] : [\"Im2Col\", \"K\"],\n      inputTypes: i ? [0, 4, 0] : [0, 4],\n      cacheKey: e.activationCacheKey\n    }), Um = (i, e, o, t, r) => {\n      let n = o[0].dims,\n        s = o[1].dims,\n        a = [s[0], Math.ceil(n[1] * s[2] * s[3] / 4)],\n        u = Ii(n, s, t),\n        [l, f] = i.calculateTextureWidthAndHeight(a, 4),\n        p = B.computeStrides(u),\n        [d, y] = i.calculateTextureWidthAndHeight(u, 4),\n        T = t.length,\n        v = o.length < 3 ? \"0.0\" : \"_B(b)\",\n        S = Math.ceil(n[1] * s[2] * s[3] / 4),\n        {\n          activationFunction: L,\n          applyActivation: P\n        } = he(r),\n        A = G(i.session.backend.glContext.version),\n        M = `\n${L}\nfloat process(int indices[${T}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${p[0]} + im2col[1] * ${p[1]} + im2col[2] * ${p[2]};\n  int kernelOffset = indices[1] * ${a[1]};\n  float value = ${v};\n  for (int i = 0; i < ${S}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${f});\n    value += dot(${A.texture2D}(Im2Col, im2colCoords), ${A.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${P}\n  return value;\n}`;\n      return {\n        ...e,\n        output: {\n          dims: t,\n          type: o[0].type,\n          textureType: 0\n        },\n        shaderSource: M\n      };\n    }, gf = (i, e, o, t) => {\n      let r = Mm(e.length > 2, t);\n      return {\n        ...r,\n        get: () => Um(i, r, e, o, t)\n      };\n    };\n  });\nvar dr,\n  Oi,\n  Vm,\n  zm,\n  Wm,\n  Hm,\n  Si,\n  qm,\n  Bn = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    lf();\n    mf();\n    yf();\n    qe();\n    _i();\n    Fn();\n    dr = (i, e, o, t, r) => {\n      let n = i[0],\n        s = i.slice(2),\n        a = s.length,\n        u = e[0],\n        f = e.slice(2).map((T, v) => T + (T - 1) * (o[v] - 1)),\n        d = s.map((T, v) => T + t[v] + t[v + a]).map((T, v) => Math.floor((T - f[v] + r[v]) / r[v]));\n      return [n, u].concat(...d);\n    }, Oi = (i, e, o) => (qm(e, o), Vm(i, e, o)), Vm = (i, e, o) => {\n      let t = Hm(o, e),\n        r = i.session.pack,\n        n = t.kernelShape[0] === 1 && t.kernelShape[1] === 1;\n      return t.group > 1 ? [i.run(uf(i, e, t), e)] : n && r ? [zm(i, e, t)] : r && e[0].dims.length === 4 && e[0].dims[0] === 1 && !n ? [hf(i, e, t)] : [Wm(i, e, t)];\n    }, zm = (i, e, o) => {\n      let t = e[0].dims,\n        r = e[1].dims,\n        n = dr(t, r, o.dilations, o.pads, o.strides),\n        s = i.reshapeUnpacked(e[0], [t[1], t[2] * t[3]]),\n        a = i.reshapeUnpacked(e[1], [r[0], r[1]]),\n        u = e.length > 2 ? [a, s, e[2]] : [a, s],\n        l = i.run(Ti(u, o), u);\n      return i.reshapeUnpacked(l, n);\n    }, Wm = (i, e, o) => {\n      let t = e[0].dims,\n        r = e[1].dims,\n        n = dr(t, r, o.dilations, o.pads, o.strides),\n        s = i.run(bf(i, e[0], e[1], n, o), [e[0]]),\n        a = e.length === 3 ? [s, e[1], e[2]] : [s, e[1]];\n      return i.run(gf(i, e, n, o), a);\n    }, Hm = (i, e) => {\n      let o = i.kernelShape.slice();\n      if (i.kernelShape.length === 0) for (let n = 2; n < e[1].dims.length; ++n) o.push(e[1].dims[n]);\n      let t = i.pads.slice();\n      Ue.adjustPadsBasedOnAutoPad(e[0].dims, i.strides, i.dilations, o, t, i.autoPad);\n      let r = Object.assign({}, i);\n      return Object.assign(r, {\n        kernelShape: o,\n        pads: t,\n        cacheKey: i.cacheKey\n      }), r;\n    }, Si = i => {\n      let e = i.attributes,\n        o = pr(e),\n        t = e.getString(\"auto_pad\", \"NOTSET\"),\n        r = e.getInts(\"dilations\", [1, 1]),\n        n = e.getInt(\"group\", 1),\n        s = e.getInts(\"kernel_shape\", []),\n        a = e.getInts(\"pads\", [0, 0, 0, 0]),\n        u = e.getInts(\"strides\", [1, 1]);\n      return W({\n        autoPad: t,\n        dilations: r,\n        group: n,\n        kernelShape: s,\n        pads: a,\n        strides: u,\n        ...o\n      });\n    }, qm = (i, e) => {\n      if (!i || i.length !== 2 && i.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n      if (i[0].dims.length !== 4 || i[1].dims.length !== 4) throw new Error(\"currently only support 2-dimensional conv\");\n      let o = i[0].dims[1],\n        t = i[1].dims[1] * e.group;\n      if (o !== t) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n      if (i.length === 3 && (i[2].dims.length !== 1 || i[1].dims[0] !== i[2].dims[0])) throw new Error(\"invalid bias\");\n      let r = i[0].dims.length - 2;\n      if (e.dilations.length !== r) throw new Error(`dilations should be ${r}D`);\n      if (e.strides.length !== r) throw new Error(`strides should be ${r}D`);\n      if (e.pads.length !== r * 2) throw new Error(`pads should be ${r * 2}D`);\n      if (e.kernelShape.length !== 0 && e.kernelShape.length !== i[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n      if (i[0].type !== \"float32\" || i[1].type !== \"float32\") throw new Error(\"Conv input(X,W) should be float tensor\");\n      if (i.length === 3 && i[2].type !== \"float32\") throw new Error(\"Conv input(bias) should be float tensor\");\n    };\n  });\nvar jm,\n  Xm,\n  Km,\n  xf,\n  Jm,\n  Ym,\n  Zm,\n  Qm,\n  tb,\n  eb,\n  Tf,\n  rb,\n  wf = O(() => {\n    \"use strict\";\n\n    It();\n    ut();\n    j();\n    qe();\n    jm = (i, e, o, t, r, n) => (i - 1) * e + o + (t - 1) * r + 1 - n, Xm = (i, e, o, t, r) => {\n      let n = Math.floor(i / 2);\n      e === \"SAME_UPPER\" ? (o[t] = n, o[r] = i - n) : e === \"SAME_LOWER\" && (o[t] = i - n, o[r] = n);\n    }, Km = (i, e, o, t, r, n, s, a) => {\n      let u = i.length - 2,\n        l = a.length === 0;\n      for (let f = 0; f < u; ++f) {\n        let p = l ? i[f + 2] * n[f] : a[f],\n          d = jm(i[f + 2], n[f], r[f], e[f], o[f], p);\n        Xm(d, t, r, f, f + u), l && a.push(n[f] * (i[f + 2] - 1) + s[f] + (e[f] - 1) * o[f] + 1 - r[f] - r[f + u]);\n      }\n    }, xf = (i, e, o) => (rb(e, o), Jm(i, e, o)), Jm = (i, e, o) => {\n      let t = eb(o, e);\n      return [tb(i, e, t)];\n    }, Ym = (i, e) => ({\n      name: \"ConvTranspose\",\n      inputNames: i ? [\"X\", \"W\", \"B\"] : [\"X\", \"W\"],\n      inputTypes: i ? [0, 0, 0] : [0, 0],\n      cacheHint: e\n    }), Zm = (i, e, o, t) => {\n      let n = e.length > 2 ? \"getB(output_channel)\" : \"0.0\",\n        s = e[0].dims,\n        a = e[1].dims,\n        u = a[1],\n        l = a[0] / t.group,\n        f = [e[0].dims[0], e[1].dims[1] * t.group, ...t.outputShape],\n        p = G(i.session.backend.glContext.version),\n        {\n          activationFunction: d,\n          applyActivation: y\n        } = he(t),\n        T = `\n  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});\n  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});\n  ${d}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${u};\n    int wOutChannel = output_channel - group_id * ${u};\n\n    float value = ${n};\n    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {\n      int input_channel = group_id * ${l} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${s[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${y}\n    ${p.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...o,\n        output: {\n          dims: f,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: T,\n        hasMain: !0\n      };\n    }, Qm = (i, e, o) => {\n      let t = Ym(e.length > 2, o.cacheKey);\n      return {\n        ...t,\n        get: () => Zm(i, e, t, o)\n      };\n    }, tb = (i, e, o) => i.run(Qm(i, e, o), e), eb = (i, e) => {\n      let o = i.kernelShape.slice();\n      if (i.kernelShape.length === 0) for (let a = 2; a < e[1].dims.length; ++a) o.push(e[1].dims[a]);\n      let t = i.pads.slice(),\n        r = i.outputShape.slice(),\n        n = e[0].dims;\n      Km(n, o, i.dilations, i.autoPad, t, i.strides, i.outputPadding, r);\n      let s = Object.assign({}, i);\n      return Object.assign(s, {\n        kernelShape: o,\n        pads: t,\n        outputShape: r,\n        cacheKey: i.cacheKey\n      }), s;\n    }, Tf = i => {\n      let e = i.attributes,\n        o = pr(e),\n        t = e.getString(\"auto_pad\", \"NOTSET\"),\n        r = e.getInts(\"dilations\", [1, 1]),\n        n = e.getInt(\"group\", 1),\n        s = e.getInts(\"kernel_shape\", []),\n        a = e.getInts(\"output_padding\", [0, 0]),\n        u = e.getInts(\"output_shape\", []),\n        l = e.getInts(\"pads\", [0, 0, 0, 0]),\n        f = e.getInts(\"strides\", [1, 1]);\n      return W({\n        autoPad: t,\n        dilations: r,\n        group: n,\n        kernelShape: s,\n        outputPadding: a,\n        outputShape: u,\n        pads: l,\n        strides: f,\n        ...o\n      });\n    }, rb = (i, e) => {\n      if (!i || i.length !== 2 && i.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n      if (i[0].dims.length !== 4 || i[1].dims.length !== 4) throw new Error(\"currently only support 2-dimensional conv\");\n      let o = i[0].dims[1],\n        t = i[1].dims[0];\n      if (o !== t) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n      let r = i[1].dims[1] * e.group;\n      if (i.length === 3 && (i[2].dims.length !== 1 || i[2].dims[0] !== r)) throw new Error(\"invalid bias\");\n      let n = i[0].dims.length - 2;\n      if (e.dilations.length !== n) throw new Error(`dilations should be ${n}D`);\n      if (e.strides.length !== n) throw new Error(`strides should be ${n}D`);\n      if (e.pads.length !== n * 2) throw new Error(`pads should be ${n * 2}D`);\n      if (e.outputPadding.length !== n) throw new Error(`output_padding should be ${n}D`);\n      if (e.kernelShape.length !== 0 && e.kernelShape.length !== i[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n      if (e.outputShape.length !== 0 && e.outputShape.length !== i[0].dims.length - 2) throw new Error(\"invalid output shape\");\n      if (i[0].type !== \"float32\" || i[1].type !== \"float32\") throw new Error(\"ConvTranspose input(X,W) should be float tensor\");\n      if (i.length === 3 && i[2].type !== \"float32\") throw new Error(\"ConvTranspose input(bias) should be float tensor\");\n    };\n  });\nvar vf,\n  je,\n  If,\n  nb,\n  _f,\n  ob,\n  ib,\n  ab,\n  Nn = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    vf = {\n      name: \"Transpose\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, je = (i, e, o) => (ab(e), [i.run({\n      ...vf,\n      cacheHint: o.cacheKey,\n      get: () => nb(i, e[0], o.perm)\n    }, e)]), If = i => W({\n      perm: i.attributes.getInts(\"perm\", [])\n    }), nb = (i, e, o) => {\n      let t = e.dims;\n      o = _f(t, o);\n      let r = ob(t, o),\n        n = t.length,\n        s = `\n      ${ib(\"perm\", o, n)}\n      float process(int indices[${n}]) {\n        int a[${n}];\n        perm(a, indices);\n        return _A(a);\n      }`;\n      return {\n        ...vf,\n        output: {\n          dims: r,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: s\n      };\n    }, _f = (i, e) => (e && e.length !== i.length && (e = [...i.keys()].reverse()), e), ob = (i, e) => (e = _f(i, e), B.sortBasedOnPerm(i, e)), ib = (i, e, o) => {\n      let t = [];\n      t.push(`void ${i}(out int a[${o}], int src[${o}]) {`);\n      for (let r = 0; r < o; ++r) t.push(`\ta[${e[r]}]=src[${r}];`);\n      return t.push(\"\t}\"), t.join(`\n`);\n    }, ab = i => {\n      if (!i || i.length !== 1) throw new Error(\"Transpose requires 1 input.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"input should be float tensor\");\n    };\n  });\nvar Of,\n  Sf,\n  sb,\n  Af = O(() => {\n    \"use strict\";\n\n    Nn();\n    Of = (i, e, o) => {\n      sb(e);\n      let t = o.blocksize,\n        r = t * t,\n        n = o.mode === \"DCR\" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3],\n        s = o.mode === \"DCR\" ? [e[0].dims[0], t, t, e[0].dims[1] / r, e[0].dims[2], e[0].dims[3]] : [e[0].dims[0], e[0].dims[1] / r, t, t, e[0].dims[2], e[0].dims[3]],\n        a = i.reshapeUnpacked(e[0], s),\n        u = {\n          perm: n,\n          cacheKey: `${n}`\n        },\n        [l] = je(i, [a], u),\n        f = [e[0].dims[0], e[0].dims[1] / r, e[0].dims[2] * t, e[0].dims[3] * t];\n      return [i.reshapeUnpacked(l, f)];\n    }, Sf = i => {\n      let e = i.attributes.getInt(\"blocksize\");\n      if (e < 1) throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);\n      let o = i.attributes.getString(\"mode\", \"DCR\");\n      if (o !== \"DCR\" && o !== \"CRD\") throw new Error(`unrecognized mode: ${o} for DepthToSpace`);\n      return {\n        mode: o,\n        blocksize: e\n      };\n    }, sb = i => {\n      if (i.length !== 1) throw new Error(`DepthToSpace expect 1 inputs, but got ${i.length}`);\n      if (i[0].type === \"string\" || i[0].dims.length !== 4) throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\");\n    };\n  });\nvar Pf,\n  Ef,\n  ub,\n  Df = O(() => {\n    \"use strict\";\n\n    Y();\n    Pf = (i, e, o) => {\n      ub(e, o);\n      let t = B.flattenShape(e[0].dims, o);\n      return [i.reshapeUnpacked(e[0], t)];\n    }, Ef = i => i.attributes.getInt(\"axis\", 1), ub = (i, e) => {\n      if (!i || i.length !== 1) throw new Error(\"Flatten requires 1 input.\");\n      let o = i[0].dims.length;\n      if (o === 0) throw new Error(\"scalar tensor is not supported.\");\n      if (e < -o || e > o) throw new Error(\"Invalid axis\");\n      if (i[0].type === \"string\") throw new Error(\"string tensor is not supported.\");\n    };\n  });\nvar Pe,\n  Rr = O(() => {\n    \"use strict\";\n\n    Pe = [\"float32\", \"float64\", \"int32\", \"int16\", \"int8\", \"uint16\", \"uint32\", \"uint8\"];\n  });\nvar Lf,\n  $f,\n  lb,\n  fb,\n  cb,\n  pb,\n  kf = O(() => {\n    \"use strict\";\n\n    It();\n    Rr();\n    Y();\n    j();\n    Lf = (i, e, o) => (pb(e, o.axis), [i.run(cb(i, e, o), e)]), $f = i => W({\n      axis: i.attributes.getInt(\"axis\", 0)\n    }), lb = {\n      name: \"Gather\",\n      inputNames: [\"A\", \"B\"],\n      inputTypes: [0, 0]\n    }, fb = (i, e, o, t) => {\n      let r = o[0].dims.slice(),\n        n = o[1].dims.slice(),\n        s = new Array(r.length + n.length - 1);\n      t = B.normalizeAxis(t, r.length);\n      let a = [];\n      for (let d = 0; d < s.length; d++) d < t ? (s[d] = r[d], a.push(`inputIdx[${d}] = outputIdx[${d}];`)) : d < t + n.length ? (s[d] = n[d - t], a.push(`indexDataIdx[${d - t}] = outputIdx[${d}];`)) : (s[d] = r[d - n.length + 1], a.push(`inputIdx[${d - n.length + 1}] = outputIdx[${d}];`));\n      let u = s.length || 1,\n        l = r.length,\n        f = n.length || 1,\n        p = `\n      float process(int outputIdx[${u}]) {\n        int inputIdx[${l}];\n        int indexDataIdx[${f}];\n        indexDataIdx[0] = 0;\n        ${a.join(`\n        `)}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${t}] = idx < 0 ? idx + ${r[t]} : idx;\n        return _A(inputIdx);\n      }`;\n      return {\n        ...e,\n        output: {\n          dims: s,\n          type: o[0].type,\n          textureType: 0\n        },\n        shaderSource: p\n      };\n    }, cb = (i, e, o) => {\n      let t = {\n        ...lb,\n        cacheHint: o.cacheKey\n      };\n      return {\n        ...t,\n        get: () => fb(i, t, e, o.axis)\n      };\n    }, pb = (i, e) => {\n      if (!i || i.length !== 2) throw new Error(\"Gather requires 2 inputs.\");\n      let o = i[0].dims.length;\n      if (o < 1) throw new Error(\"Invalid input shape.\");\n      if (e < -o || e > o - 1) throw new Error(\"Invalid axis.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invaid input type.\");\n      if (i[1].type !== \"int32\" && i[1].type !== \"int16\") throw new Error(\"Invaid input type.\");\n    };\n  });\nvar Ai,\n  Bf,\n  Ff,\n  Cf,\n  db,\n  hb,\n  mb,\n  Nf = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    Ai = (i, e, o) => (mb(e, o), [i.run(db(e, o), e)]), Bf = (i, e) => {\n      let o = i.attributes.getInt(\"transA\", 0) !== 0,\n        t = i.attributes.getInt(\"transB\", 0) !== 0,\n        r = i.attributes.getFloat(\"alpha\", 1),\n        n = i.attributes.getFloat(\"beta\", 1);\n      return W({\n        transA: o,\n        transB: t,\n        alpha: r,\n        beta: n,\n        isOptionalC: e\n      });\n    }, Ff = i => Bf(i, !1), Cf = i => Bf(i, !0), db = (i, e) => {\n      let o = {\n        name: \"Gemm\",\n        inputNames: i.length === 3 ? [\"A\", \"B\", \"C\"] : [\"A\", \"B\"],\n        inputTypes: i.length === 3 ? [0, 0, 0] : [0, 0],\n        key: e.cacheKey\n      };\n      return {\n        ...o,\n        get: () => hb(o, i, e)\n      };\n    }, hb = (i, e, o) => {\n      let t = e[0].dims.slice(),\n        r = e[1].dims.slice(),\n        [n, s] = Sn.getShapeOfGemmResult(t, o.transA, r, o.transB, e.length === 3 ? e[2].dims : void 0),\n        a = [n, s];\n      if (!a) throw new Error(\"Can't use gemm on the given tensors\");\n      let u = t[t.length - 1],\n        l = \"\";\n      o.transA && (u = t[0]), o.transA && o.transB ? l = \"value += _A_T(a) * _B_T(b);\" : o.transA && !o.transB ? l = \"value += _A_T(a) * _B(b);\" : !o.transA && o.transB ? l = \"value += _A(a) * _B_T(b);\" : !o.transA && !o.transB && (l = \"value += _A(a) * _B(b);\");\n      let f = a.length,\n        p = e.length === 3 ? `int c[${e[2].dims.length}];` : \"\",\n        d = e.length === 3 ? \"bcastIndices_C(indices, c);\" : \"\",\n        y = e.length === 3 ? \"value += beta * _C(c);\" : \"\",\n        T = `\n      float process(int indices[${f}]) {\n          int a[${f}];\n          int b[${f}];\n          ${p}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${d}\n\n          float value = 0.0;\n          for (int k=0; k<${u}; ++k) {\n              a[${f - 1}] = k;\n              b[${f - 2}] = k;\n              ${l}\n          }\n\n          value = value * alpha;\n          ${y}\n          return value;\n      }`;\n      return {\n        ...i,\n        output: {\n          dims: a,\n          type: e[0].type,\n          textureType: 0\n        },\n        variables: [{\n          name: \"alpha\",\n          type: \"float\",\n          data: o.alpha\n        }, {\n          name: \"beta\",\n          type: \"float\",\n          data: o.beta\n        }],\n        shaderSource: T\n      };\n    }, mb = (i, e) => {\n      if (!i) throw new Error(\"Input is missing\");\n      if (e.isOptionalC && (i.length < 2 || i.length > 3)) throw new Error(\"Invaid input shape.\");\n      if (!e.isOptionalC && i.length !== 3) throw new Error(\"Gemm requires 3 inputs\");\n      if (i.length === 3 && i[2].dims.length !== 1 && i[2].dims.length !== 2) throw new Error(\"Invalid input shape of C\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\" || i[1].type !== \"float32\" && i[1].type !== \"float64\" || i.length === 3 && i[2].type !== \"float32\" && i[2].type !== \"float64\") throw new Error(\"Invalid input type.\");\n      if (i[0].type !== i[1].type || i.length === 3 && i[0].type !== i[2].type) throw new Error(\"Input types are mismatched\");\n    };\n  });\nvar Rf,\n  Gf,\n  bb,\n  gb,\n  yb,\n  xb,\n  Tb,\n  Mf = O(() => {\n    \"use strict\";\n\n    It();\n    j();\n    Rf = (i, e, o) => (Tb(e), [i.run(yb(i, e, o), e)]), Gf = i => {\n      let e = i.attributes.getFloat(\"scale\"),\n        o = i.attributes.getFloats(\"bias\");\n      return W({\n        scale: e,\n        bias: o\n      });\n    }, bb = {\n      name: \"ImageScaler\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, gb = (i, e, o, t) => {\n      let r = o[0].dims.slice(),\n        n = r.length,\n        a = `\n      ${xb(t.bias.length)}\n      float process(int indices[${n}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;\n      return {\n        ...e,\n        output: {\n          dims: r,\n          type: o[0].type,\n          textureType: 0\n        },\n        variables: [{\n          name: \"bias\",\n          type: \"float\",\n          arrayLength: t.bias.length,\n          data: t.bias\n        }, {\n          name: \"scale\",\n          type: \"float\",\n          data: t.scale\n        }],\n        shaderSource: a\n      };\n    }, yb = (i, e, o) => {\n      let t = {\n        ...bb,\n        cacheHint: o.cacheKey\n      };\n      return {\n        ...t,\n        get: () => gb(i, t, e, o)\n      };\n    }, xb = i => {\n      let e = [`float getBias(float bias[${i}], int channel) {`];\n      for (let o = 0; o < i; ++o) o === 0 ? e.push(`\tif (channel == ${o}) { return bias[${o}]; }`) : o === i - 1 ? e.push(`\telse { return bias[${o}]; }`) : e.push(`\telse if (channel == ${o}) { return bias[${o}]; }`);\n      return e.push(\"\t}\"), e.join(`\n`);\n    }, Tb = i => {\n      if (!i || i.length !== 1) throw new Error(\"ImageScaler requires 1 input.\");\n      if (i[0].dims.length !== 4) throw new Error(\"Invalid input shape.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Vf,\n  zf,\n  Uf,\n  wb,\n  vb,\n  Ib,\n  _b,\n  Ob,\n  Sb,\n  Wf = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    Vf = (i, e, o) => {\n      Sb(e);\n      let t = i.run(vb(e[0]), e);\n      return [i.run(Ob(i, e[0], o, t.dims), [e[0], t, e[1], e[2]])];\n    }, zf = i => i.attributes.getFloat(\"epsilon\", 1e-5), Uf = {\n      name: \"InstanceNormalization_MeanAndVariance\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, wb = (i, e) => {\n      let o = e.dims.slice(),\n        t = o[1],\n        r = o[2] * o[3],\n        n = [o[0], t],\n        s = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${o[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${o[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${r});\n        temp = 0.0;\n        for(int a2=0; a2<${o[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${o[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${r});\n\n        return v;\n      }`;\n      return {\n        ...i,\n        output: {\n          dims: n,\n          type: e.type,\n          textureType: 4\n        },\n        shaderSource: s\n      };\n    }, vb = i => ({\n      ...Uf,\n      get: () => wb(Uf, i)\n    }), Ib = {\n      name: \"InstanceNormalization_ComputeOutput\",\n      inputNames: [\"X\", \"MeanAndVariance\", \"Scale\", \"B\"],\n      inputTypes: [0, 4, 0, 0]\n    }, _b = (i, e, o, t, r) => {\n      let n = G(i.session.backend.glContext.version),\n        [s, a] = i.calculateTextureWidthAndHeight(r, 4),\n        [u, l] = [s / 4, a],\n        f = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${u}, ${l});\n        return ${n.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;\n      return {\n        ...e,\n        output: {\n          dims: o.dims,\n          type: o.type,\n          textureType: 0\n        },\n        variables: [{\n          name: \"epsilon\",\n          type: \"float\",\n          data: t\n        }],\n        shaderSource: f\n      };\n    }, Ob = (i, e, o, t) => {\n      let r = {\n        ...Ib,\n        cacheHint: `${o}`\n      };\n      return {\n        ...r,\n        get: () => _b(i, r, e, o, t)\n      };\n    }, Sb = i => {\n      if (!i || i.length !== 3) throw new Error(\"InstanceNormalization requires 3 inputs.\");\n      let e = i[0],\n        o = i[1],\n        t = i[2];\n      if (e.dims.length < 3 || o.dims.length !== 1 || t.dims.length !== 1) throw new Error(\"Invalid input shape.\");\n      if (o.dims[0] !== e.dims[1] || t.dims[0] !== e.dims[1]) throw new Error(\"Input shapes are mismatched.\");\n      if (e.type !== \"float32\" && e.type !== \"float64\" || o.type !== \"float32\" && o.type !== \"float64\" || t.type !== \"float32\" && t.type !== \"float64\") throw new Error(\"Invalid input type.\");\n      if (i[0].dims.length !== 4) throw new Error(\"Only support 4-D input shape.\");\n    };\n  });\nfunction Ab(i, e) {\n  let o = i[0].dims[1],\n    t = i[0].dims.length,\n    r = -Math.floor((e.size - 1) / 2),\n    n = Math.ceil((e.size - 1) / 2),\n    s = `float(${e.alpha}) / float(${e.size})`,\n    a = `float(${e.bias})`,\n    u = `float(${e.beta})`,\n    l = `\n    float process(int indices[${t}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${r}; i <= ${n}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${o}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${a} + ${s} * square_sum, ${u});\n    }`;\n  return {\n    ...jf,\n    cacheHint: e.cacheKey,\n    output: {\n      dims: i[0].dims,\n      type: i[0].type,\n      textureType: 0\n    },\n    shaderSource: l\n  };\n}\nfunction Pb(i, e) {\n  return {\n    ...jf,\n    cacheHint: e.cacheKey,\n    get: () => Ab(i, e)\n  };\n}\nvar Hf,\n  qf,\n  jf,\n  Eb,\n  Xf = O(() => {\n    \"use strict\";\n\n    It();\n    j();\n    Hf = (i, e, o) => (Eb(e), [i.run(Pb(e, o), e)]), qf = i => {\n      let e = i.attributes.getFloat(\"alpha\", 1e-4),\n        o = i.attributes.getFloat(\"beta\", .75),\n        t = i.attributes.getFloat(\"bias\", 1),\n        r = i.attributes.getInt(\"size\");\n      return W({\n        alpha: e,\n        beta: o,\n        bias: t,\n        size: r\n      });\n    }, jf = {\n      name: \"LRN\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    };\n    Eb = i => {\n      if (!i || i.length !== 1) throw new Error(\"LRN requires 1 input.\");\n      if (i[0].dims.length !== 4) throw new Error('currently only support LRN for input with \"NCHW\" format');\n      if (i[0].type !== \"float32\") throw new Error(\"input should be float type\");\n    };\n  });\nvar Db,\n  Pi,\n  Kf,\n  Jf,\n  Yf,\n  Lb,\n  $b,\n  kb,\n  Bb,\n  Fb,\n  Cb,\n  Nb,\n  Rb,\n  Zf = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    ut();\n    j();\n    Db = {\n      name: \"Pad\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, Pi = (i, e, o) => (kb(e), [i.run({\n      ...Db,\n      cacheHint: o.cacheKey,\n      get: () => $b(i, e[0], o)\n    }, e)]), Kf = i => {\n      let e = i.attributes.getString(\"mode\", \"constant\"),\n        o = i.attributes.getFloat(\"value\", 0),\n        t = i.attributes.getInts(\"pads\");\n      return W({\n        mode: e,\n        value: o,\n        pads: t\n      });\n    }, Jf = (i, e, o) => {\n      Bb(e);\n      let t = Lb(i, e, o);\n      return Pi(i, [e[0]], t);\n    }, Yf = i => i.attributes.getString(\"mode\", \"constant\"), Lb = (i, e, o) => {\n      if (!i.session.isInitializer(e[1].dataId) || e.length >= 3 && !i.session.isInitializer(e[2].dataId)) throw new Error(\"dynamic pad attributes are not allowed\");\n      let t = Array.from(e[1].integerData),\n        r = e.length >= 3 ? e[2].floatData[0] : 0;\n      return W({\n        mode: o,\n        pads: t,\n        value: r\n      });\n    }, $b = (i, e, o) => {\n      let t = B.padShape(e.dims.slice(), o.pads),\n        r = t.length,\n        s = `\n      ${Fb(i, e, o)}\n      float process(int[${r}] indices) {\n          return padA(indices);\n      }`;\n      return {\n        name: \"Pad\",\n        inputNames: [\"A\"],\n        inputTypes: [0],\n        output: {\n          dims: t,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: s\n      };\n    }, kb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Pad requires 1 input\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n    }, Bb = i => {\n      if (!i || i.length !== 2 && i.length !== 3) throw new Error(\"Pad requires 2 or 3 inputs\");\n      if (i[1].type !== \"int32\") throw new Error(\"Invalid input type.\");\n      if (i.length >= 3 && i[2].type === \"string\") throw new Error(\"Invalid input type.\");\n    }, Fb = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        [r, n] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        s = B.computeStrides(e.dims);\n      switch (o.mode) {\n        case \"constant\":\n          return Cb(t, e.dims, s, r, n, o.pads, o.value);\n        case \"reflect\":\n          return Nb(t, e.dims, s, r, n, o.pads);\n        case \"edge\":\n          return Rb(t, e.dims, s, r, n, o.pads);\n        default:\n          throw new Error(\"Invalid mode\");\n      }\n    }, Cb = (i, e, o, t, r, n, s) => {\n      let a = e.length,\n        u = \"\";\n      for (let l = a - 1; l >= 0; --l) u += `\n        k = m[${l}] - ${n[l]};\n        if (k < 0)  return constant;\n        if (k >= ${e[l]}) return constant;\n        offset += k * ${o[l]};\n        `;\n      return `\n      float padA(int m[${a}]) {\n        const float constant = float(${s});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${t}, ${r});\n        float value = getColorAsFloat(${i.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    }, Nb = (i, e, o, t, r, n) => {\n      let s = e.length,\n        a = \"\";\n      for (let u = s - 1; u >= 0; --u) a += `\n        k = m[${u}] - ${n[u]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (e[u] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${e[u]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${o[u]};\n        `;\n      return `\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${a}\n        vec2 coords = offsetToCoords(offset, ${t}, ${r});\n        float value = getColorAsFloat(${i.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    }, Rb = (i, e, o, t, r, n) => {\n      let s = e.length,\n        a = \"\";\n      for (let u = s - 1; u >= 0; --u) a += `\n        k = m[${u}] - ${n[u]};\n        if (k < 0)  k = 0;\n        if (k >= ${e[u]}) k = ${e[u] - 1};\n        offset += k * ${o[u]};\n      `;\n      return `\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${a}\n        vec2 coords = offsetToCoords(offset, ${t}, ${r});\n        float value = getColorAsFloat(${i.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    };\n  });\nvar tc,\n  ec,\n  rc,\n  nc,\n  oc,\n  ic,\n  ac,\n  sc,\n  uc,\n  Gb,\n  Qf,\n  lc,\n  Gn,\n  fc,\n  Rn,\n  Mb,\n  cc = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    tc = (i, e, o) => {\n      Gn(e);\n      let t = {\n        name: \"AveragePool\",\n        inputNames: [\"X\"],\n        inputTypes: [0],\n        cacheHint: o.cacheKey\n      };\n      return [i.run({\n        ...t,\n        get: () => rc(e, t, !1, o)\n      }, e)];\n    }, ec = i => {\n      let e = i.attributes.getString(\"auto_pad\", \"NOTSET\"),\n        o = i.attributes.getInt(\"ceil_mode\", 0),\n        t = i.attributes.getInt(\"count_include_pad\", 0) !== 0,\n        r = i.attributes.getInts(\"kernel_shape\"),\n        n = i.attributes.getInts(\"strides\", []),\n        s = i.attributes.getInts(\"pads\", []);\n      if (o !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n      return W({\n        autoPad: e,\n        ceilMode: o,\n        countIncludePad: t,\n        kernelShape: r,\n        strides: n,\n        pads: s\n      });\n    }, rc = (i, e, o, t) => {\n      let [r, n] = uc(i, t, o),\n        s = B.size(r.kernelShape),\n        a = \"value += _X(x);\",\n        u = \"\";\n      r.countIncludePad ? u += `value /= float(${s});` : u += `value /= float(${s} - pad);`;\n      let f = `\n        ${fc(i[0].dims, r, a, u, \"0.0\")}\n      `;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: i[0].type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, nc = (i, e, o) => {\n      Gn(e);\n      let t = {\n        name: \"GlobalAveragePool\",\n        inputNames: [\"X\"],\n        inputTypes: [0],\n        cacheHint: `${o.countIncludePad}`\n      };\n      return [i.run({\n        ...t,\n        get: () => rc(e, t, !0, o)\n      }, e)];\n    }, oc = i => {\n      let e = i.attributes.getInt(\"count_include_pad\", 0) !== 0;\n      return W({\n        autoPad: \"\",\n        ceilMode: 0,\n        countIncludePad: e,\n        kernelShape: [],\n        strides: [],\n        pads: []\n      });\n    }, ic = (i, e, o) => {\n      Gn(e);\n      let t = {\n        name: \"MaxPool\",\n        inputNames: [\"X\"],\n        inputTypes: [0],\n        cacheHint: o.cacheKey\n      };\n      return [i.run({\n        ...t,\n        get: () => sc(e, t, !1, o)\n      }, e)];\n    }, ac = i => {\n      let e = i.attributes.getString(\"auto_pad\", \"NOTSET\"),\n        o = i.attributes.getInt(\"ceil_mode\", 0),\n        t = i.attributes.getInts(\"kernel_shape\"),\n        r = i.attributes.getInts(\"strides\", []),\n        n = i.attributes.getInts(\"pads\", []),\n        s = i.attributes.getInt(\"storage_order\", 0),\n        a = i.attributes.getInts(\"dilations\", []);\n      if (s !== 0) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n      if (o !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n      return W({\n        autoPad: e,\n        ceilMode: o,\n        countIncludePad: !1,\n        kernelShape: t,\n        strides: r,\n        pads: n,\n        storageOrder: s,\n        dilations: a\n      });\n    }, sc = (i, e, o, t) => {\n      let [r, n] = uc(i, t, o),\n        s = `\n      value = max(_X(x), value);\n    `,\n        a = \"\",\n        l = `\n      ${fc(i[0].dims, r, s, a, \"-1e5\")}\n    `;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: i[0].type,\n          textureType: 0\n        },\n        shaderSource: l\n      };\n    }, uc = (i, e, o) => {\n      let t = i[0].dims.slice(),\n        r = Object.hasOwnProperty.call(e, \"dilations\"),\n        n = e.kernelShape.slice(),\n        s = e.strides.slice(),\n        a = r ? e.dilations.slice() : [],\n        u = e.pads.slice();\n      Ue.adjustPoolAttributes(o, t, n, s, a, u);\n      let l = Ue.computePoolOutputShape(o, t, s, a, n, u, e.autoPad),\n        f = Object.assign({}, e);\n      return r ? Object.assign(f, {\n        kernelShape: n,\n        strides: s,\n        pads: u,\n        dilations: a,\n        cacheKey: e.cacheKey\n      }) : Object.assign(f, {\n        kernelShape: n,\n        strides: s,\n        pads: u,\n        cacheKey: e.cacheKey\n      }), [f, l];\n    }, Gb = {\n      autoPad: \"\",\n      ceilMode: 0,\n      countIncludePad: !1,\n      kernelShape: [],\n      strides: [],\n      pads: [],\n      storageOrder: 0,\n      dilations: [],\n      cacheKey: \"\"\n    }, Qf = {\n      name: \"GlobalMaxPool\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, lc = (i, e) => (Gn(e), [i.run({\n      ...Qf,\n      get: () => sc(e, Qf, !0, Gb)\n    }, e)]), Gn = i => {\n      if (!i || i.length !== 1) throw new Error(\"Pool ops requires 1 input.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n    }, fc = (i, e, o, t, r) => {\n      let n = i.length;\n      if (e.kernelShape.length <= 2) {\n        let s = e.kernelShape[e.kernelShape.length - 1],\n          a = e.strides[e.strides.length - 1],\n          u = e.pads[e.pads.length / 2 - 1],\n          l = e.pads[e.pads.length - 1],\n          f = i[n - 1],\n          p = \"\",\n          d = \"\",\n          y = \"\";\n        if (u + l !== 0 ? p = `\n          for (int i = 0; i < ${s}; i++) {\n            x[${n} - 1] = indices[${n} - 1] * ${a} - ${u} + i;\n            if (x[${n} - 1] < 0 || x[${n} - 1] >= ${f}) {\n              pad++;\n              continue;\n            }\n            ${o}\n          }` : p = `\n          for (int i = 0; i < ${s}; i++) {\n            x[${n} - 1] = indices[${n} - 1] * ${a} - ${u} + i;\n            ${o}\n          }`, e.kernelShape.length === 2) {\n          let v = e.kernelShape[e.kernelShape.length - 2],\n            S = e.strides[e.strides.length - 2],\n            L = e.pads[e.pads.length / 2 - 2],\n            P = e.pads[e.pads.length - 2],\n            A = i[n - 2];\n          L + P !== 0 ? d = `\n            for (int j = 0; j < ${v}; j++) {\n              x[${n} - 2] = indices[${n} - 2] * ${S} - ${L} + j;\n              if (x[${n} - 2] < 0 || x[${n} - 2] >= ${A}) {\n                pad+= ${s};\n                continue;\n              }\n          ` : d = `\n            for (int j = 0; j < ${v}; j++) {\n              x[${n} - 2] = indices[${n} - 2] * ${S} - ${L} + j;\n            `, y = `\n          }\n        `;\n        }\n        return `\n        float process(int indices[${n}]) {\n          int x[${n}];\n          copyVec(indices, x);\n\n          float value = ${r};\n          int pad = 0;\n          ${d}\n          ${p}\n          ${y}\n          ${t}\n          return value;\n        }\n      `;\n      } else {\n        let s = B.size(e.kernelShape),\n          a = B.computeStrides(e.kernelShape),\n          u = a.length,\n          l = e.pads.length,\n          f = Mb(u),\n          p = Rn(i, \"inputDims\"),\n          d = Rn(e.pads, \"pads\"),\n          y = Rn(a, \"kernelStrides\"),\n          T = Rn(e.strides, \"strides\"),\n          v = e.pads.reduce((P, A) => P + A),\n          S = \"\";\n        return v ? S = `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${o}\n          }` : S = `\n          }\n          ${o}\n        `, `\n        ${f}\n        float process(int indices[${n}]) {\n          int x[${n}];\n          copyVec(indices, x);\n          int offset[${u}];\n          int pads[${l}];\n          int inputDims[${n}];\n          int kernelStrides[${u}];\n          int strides[${u}];\n          ${d}\n          ${p}\n          ${T}\n          ${y}\n\n          float value = ${r};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${n} - ${u}; j < ${n}; j++) {\n              x[j] = indices[j] * strides[j - ${n} + ${u}]\n                + offset[j - ${n} + ${u}] - pads[j - 2];\n              ${S}\n          }\n          ${t}\n\n          return value;\n        }\n      `;\n      }\n    }, Rn = (i, e) => {\n      let o = \"\";\n      for (let t = 0; t < i.length; t++) o += `\n      ${e}[${t}] = ${i[t]};\n    `;\n      return o;\n    }, Mb = i => `\n  void offsetToIndices(int offset, int[${i}] strides, out int[${i}] indices) {\n    if (${i} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${i} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${i} - 1] = offset;\n  }`;\n  });\nvar Xe,\n  Ee,\n  Ub,\n  Vb,\n  pc,\n  dc,\n  hc,\n  mc,\n  bc,\n  gc,\n  yc,\n  xc = O(() => {\n    \"use strict\";\n\n    It();\n    Rr();\n    Y();\n    j();\n    Xe = (i, e, o, t, r) => {\n      Vb(e);\n      let n = {\n        name: t,\n        inputNames: [\"A\"],\n        inputTypes: [0]\n      };\n      return [i.run({\n        ...n,\n        cacheHint: o.cacheKey,\n        get: () => Ub(i, e, o, t, r, n)\n      }, e)];\n    }, Ee = i => {\n      let e = i.attributes.getInts(\"axes\", []),\n        o = i.attributes.getInt(\"keepdims\", 1) === 1;\n      return W({\n        axes: e,\n        keepDims: o\n      });\n    }, Ub = (i, e, o, t, r, n) => {\n      let s = [],\n        a = e[0].dims.length || 1,\n        u = [],\n        l = B.normalizeAxes(o.axes, e[0].dims.length),\n        f = r(e, l),\n        p = f[1];\n      for (let T = 0; T < e[0].dims.length; T++) l.indexOf(T) >= 0 || l.length === 0 ? (o.keepDims && s.push(1), p = `\n          for(int j${T} = 0; j${T} < ${e[0].dims[T]}; j${T}++) {\n            inputIdx[${T}] = j${T};\n            ${p}\n          }`) : (u.push(`inputIdx[${T}] = outputIdx[${s.length}];`), s.push(e[0].dims[T]));\n      let y = `\n      float process(int outputIdx[${s.length || 1}]) {\n        float value;                 // final result\n        int inputIdx[${a}];      // addressing input data\n        ${u.join(`\n`)}\n        ${f[0]}       // init ops for reduce max/min\n        ${p}\n        ${f[2]}       // final computation for reduce mean\n        return value;\n      }`;\n      return {\n        ...n,\n        output: {\n          dims: s,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: y\n      };\n    }, Vb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Reduce op requires 1 input.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invalid input type.\");\n    }, pc = (i, e, o) => Xe(i, e, o, \"ReduceSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"\"]), dc = (i, e, o) => Xe(i, e, o, \"ReduceMean\", (r, n) => {\n      let s = 1;\n      for (let a = 0; a < r[0].dims.length; a++) (n.indexOf(a) >= 0 || n.length === 0) && (s *= r[0].dims[a]);\n      return [\"value = 0.0;\", \"value += _A(inputIdx);\", `value /= ${s}.;`];\n    }), hc = (i, e, o) => Xe(i, e, o, \"ReduceMax\", (r, n) => {\n      let s = [];\n      for (let a = 0; a < r[0].dims.length; a++) (n.indexOf(a) >= 0 || n.length === 0) && s.push(`inputIdx[${a}] = 0;`);\n      return [`${s.join(`\n`)}\nvalue = _A(inputIdx);`, \"value = max(value, _A(inputIdx));\", \"\"];\n    }), mc = (i, e, o) => Xe(i, e, o, \"ReduceMin\", (r, n) => {\n      let s = [];\n      for (let a = 0; a < r[0].dims.length; a++) (n.indexOf(a) >= 0 || n.length === 0) && s.push(`inputIdx[${a}] = 0;`);\n      return [`${s.join(`\n`)}\nvalue = _A(inputIdx);`, \"value = min(value, _A(inputIdx));\", \"\"];\n    }), bc = (i, e, o) => Xe(i, e, o, \"ReduceProd\", () => [\"value = 1.0;\", \"value *= _A(inputIdx);\", \"\"]), gc = (i, e, o) => Xe(i, e, o, \"ReduceLogSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"value = log(value);\"]), yc = (i, e, o) => Xe(i, e, o, \"ReduceLogSumSquare\", () => [\"float t; value = 0.0;\", \"t = _A(inputIdx); value += t * t;\", \"\"]);\n  });\nvar Tc,\n  wc = O(() => {\n    \"use strict\";\n\n    Y();\n    Tc = (i, e) => {\n      let o = B.calculateReshapedDims(e[0].dims, e[1].integerData);\n      return i.session.pack ? [i.reshapePacked(e[0], o)] : [i.reshapeUnpacked(e[0], o)];\n    };\n  });\nvar vc,\n  Ei,\n  Ic,\n  _c,\n  Gr,\n  zb,\n  Di,\n  Mn,\n  Li = O(() => {\n    \"use strict\";\n\n    It();\n    ut();\n    j();\n    vc = {\n      name: \"Upsample\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, Ei = (i, e, o) => (Di(e, o), [i.run({\n      ...vc,\n      cacheHint: o.cacheKey,\n      get: () => zb(i, e, o)\n    }, e)]), Ic = i => Gr(i, 7), _c = i => Gr(i, 9), Gr = (i, e) => {\n      let o = e >= 10,\n        t = i.attributes.getString(\"mode\", \"nearest\");\n      if (t !== \"nearest\" && t !== \"linear\" && (e < 11 || t !== \"cubic\")) throw new Error(`unrecognized mode: ${t}`);\n      let r = [];\n      e < 9 && (r = i.attributes.getFloats(\"scales\"), Mn(r, t, o));\n      let n = i.attributes.getFloat(\"extrapolation_value\", 0),\n        s = e > 10 ? i.attributes.getString(\"coordinate_transformation_mode\", \"half_pixel\") : \"asymmetric\";\n      if ([\"asymmetric\", \"pytorch_half_pixel\", \"tf_half_pixel_for_nn\", \"align_corners\", \"tf_crop_and_resize\", \"half_pixel\"].indexOf(s) === -1) throw new Error(`coordinate_transform_mode '${s}' is not supported`);\n      let a = s === \"tf_crop_and_resize\",\n        u = a,\n        l = t === \"nearest\" && e >= 11 ? i.attributes.getString(\"nearest_mode\", \"round_prefer_floor\") : \"\";\n      if ([\"round_prefer_floor\", \"round_prefer_ceil\", \"floor\", \"ceil\", \"\"].indexOf(l) === -1) throw new Error(`nearest_mode '${l}' is not supported`);\n      let f = i.attributes.getFloat(\"cubic_coeff_a\", -.75),\n        p = i.attributes.getInt(\"exclude_outside\", 0) !== 0;\n      if (p && t !== \"cubic\") throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");\n      let d = e < 11 ? !0 : t === \"nearest\" && s === \"asymmetric\" && l === \"floor\",\n        y = 0,\n        T = 0,\n        v = 0;\n      return e > 10 ? i.inputs.length > 2 ? (y = 1, T = 2, v = 3) : (T = 1, v = 2) : e === 9 && (T = 1), W({\n        opset: e,\n        isResize: o,\n        mode: t,\n        scales: r,\n        extrapolationValue: n,\n        coordinateTransformMode: s,\n        useExtrapolation: u,\n        needRoiInput: a,\n        nearestMode: l,\n        cubicCoefficientA: f,\n        excludeOutside: p,\n        useNearest2xOptimization: d,\n        roiInputIdx: y,\n        scalesInputIdx: T,\n        sizesInputIdx: v\n      });\n    }, zb = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        [r, n] = i.calculateTextureWidthAndHeight(e[0].dims, 0),\n        s = e[0].dims.map((v, S) => Math.floor(v * o.scales[S])),\n        [a, u] = i.calculateTextureWidthAndHeight(s, 0),\n        l = s.length,\n        f = new Array(l),\n        p = new Array(l),\n        d = `\n      int output_pitches[${l}];\n      int input_pitches[${l}];\n      `;\n      for (let v = l - 1; v >= 0; v--) f[v] = v === l - 1 ? 1 : f[v + 1] * s[v + 1], p[v] = v === l - 1 ? 1 : p[v + 1] * e[0].dims[v + 1], d += `\n        output_pitches[${v}] = ${f[v]};\n        input_pitches[${v}] = ${p[v]};\n        `;\n      let y = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${r}, ${n});\n        float value = getColorAsFloat(${t.texture2D}(X, coords));\n        return value;\n      }\n      `,\n        T = o.mode === \"nearest\" ? `\n    ${y}\n    float process(int indices[${l}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${a}, ${u});\n\n      ${d}\n\n      int d, m;\n      for (int dim = 0; dim < ${l}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }` : l === 4 ? `\n    ${y}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${a}, ${u});\n\n      ${d}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }` : `\n    ${y}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${a}, ${u});\n\n      ${d}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;\n      return {\n        ...vc,\n        output: {\n          dims: s,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: T,\n        variables: [{\n          name: \"scales\",\n          type: \"int\",\n          arrayLength: o.scales.length,\n          data: o.scales.map(v => Math.ceil(v))\n        }]\n      };\n    }, Di = (i, e) => {\n      if (!i || e.opset < 9 && i.length !== 1 || e.opset >= 9 && e.opset < 11 && i.length !== 2 || e.opset >= 11 && i.length < 2) throw new Error(\"invalid inputs.\");\n      if (e.scales.length > 0 && i[0].dims.length !== e.scales.length) throw new Error(\"Invalid input shape.\");\n      if (i[0].type === \"string\") throw new Error(\"Invalid input tensor types.\");\n    }, Mn = (i, e, o) => {\n      if (o) {\n        for (let t of i) if (t <= 0) throw new Error(\"Scale value should be greater than 0.\");\n      } else for (let t of i) if (t < 1) throw new Error(\"Scale value should be greater than or equal to 1.\");\n      if ((e === \"linear\" || e === \"cubic\") && i.length !== 2 && (i.length !== 4 || i[0] !== 1 || i[1] !== 1)) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o ? \"Resize\" : \"Upsample\"} opeartor.`);\n    };\n  });\nvar $i,\n  ki,\n  Oc,\n  Sc,\n  Wb,\n  Hb,\n  qb,\n  jb,\n  Ac = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    Li();\n    $i = {\n      name: \"Resize\",\n      inputNames: [\"A\"],\n      inputTypes: [2]\n    }, ki = (i, e, o) => (Di(e, o), [i.run({\n      ...$i,\n      cacheHint: o.cacheKey,\n      get: () => Wb(i, e, o)\n    }, e)]), Oc = i => Gr(i, 10), Sc = i => Gr(i, 11), Wb = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        [r, n] = Hb(e, o);\n      if (r.every(A => A === 1) && o.coordinateTransformMode !== \"tf_crop_and_resize\") return {\n        ...$i,\n        output: {\n          dims: n,\n          type: e[0].type,\n          textureType: 2\n        },\n        hasMain: !0,\n        shaderSource: `void main() {\n                    vec4 v = ${t.texture2D}(X, TexCoords);\n                    ${t.output} = v;\n                }`\n      };\n      let a = n.length;\n      if (a < 2) throw new Error(`output dimension should be at least 2, but got ${a}`);\n      let u = n[a - 2],\n        l = n[a - 1],\n        f = e[0].dims;\n      if (a !== f.length) throw new Error(`output dimension should match input ${f.length}, but got ${a}`);\n      let p = f[a - 2],\n        d = f[a - 1],\n        y = r[a - 2],\n        T = r[a - 1],\n        v = \"\";\n      if (o.mode !== \"linear\") throw new Error(`resize (packed) does not support mode: '${o.mode}'`);\n      switch (o.coordinateTransformMode) {\n        case \"asymmetric\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;\n          break;\n        case \"half_pixel\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;\n          break;\n        case \"pytorch_half_pixel\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;\n          break;\n        case \"align_corners\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,\n                            ${u}.0 - 1.0);\n                        vec4 original = vec4(${d}.0 - 1.0, ${p}.0 - 1.0, ${d}.0 - 1.0,\n                            ${p}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;\n          break;\n        default:\n          throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`);\n      }\n      let S = Bt(a),\n        L = de(),\n        P = `\n            const vec2 inputWH = vec2(${p}.0, ${d}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${T}), float(${y}), float(${T}));\n            ${L}\n            ${v}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${S} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${u - 1};\n                bool hasNextCol = rc.z < ${l - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${t.output} = vec4(newValue);\n            }\n        `;\n      return {\n        ...$i,\n        output: {\n          dims: n,\n          type: e[0].type,\n          textureType: 2\n        },\n        hasMain: !0,\n        shaderSource: P\n      };\n    }, Hb = (i, e) => {\n      let t = i[0].dims,\n        r = e.scales,\n        n;\n      if (r.length === 0) {\n        let a = i[e.scalesInputIdx];\n        if (a && a.size !== 0) {\n          if (i[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n          r = qb(a, e.mode, e.isResize);\n        } else {\n          let u = i[e.sizesInputIdx];\n          if (!u || u.size === 0) throw new Error(\"Either scales or sizes MUST be provided as input.\");\n          n = Array.from(u.integerData), r = jb(n, t, e.mode, e.isResize);\n        }\n      } else if (i[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n      let s = n || t.map((a, u) => Math.floor(a * r[u]));\n      return [r, s];\n    }, qb = (i, e, o) => {\n      let t = Array.from(i.floatData);\n      return Mn(t, e, o), t;\n    }, jb = (i, e, o, t) => {\n      let r = e.length,\n        n = new Array(r);\n      for (let s = 0, a = r; s < a; s++) if (e[s] === 0) {\n        if (i[s] !== 0) throw new Error(\"Input dim is zero but required output dim is non-zero.\");\n        n[s] = 1;\n      } else n[s] = i[s] / e[s];\n      return Mn(n, o, t), n;\n    };\n  });\nvar Pc,\n  Xb,\n  Ec = O(() => {\n    \"use strict\";\n\n    We();\n    Pc = (i, e) => (Xb(e), [new bt([e[0].dims.length], \"int32\", void 0, void 0, new Int32Array(e[0].dims))]), Xb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Shape requires 1 input.\");\n    };\n  });\nvar Bi,\n  Dc,\n  Lc,\n  $c,\n  Kb,\n  kc,\n  Jb,\n  Yb,\n  Bc = O(() => {\n    \"use strict\";\n\n    It();\n    Rr();\n    Y();\n    j();\n    Bi = {\n      name: \"Slice\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, Dc = (i, e, o) => (Kb(e), [i.run({\n      ...Bi,\n      cacheHint: o.cacheKey,\n      get: () => $c(i, e[0], o)\n    }, e)]), Lc = i => {\n      let e = i.attributes.getInts(\"starts\"),\n        o = i.attributes.getInts(\"ends\"),\n        t = i.attributes.getInts(\"axes\", []);\n      return W({\n        starts: e,\n        ends: o,\n        axes: t\n      });\n    }, $c = (i, e, o) => {\n      let t = o.axes.length === 0 ? e.dims.slice(0).map((p, d) => d) : o.axes,\n        r = B.normalizeAxes(t, e.dims.length),\n        n = o.starts.map((p, d) => p > e.dims[r[d]] - 1 ? e.dims[r[d]] : B.normalizeAxis(p, e.dims[r[d]])),\n        s = o.ends.map((p, d) => p > e.dims[r[d]] - 1 ? e.dims[r[d]] : B.normalizeAxis(p, e.dims[r[d]])),\n        a = e.dims.slice(),\n        u = [];\n      for (let p = 0; p < r.length; p++) a[r[p]] = s[p] - n[p], n[p] > 0 && u.push(`outputIdx[${r[p]}] += ${n[p]};`);\n      let f = `\n      float process(int outputIdx[${a.length}]) {\n        ${u.join(`\n      `)}\n        return _A(outputIdx);\n      }`;\n      return {\n        ...Bi,\n        output: {\n          dims: a,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, Kb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Slice requires 1 input.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invalid input type.\");\n    }, kc = (i, e) => {\n      Yb(e);\n      let o = Jb(i, e);\n      return [i.run({\n        ...Bi,\n        cacheHint: o.cacheKey,\n        get: () => $c(i, e[0], o)\n      }, [e[0]])];\n    }, Jb = (i, e) => {\n      if (!i.session.isInitializer(e[1].dataId) || !i.session.isInitializer(e[2].dataId) || e.length >= 4 && !i.session.isInitializer(e[3].dataId) || e.length >= 5 && !i.session.isInitializer(e[4].dataId)) throw new Error(\"dynamic slice attributes are not allowed\");\n      if (e.length >= 5 && e[4].integerData.some(s => s !== 1)) throw new Error(\"currently non-1 steps is not supported for Slice\");\n      let o = Array.from(e[1].integerData),\n        t = Array.from(e[2].integerData),\n        r = e.length >= 4 ? Array.from(e[3].integerData) : [],\n        n = `${r};${o};${t}`;\n      return {\n        starts: o,\n        ends: t,\n        axes: r,\n        cacheKey: n\n      };\n    }, Yb = i => {\n      if (!i || i.length < 3 || i.length > 5) throw new Error(\"Invalid input number.\");\n      if (i[1].type !== \"int32\" || i[1].dims.length !== 1) throw new Error(\"Invalid input type.\");\n      if (i[2].type !== \"int32\" || i[2].dims.length !== 1) throw new Error(\"Invalid input type.\");\n      if (i.length >= 4 && (i[3].type !== \"int32\" || i[3].dims.length !== 1)) throw new Error(\"Invalid input type.\");\n      if (i.length >= 5 && (i[4].type !== \"int32\" || i[4].dims.length !== 1)) throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Fc,\n  Cc,\n  Nc,\n  Rc,\n  Gc,\n  Mc,\n  Uc,\n  Vc,\n  Zb,\n  Qb,\n  tg,\n  zc,\n  Wc = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    ut();\n    j();\n    Nn();\n    Fc = {\n      name: \"SoftmaxComputeMax\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, Cc = {\n      name: \"SoftmaxComputeScale\",\n      inputNames: [\"A\", \"Max\"],\n      inputTypes: [0, 0]\n    }, Nc = {\n      name: \"SoftMax\",\n      inputNames: [\"A\", \"Max\", \"Norm\"],\n      inputTypes: [0, 0, 0]\n    }, Rc = (i, e, o) => {\n      zc(e);\n      let t = e[0].dims.slice(),\n        r = B.normalizeAxis(o.axis, t.length),\n        n = B.sizeToDimension(t, r),\n        s = B.sizeFromDimension(t, r);\n      return Vc(i, e, o, n, s);\n    }, Gc = i => W({\n      axis: i.attributes.getInt(\"axis\", 1)\n    }), Mc = i => W({\n      axis: i.attributes.getInt(\"axis\", -1)\n    }), Uc = (i, e, o) => {\n      zc(e);\n      let t = e[0].dims.slice(),\n        r = B.normalizeAxis(o.axis, t.length),\n        n = t.length,\n        s = r !== n - 1,\n        a = [],\n        u = [],\n        l = [],\n        f;\n      s && (u = Array.from({\n        length: n\n      }).map((T, v) => v), u[r] = n - 1, u[n - 1] = r, u.map(T => a.push(t[T])), f = W({\n        perm: u\n      }), l = je(i, e, f));\n      let p = s ? B.sizeToDimension(a, n - 1) : B.sizeToDimension(t, n - 1),\n        d = s ? B.sizeFromDimension(a, n - 1) : B.sizeFromDimension(t, n - 1),\n        y = Vc(i, s ? l : e, o, p, d);\n      return s ? je(i, y, f) : y;\n    }, Vc = (i, e, o, t, r) => {\n      let n = Zb(i, e[0], t, r, [t]),\n        s = i.run({\n          ...Fc,\n          cacheHint: o.cacheKey,\n          get: () => n\n        }, e),\n        a = Qb(i, e[0], t, r, n.output.dims, [t]),\n        u = i.run({\n          ...Cc,\n          cacheHint: o.cacheKey,\n          get: () => a\n        }, [e[0], s]),\n        l = tg(i, e[0], t, r, n.output.dims, a.output.dims);\n      return [i.run({\n        ...Nc,\n        cacheHint: o.cacheKey,\n        get: () => l\n      }, [e[0], s, u])];\n    }, Zb = (i, e, o, t, r) => {\n      let [n, s] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        a = r.length;\n      if (o < 1 || t < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n      if (r.length !== 1) throw new Error(\"Dimensionality of the output should be 1\");\n      if (r[0] !== o) throw new Error(\"Shape of the output should be equal to logical row count\");\n      let u = G(i.session.backend.glContext.version),\n        l = `\n      float process(int[${a}] indices) {\n        int logical_row_start_offset = indices[0] * ${t};\n\n        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n},\n        ${s} )));\n        for(int i=1; i<${t}; ++i)\n        {\n          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${n}, ${s})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;\n      return {\n        ...Fc,\n        output: {\n          dims: r,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: l\n      };\n    }, Qb = (i, e, o, t, r, n) => {\n      let [s, a] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        u = n.length;\n      if (o < 1 || t < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n      if (n.length !== 1) throw new Error(\"Dimensionality of the output should be 1\");\n      if (n[0] !== o) throw new Error(\"Shape of the output should be equal to logical row count\");\n      if (r.length !== 1) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n      if (r[0] !== o) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n      let l = G(i.session.backend.glContext.version),\n        f = `\n      float process(int[${u}] indices) {\n        int logical_row_start_offset = indices[0] * ${t};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${t}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${a}))) - max);\n        }\n\n        return norm_factor;\n      }`;\n      return {\n        ...Cc,\n        output: {\n          dims: n,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, tg = (i, e, o, t, r, n) => {\n      let [s, a] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        u = e.dims.length;\n      if (o < 1 || t < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n      if (r.length !== 1 || n.length !== 1) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n      if (r[0] !== o || n[0] !== o) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n      let l = `\n      float process(int[${u}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${a});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${t};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;\n      return {\n        ...Nc,\n        output: {\n          dims: e.dims,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: l\n      };\n    }, zc = i => {\n      if (!i || i.length !== 1) throw new Error(\"Softmax requires 1 input.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type\");\n    };\n  });\nvar Hc,\n  qc,\n  jc,\n  eg,\n  rg,\n  ng,\n  Xc = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    Hc = {\n      name: \"Split\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, qc = (i, e, o) => {\n      ng(e);\n      let t = B.normalizeAxis(o.axis, e[0].dims.length),\n        r = eg(i, e, t, o),\n        n = [];\n      for (let s = 0; s < r; ++s) n.push(i.run({\n        ...Hc,\n        cacheHint: `${o.cacheKey};${s}`,\n        get: () => rg(i, e[0], o, t, s)\n      }, e));\n      return n;\n    }, jc = i => {\n      let e = i.attributes.getInt(\"axis\", 0),\n        o = i.attributes.getInts(\"split\", []),\n        t = i.outputs.length;\n      return W({\n        axis: e,\n        split: o,\n        numOutputs: t\n      });\n    }, eg = (i, e, o, t) => {\n      let [, r] = $r.splitShape(e[0].dims, o, t.split, t.numOutputs);\n      return r.length;\n    }, rg = (i, e, o, t, r) => {\n      let [n, s] = $r.splitShape(e.dims, t, o.split, o.numOutputs),\n        a = s[r],\n        u = n[r],\n        f = `\n      float process(int indices[${u.length}]) {\n        indices[${t}] += ${a};\n        return _A(indices);\n      }\n    `;\n      return {\n        ...Hc,\n        cacheHint: `${o.cacheKey}:${r}`,\n        output: {\n          dims: u,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, ng = i => {\n      if (!i || i.length !== 1) throw new Error(\"Split requires one input.\");\n      if (i[0].type !== \"int8\" && i[0].type !== \"uint8\" && i[0].type !== \"int16\" && i[0].type !== \"uint16\" && i[0].type !== \"int32\" && i[0].type !== \"uint32\" && i[0].type !== \"float32\" && i[0].type !== \"float64\" && i[0].type !== \"bool\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Fi,\n  Kc,\n  Jc,\n  og,\n  ig,\n  Yc = O(() => {\n    \"use strict\";\n\n    Y();\n    Fi = (i, e, o) => {\n      og(e);\n      let t = B.squeezeShape(e[0].dims, o);\n      return [i.reshapeUnpacked(e[0], t)];\n    }, Kc = (i, e) => (ig(e), Fi(i, [e[0]], Array.from(e[1].integerData))), Jc = i => i.attributes.getInts(\"axes\"), og = i => {\n      if (!i || i.length !== 1) throw new Error(\"Squeeze requires 1 input.\");\n      if (i[0].type === \"string\") throw new Error(\"invalid input tensor types.\");\n    }, ig = i => {\n      if (!i || i.length !== 2) throw new Error(\"Squeeze requires 2 inputs.\");\n      if (i[1].type !== \"int32\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Zc,\n  ag,\n  sg,\n  Qc = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    Zc = (i, e) => {\n      sg(e);\n      let o = {\n        name: \"Sum\",\n        inputNames: e.map((r, n) => `X${n}`),\n        inputTypes: new Array(e.length).fill(0)\n      };\n      return [i.run({\n        ...o,\n        get: () => ag(i, e, o)\n      }, e)];\n    }, ag = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        r = e[0].dims.slice(),\n        s = `\n      void main() {\n        vec4 result = ${e.map((a, u) => `${t.texture2D}(X${u},TexCoords)`).join(\" + \")};\n        ${t.output} = result;\n      }\n    `;\n      return {\n        ...o,\n        output: {\n          dims: r,\n          type: e[0].type,\n          textureType: 0\n        },\n        hasMain: !0,\n        shaderSource: s\n      };\n    }, sg = i => {\n      if (!i || i.length === 0) throw new Error(\"Sum requires inputs.\");\n      let e = i[0].dims.length;\n      for (let o = 1; o < i.length; o++) {\n        if (e !== i[o].dims.length) throw new Error(\"Input shapes are mismatched.\");\n        for (let t = 0; t < e; t++) if (i[0].dims[t] !== i[o].dims[t]) throw new Error(\"Input shapes are not matched.\");\n      }\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n      for (let o = 1; o < i.length; o++) if (i[0].type !== i[o].type) throw new Error(\"Input types are not matched.\");\n    };\n  });\nvar tp,\n  ug,\n  lg,\n  ep = O(() => {\n    \"use strict\";\n\n    Rr();\n    j();\n    tp = (i, e) => {\n      lg(e);\n      let o = {\n        name: \"Tile\",\n        inputNames: [\"A\"],\n        inputTypes: [0]\n      };\n      return [i.run({\n        ...o,\n        get: () => ug(i, e, o)\n      }, e)];\n    }, ug = (i, e, o) => {\n      let t = e[0].dims.slice(),\n        r = new Array(t.length),\n        n = [];\n      for (let u = 0; u < t.length; u++) r[u] = t[u] * e[1].numberData[u], n.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${t[u]}.));`);\n      let s = r.length,\n        a = `\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${n.join(`\n`)}\n        return _A(inputIdx);\n      }\n    `;\n      return {\n        ...o,\n        output: {\n          dims: r,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: a\n      };\n    }, lg = i => {\n      if (!i || i.length !== 2) throw new Error(\"Tile requires 2 input.\");\n      if (i[1].dims.length !== 1) throw new Error(\"The second input shape must 1 dimension.\");\n      if (i[1].dims[0] !== i[0].dims.length) throw new Error(\"Invalid input shape.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invalid input type.\");\n      if (i[1].type !== \"int32\" && i[1].type !== \"int16\") throw new Error(\"Invalid repeat type.\");\n    };\n  });\nvar Ci,\n  rp,\n  np,\n  fg,\n  cg,\n  op = O(() => {\n    \"use strict\";\n\n    Y();\n    Ci = (i, e, o) => {\n      fg(e);\n      let t = B.unsqueezeShape(e[0].dims, o);\n      return [i.reshapeUnpacked(e[0], t)];\n    }, rp = (i, e) => (cg(e), Ci(i, [e[0]], Array.from(e[1].integerData))), np = i => i.attributes.getInts(\"axes\"), fg = i => {\n      if (!i || i.length !== 1) throw new Error(\"Unsqueeze requires 1 input.\");\n      if (i[0].type === \"string\") throw new Error(\"invalid input tensor types.\");\n    }, cg = i => {\n      if (!i || i.length !== 2) throw new Error(\"Unsqueeze requires 2 inputs.\");\n      if (i[1].type !== \"int32\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar ip,\n  ap = O(() => {\n    \"use strict\";\n\n    ml();\n    Pl();\n    Ll();\n    Nl();\n    Bn();\n    wf();\n    Af();\n    Df();\n    kf();\n    Nf();\n    Mf();\n    Wf();\n    Xf();\n    Fn();\n    Zf();\n    cc();\n    xc();\n    wc();\n    Ac();\n    Ec();\n    Bc();\n    Wc();\n    Xc();\n    Yc();\n    Qc();\n    ep();\n    Nn();\n    xi();\n    op();\n    Li();\n    ip = [[\"Abs\", \"\", \"6+\", Rl], [\"Acos\", \"\", \"7+\", Gl], [\"Add\", \"\", \"7+\", bl], [\"And\", \"\", \"7+\", gl], [\"Asin\", \"\", \"7+\", Ml], [\"Atan\", \"\", \"7+\", Ul], [\"AveragePool\", \"\", \"7+\", tc, ec], [\"BatchNormalization\", \"\", \"7+\", dl, hl], [\"Cast\", \"\", \"6+\", El, Dl], [\"Ceil\", \"\", \"6+\", Wl], [\"Clip\", \"\", \"6-10\", gi, Vl], [\"Clip\", \"\", \"11+\", zl], [\"Concat\", \"\", \"4+\", Bl, Cl], [\"Conv\", \"\", \"1+\", Oi, Si], [\"ConvTranspose\", \"\", \"1+\", xf, Tf], [\"Cos\", \"\", \"7+\", Hl], [\"Div\", \"\", \"7+\", yl], [\"Dropout\", \"\", \"7+\", yi], [\"DepthToSpace\", \"\", \"1+\", Of, Sf], [\"Equal\", \"\", \"7+\", xl], [\"Elu\", \"\", \"6+\", ql, jl], [\"Exp\", \"\", \"6+\", Xl], [\"Flatten\", \"\", \"1+\", Pf, Ef], [\"Floor\", \"\", \"6+\", Kl], [\"FusedConv\", \"com.microsoft\", \"1+\", Oi, Si], [\"Gather\", \"\", \"1+\", Lf, $f], [\"Gemm\", \"\", \"7-10\", Ai, Ff], [\"Gemm\", \"\", \"11+\", Ai, Cf], [\"GlobalAveragePool\", \"\", \"1+\", nc, oc], [\"GlobalMaxPool\", \"\", \"1+\", lc], [\"Greater\", \"\", \"7+\", Tl], [\"Identity\", \"\", \"1+\", yi], [\"ImageScaler\", \"\", \"1+\", Rf, Gf], [\"InstanceNormalization\", \"\", \"6+\", Vf, zf], [\"LeakyRelu\", \"\", \"6+\", Jl, Yl], [\"Less\", \"\", \"7+\", wl], [\"LRN\", \"\", \"1+\", Hf, qf], [\"Log\", \"\", \"6+\", Zl], [\"MatMul\", \"\", \"1+\", pf, df], [\"MaxPool\", \"\", \"1+\", ic, ac], [\"Mul\", \"\", \"7+\", vl], [\"Neg\", \"\", \"6+\", Ql], [\"Not\", \"\", \"1+\", tf], [\"Or\", \"\", \"7+\", Il], [\"Pad\", \"\", \"2-10\", Pi, Kf], [\"Pad\", \"\", \"11+\", Jf, Yf], [\"Pow\", \"\", \"7+\", _l], [\"PRelu\", \"\", \"7+\", Ol], [\"ReduceLogSum\", \"\", \"1+\", gc, Ee], [\"ReduceMax\", \"\", \"1+\", hc, Ee], [\"ReduceMean\", \"\", \"1+\", dc, Ee], [\"ReduceMin\", \"\", \"1+\", mc, Ee], [\"ReduceProd\", \"\", \"1+\", bc, Ee], [\"ReduceSum\", \"\", \"1-12\", pc, Ee], [\"ReduceSumSquare\", \"\", \"1+\", yc, Ee], [\"Relu\", \"\", \"6+\", ef], [\"Reshape\", \"\", \"5+\", Tc], [\"Resize\", \"\", \"10\", ki, Oc], [\"Resize\", \"\", \"11+\", ki, Sc], [\"Shape\", \"\", \"1+\", Pc], [\"Sigmoid\", \"\", \"6+\", rf], [\"Sin\", \"\", \"7+\", nf], [\"Slice\", \"\", \"10+\", kc], [\"Slice\", \"\", \"1-9\", Dc, Lc], [\"Softmax\", \"\", \"1-12\", Rc, Gc], [\"Softmax\", \"\", \"13+\", Uc, Mc], [\"Split\", \"\", \"2-12\", qc, jc], [\"Sqrt\", \"\", \"6+\", of], [\"Squeeze\", \"\", \"1-12\", Fi, Jc], [\"Squeeze\", \"\", \"13+\", Kc], [\"Sub\", \"\", \"7+\", Sl], [\"Sum\", \"\", \"6+\", Zc], [\"Tan\", \"\", \"7+\", af], [\"Tanh\", \"\", \"6+\", sf], [\"Tile\", \"\", \"6+\", tp], [\"Transpose\", \"\", \"1+\", je, If], [\"Upsample\", \"\", \"7-8\", Ei, Ic], [\"Upsample\", \"\", \"9\", Ei, _c], [\"Unsqueeze\", \"\", \"1-12\", Ci, np], [\"Unsqueeze\", \"\", \"13+\", rp], [\"Xor\", \"\", \"7+\", Al]];\n  });\nfunction up(i) {\n  let e = {},\n    o;\n  for (; (o = sp.exec(i)) !== null;) {\n    let t = o[3].split(\",\").map(r => {\n      let n = r.trim().split(\" \");\n      return n && n.length === 2 ? {\n        type: n[0],\n        name: n[1]\n      } : null;\n    }).filter(r => r !== null);\n    e[o[2]] = {\n      params: t,\n      body: o[4]\n    };\n  }\n  for (let t in e) {\n    let r = pg.replace(\"__FUNC__\", t),\n      n = new RegExp(r, \"gm\");\n    for (; (o = n.exec(i)) !== null;) {\n      let s = o[1],\n        a = o[2],\n        u = o[3].split(\",\"),\n        l = s ? `${s} ${a};` : \"\",\n        f = e[t].body,\n        p = \"\";\n      e[t].params.forEach((y, T) => {\n        y && (p += `${y.type} ${y.name} = ${u[T]};\n`);\n      }), f = `${p}\n ${f}`, f = f.replace(\"return\", `${a} = `);\n      let d = `\n      ${l}\n      {\n        ${f}\n      }\n      `;\n      i = i.replace(o[0], d);\n    }\n  }\n  return i = i.replace(sp, \"\"), i;\n}\nvar sp,\n  pg,\n  lp = O(() => {\n    \"use strict\";\n\n    sp = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm, pg = \"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\";\n  });\nfunction hr(i, e) {\n  let o = [],\n    t = [],\n    r = e != null && Array.isArray(e) && e.length === 0,\n    n = e == null || r ? null : dg(e, i).sort(),\n    s = 0;\n  for (let a = 0; a < i.length; ++a) {\n    if (n != null) {\n      if (n[s] === a && i[a] !== 1) throw new Error(`Can't squeeze axis ${a} since its dim '${i[a]}' is not 1`);\n      (n[s] == null || n[s] > a) && i[a] === 1 && (o.push(i[a]), t.push(a)), n[s] <= a && s++;\n    }\n    i[a] !== 1 && (o.push(i[a]), t.push(a));\n  }\n  return {\n    newShape: o,\n    keptDims: t\n  };\n}\nfunction dg(i, e) {\n  let o = e.length;\n  return i = i == null ? e.map((t, r) => r) : [].concat(i), ur(i.every(t => t >= -o && t < o), () => `All values in axis param must be in range [-${o}, ${o}) but got axis ${i}`), ur(i.every(hg), () => `All values in axis param must be integers but got axis ${i}`), i.map(t => t < 0 ? o + t : t);\n}\nfunction hg(i) {\n  return i % 1 === 0;\n}\nfunction mg(i) {\n  if (i.length === 0) return 1;\n  let e = i[0];\n  for (let o = 1; o < i.length; o++) e *= i[o];\n  return e;\n}\nfunction fp(i) {\n  let e = Math.ceil(Math.sqrt(i));\n  return [e, Math.ceil(i / e)];\n}\nvar Un,\n  Ni = O(() => {\n    \"use strict\";\n\n    Ut();\n    Y();\n    Un = class {\n      constructor(e) {\n        this.maxTextureSize = e;\n      }\n      computeTextureWH(e, o) {\n        let t = this.computeTexture(e, o);\n        return o && o.isPacked && (t[0] /= 2, t[1] /= 2), o && o.reverseWH ? [t[1], t[0]] : t;\n      }\n      computeTexture(e, o) {\n        let t = o && o.isPacked;\n        if (e.length === 0) return t ? [2, 2] : [1, 1];\n        let r = this.maxTextureSize;\n        if (o && o.breakAxis !== void 0) {\n          let a = o.breakAxis >= e.length ? 1 : e.slice(o.breakAxis).reduce((l, f) => l * f),\n            u = o.breakAxis <= 0 ? 1 : e.slice(0, o.breakAxis).reduce((l, f) => l * f);\n          if (a > r || u > r) tt.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${e}, breakAxis:${o.breakAxis}`);else return [a, u];\n        }\n        let n = e.slice(0);\n        t && (r = r * 2, n = n.map((a, u) => u >= n.length - 2 ? n[u] % 2 === 0 ? n[u] : n[u] + 1 : n[u]), n.length === 1 && (n = [2, n[0]])), n.length !== 2 && (n = hr(n).newShape);\n        let s = mg(n);\n        return n.length <= 1 && s <= r ? [1, s] : n.length === 2 && n[0] <= r && n[1] <= r ? n : n.length === 3 && n[0] * n[1] <= r && n[2] <= r ? [n[0] * n[1], n[2]] : n.length === 3 && n[0] <= r && n[1] * n[2] <= r ? [n[0], n[1] * n[2]] : n.length === 4 && n[0] * n[1] * n[2] <= r && n[3] <= r ? [n[0] * n[1] * n[2], n[3]] : n.length === 4 && n[0] <= r && n[1] * n[2] * n[3] <= r ? [n[0], n[1] * n[2] * n[3]] : t ? fp(s / 4).map(a => a * 2) : fp(s);\n      }\n    };\n  });\nvar Vn,\n  cp = O(() => {\n    \"use strict\";\n\n    Y();\n    Te();\n    ut();\n    Ni();\n    pe();\n    Vn = class extends Ht {\n      constructor(o) {\n        super(o);\n      }\n      getFunctions() {\n        return {\n          ...this.offsetToCoords(),\n          ...this.coordsToOffset(),\n          ...this.toVec(),\n          ...this.valueFrom(),\n          ...this.getCommonUtilFuncs(),\n          ...this.getInputsSamplingSnippets(),\n          ...this.getOutputSamplingSnippet()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      offsetToCoords() {\n        let o = \"offsetToCoords\";\n        return {\n          offsetToCoords: new k(`\n      vec2 ${o}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `)\n        };\n      }\n      coordsToOffset() {\n        let o = \"coordsToOffset\";\n        return {\n          coordsToOffset: new k(`\n      int ${o}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `)\n        };\n      }\n      getOutputSamplingSnippet() {\n        let o = this.context.outputTextureLayout;\n        return o.isPacked ? this.getPackedOutputSamplingSnippet(o) : this.getUnpackedOutputSamplingSnippet(o);\n      }\n      getPackedOutputSamplingSnippet(o) {\n        let t = o.unpackedShape,\n          r = [o.width, o.height],\n          n = {},\n          s = \"getOutputCoords\";\n        switch (t.length) {\n          case 0:\n            n[s] = this.getOutputScalarCoords();\n            break;\n          case 1:\n            n[s] = this.getOutputPacked1DCoords(t, r);\n            break;\n          case 2:\n            n[s] = this.getOutputPacked2DCoords(t, r);\n            break;\n          case 3:\n            n[s] = this.getOutputPacked3DCoords(t, r);\n            break;\n          default:\n            n[s] = this.getOutputPackedNDCoords(t, r);\n        }\n        let u = `\n      void setOutput(vec4 val) {\n        ${G(this.context.glContext.version).output} = val;\n      }\n    `,\n          l = \"floatTextureSetRGBA\";\n        return n[l] = new k(u), n;\n      }\n      getUnpackedOutputSamplingSnippet(o) {\n        let t = o.unpackedShape,\n          r = [o.width, o.height],\n          n = {},\n          s = \"getOutputCoords\";\n        switch (t.length) {\n          case 0:\n            n[s] = this.getOutputScalarCoords();\n            break;\n          case 1:\n            n[s] = this.getOutputUnpacked1DCoords(t, r);\n            break;\n          case 2:\n            n[s] = this.getOutputUnpacked2DCoords(t, r);\n            break;\n          case 3:\n            n[s] = this.getOutputUnpacked3DCoords(t, r);\n            break;\n          case 4:\n            n[s] = this.getOutputUnpacked4DCoords(t, r);\n            break;\n          case 5:\n            n[s] = this.getOutputUnpacked5DCoords(t, r);\n            break;\n          case 6:\n            n[s] = this.getOutputUnpacked6DCoords(t, r);\n            break;\n          default:\n            throw new Error(`Unsupported output dimensionality: ${t.length}`);\n        }\n        let u = `\n        void setOutput(float val) {\n          ${G(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `,\n          l = \"floatTextureSetR\";\n        return n[l] = new k(u), n;\n      }\n      getOutputScalarCoords() {\n        return new k(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `);\n      }\n      getOutputPacked1DCoords(o, t) {\n        let r = t,\n          n = \"\";\n        return r[0] === 1 ? (n = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${r[1]}.0);\n          }\n        `, new k(n)) : r[1] === 1 ? (n = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${r[0]}.0);\n          }\n        `, new k(n)) : (n = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${r[0]}, ${r[1]}));\n          return 2 * (resTexRC.y * ${r[0]} + resTexRC.x);\n        }\n      `, new k(n));\n      }\n      getOutputPacked2DCoords(o, t) {\n        let r = \"\";\n        if (Me.arraysEqual(o, t)) return r = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `, new k(r);\n        let n = t,\n          s = Math.ceil(o[1] / 2);\n        return r = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${s}) * 2;\n          int c = 2 * (index / ${s});\n\n          return ivec2(r, c);\n        }\n      `, new k(r);\n      }\n      getOutputPacked3DCoords(o, t) {\n        let r = [t[0], t[1]],\n          n = Math.ceil(o[2] / 2),\n          s = n * Math.ceil(o[1] / 2),\n          a = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${r[0]}, ${r[1]}));\n          int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n          int b = index / ${s};\n          index -= b * ${s};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${n}) * 2;\n          int c = 2 * (index / ${n});\n\n          return ivec3(b, r, c);\n        }\n      `;\n        return new k(a);\n      }\n      getOutputPackedNDCoords(o, t) {\n        let r = [t[0], t[1]],\n          n = Math.ceil(o[o.length - 1] / 2),\n          s = n * Math.ceil(o[o.length - 2] / 2),\n          a = s,\n          u = \"\",\n          l = \"b, r, c\";\n        for (let p = 2; p < o.length - 1; p++) a *= o[o.length - p - 1], u = `\n      int b${p} = index / ${a};\n      index -= b${p} * ${a};\n    ` + u, l = `b${p}, ` + l;\n        let f = `\n      ivec${o.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${r[0]}, ${r[1]}));\n        int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n        ${u}\n\n        int b = index / ${s};\n        index -= b * ${s};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${n}) * 2;\n        int c = 2 * (index / ${n});\n\n        return ivec${o.length}(${l});\n      }\n    `;\n        return new k(f);\n      }\n      getOutputUnpacked1DCoords(o, t) {\n        let r = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;\n        return new k(r);\n      }\n      getOutputUnpacked2DCoords(o, t) {\n        let r = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${o[1]};\n          int c = index - r * ${o[1]};\n          return ivec2(r, c);\n        }\n      `;\n        return new k(r);\n      }\n      getOutputUnpacked3DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${u}\n          return ivec3(r, c, d);\n        }\n      `, new k(r);\n      }\n      getOutputUnpacked4DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\", \"d2\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${u}\n          return ivec4(r, c, d, d2);\n        }\n      `, new k(r);\n      }\n      getOutputUnpacked5DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\", \"d2\", \"d3\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${u}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `, new k(r);\n      }\n      getOutputUnpacked6DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\", \"d2\", \"d3\", \"d4\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${u}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `, new k(r);\n      }\n      getCommonUtilFuncs() {\n        let o = {},\n          t = \"uvFromFlat\";\n        o[t] = new k(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `), t = \"packedUVfrom1D\", o[t] = new k(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `), t = \"packedUVfrom2D\", o[t] = new k(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `), t = \"packedUVfrom3D\", o[t] = new k(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `), t = \"sampleTexture\";\n        let r = G(this.context.glContext.version);\n        return o[t] = new k(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${r.texture2D}(textureSampler, uv).r;\n        }`), o;\n      }\n      getInputsSamplingSnippets() {\n        let o = {},\n          t = this.context.outputTextureLayout;\n        return this.context.programInfo.inputNames.forEach((r, n) => {\n          let s = this.context.inputTextureLayouts[n],\n            a = An(r);\n          s.isPacked ? o[a] = this.getPackedSamplerFromInput(a, r, s) : o[a] = this.getUnpackedSamplerFromInput(a, r, s);\n          let u = Yu(r);\n          s.unpackedShape.length <= t.unpackedShape.length && (s.isPacked ? o[u] = this.getPackedSamplerAtOutputCoords(u, s, t, r) : o[u] = this.getUnpackedSamplerAtOutputCoords(u, s, t, r));\n        }), o;\n      }\n      getPackedSamplerAtOutputCoords(o, t, r, n) {\n        let s = t.unpackedShape,\n          a = r.unpackedShape,\n          l = An(n),\n          f = s.length,\n          p = a.length,\n          d = kt.getBroadcastDims(s, a),\n          y = Bt(p),\n          T = p - f,\n          v,\n          S = ne();\n        f === 0 ? v = \"\" : p < 2 && d.length >= 1 ? v = \"coords = 0;\" : v = d.map(Dt => `coords.${S[Dt + T]} = 0;`).join(`\n`);\n        let L = \"\";\n        p < 2 && f > 0 ? L = \"coords\" : L = s.map((Dt, _t) => `coords.${S[_t + T]}`).join(\", \");\n        let P = \"return outputValue;\",\n          M = B.size(s) === 1,\n          lt = B.size(a) === 1;\n        if (f === 1 && !M && !lt) P = `\n        return vec4(outputValue.xy, outputValue.xy);\n      `;else if (M && !lt) p === 1 ? P = `\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ` : P = `\n          return vec4(outputValue.x);\n        `;else if (d.length) {\n          let Dt = f - 2,\n            _t = f - 1;\n          d.indexOf(Dt) > -1 && d.indexOf(_t) > -1 ? P = \"return vec4(outputValue.x);\" : d.indexOf(Dt) > -1 ? P = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : d.indexOf(_t) > -1 && (P = \"return vec4(outputValue.xx, outputValue.zz);\");\n        }\n        let wt = `\n        int lastDim = coords.${S[p - 1]};\n        coords.${S[p - 1]} = coords.${S[p - 2]};\n        coords.${S[p - 2]} = lastDim;\n      `,\n          et = `\n      vec4 ${o}() {\n        ${y} coords = getOutputCoords();\n        ${wt}\n        ${v}\n        vec4 outputValue = ${l}(${L});\n        ${P}\n      }\n    `;\n        return new k(et, [\"coordinates.getOutputCoords\"]);\n      }\n      getUnpackedSamplerAtOutputCoords(o, t, r, n) {\n        let s = [r.width, r.height],\n          a = [t.width, t.height],\n          u = t.unpackedShape.length,\n          l = r.unpackedShape.length,\n          f = t.unpackedShape,\n          p = r.unpackedShape,\n          d = An(n);\n        if (u === l && Me.arraysEqual(a, s)) {\n          let M = `\n          float ${o}() {\n            return sampleTexture(${n}, TexCoords);\n          }\n        `;\n          return new k(M, [\"coordinates.sampleTexture\"]);\n        }\n        let y = Bt(l),\n          T = kt.getBroadcastDims(f, p),\n          v = l - u,\n          S,\n          L = ne();\n        u === 0 ? S = \"\" : l < 2 && T.length >= 1 ? S = \"coords = 0;\" : S = T.map(M => `coords.${L[M + v]} = 0;`).join(`\n`);\n        let P = \"\";\n        l < 2 && u > 0 ? P = \"coords\" : P = t.unpackedShape.map((M, V) => `coords.${L[V + v]}`).join(\", \");\n        let A = `\n        float ${o}() {\n          ${y} coords = getOutputCoords();\n          ${S}\n          return ${d}(${P});\n        }\n      `;\n        return new k(A, [\"coordinates.getOutputCoords\"]);\n      }\n      getPackedSamplerFromInput(o, t, r) {\n        switch (r.unpackedShape.length) {\n          case 0:\n            return this.getPackedSamplerScalar(o, t);\n          case 1:\n            return this.getPackedSampler1D(o, t, r);\n          case 2:\n            return this.getPackedSampler2D(o, t, r);\n          case 3:\n            return this.getPackedSampler3D(o, t, r);\n          default:\n            return this.getPackedSamplerND(o, t, r);\n        }\n      }\n      getUnpackedSamplerFromInput(o, t, r) {\n        let n = r.unpackedShape;\n        switch (n.length) {\n          case 0:\n            return this.getUnpackedSamplerScalar(o, t, r);\n          case 1:\n            return this.getUnpackedSampler1D(o, t, r);\n          case 2:\n            return this.getUnpackedSampler2D(o, t, r);\n          case 3:\n            return this.getUnpackedSampler3D(o, t, r);\n          case 4:\n            return this.getUnpackedSampler4D(o, t, r);\n          case 5:\n            return this.getUnpackedSampler5D(o, t, r);\n          case 6:\n            return this.getUnpackedSampler6D(o, t, r);\n          default:\n            throw new Error(`Unsupported dimension ${n.length}-D`);\n        }\n      }\n      getPackedSamplerScalar(o, t) {\n        let r = G(this.context.glContext.version),\n          n = `\n          vec4 ${o}() {\n            return ${r.texture2D}(${t}, halfCR);\n          }\n        `;\n        return new k(n);\n      }\n      getPackedSampler1D(o, t, r) {\n        let n = [r.width, r.height],\n          s = [n[1], n[0]],\n          a = G(this.context.glContext.version),\n          l = `vec4 ${o}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }`;\n        return new k(l, [\"coordinates.packedUVfrom1D\"]);\n      }\n      getPackedSampler2D(o, t, r) {\n        let n = r.unpackedShape,\n          s = [r.width, r.height],\n          a = G(this.context.glContext.version),\n          u = s[0],\n          l = s[1];\n        if (s != null && Me.arraysEqual(n, s)) {\n          let T = `vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n        return ${a.texture2D}(${t}, uv);\n      }`;\n          return new k(T);\n        }\n        let f = s,\n          p = Math.ceil(n[1] / 2),\n          y = `vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${f[1]}, ${f[0]}, ${p}, row, col);\n      return ${a.texture2D}(${t}, uv);\n    }`;\n        return new k(y, [\"coordinates.packedUVfrom2D\"]);\n      }\n      getPackedSampler3D(o, t, r) {\n        let n = r.unpackedShape,\n          s = [r.width, r.height],\n          a = [s[0], s[1]],\n          u = G(this.context.glContext.version);\n        if (n[0] === 1) {\n          let v = n.slice(1),\n            S = [1, 2],\n            L = lr(n, v),\n            P = [\"b\", \"row\", \"col\"],\n            A = JSON.parse(JSON.stringify(r));\n          A.unpackedShape = L;\n          let M = this.getPackedSamplerFromInput(o, t, A),\n            lt = `${M.routineBody}\n      vec4 ${o}(int b, int row, int col) {\n        return ${o}(${fr(P, S)});\n      } `;\n          return new k(lt, M.dependencies);\n        }\n        let l = a[0],\n          f = a[1],\n          p = Math.ceil(n[2] / 2),\n          d = p * Math.ceil(n[1] / 2),\n          T = `vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${f}, ${l}, ${d}, ${p}, b, row, col);\n      return ${u.texture2D}(${t}, uv);}`;\n        return new k(T, [\"coordinates.packedUVfrom3D\"]);\n      }\n      getPackedSamplerND(o, t, r) {\n        let n = r.unpackedShape,\n          s = n.length,\n          a = [r.width, r.height],\n          u = G(this.context.glContext.version),\n          l = [a[0], a[1]],\n          f = l[1],\n          p = l[0],\n          d = Math.ceil(n[s - 1] / 2),\n          y = d * Math.ceil(n[s - 2] / 2),\n          T = \"int b, int row, int col\",\n          v = `b * ${y} + (row / 2) * ${d} + (col / 2)`;\n        for (let P = 2; P < s - 1; P++) T = `int b${P}, ` + T, y *= n[s - P - 1], v = `b${P} * ${y} + ` + v;\n        let L = `vec4 ${o}(${T}) {\n      int index = ${v};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${f});\n      return ${u.texture2D}(${t}, uv);\n    }`;\n        return new k(L);\n      }\n      getUnpackedSamplerScalar(o, t, r) {\n        let [n, s] = [r.width, r.height];\n        if (n === 1 && s === 1) {\n          let u = `\n          float ${o}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        let a = `\n        float ${o}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${n}, ${s});\n          vec2 uv = uvFromFlat(${n}, ${s}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      getUnpackedSampler1D(o, t, r) {\n        let n = r.width,\n          s = r.height;\n        if (s === 1 && n === 1) {\n          let u = `\n        float ${o}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        if (s === 1) {\n          let u = `\n          float ${o}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${n}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        if (n === 1) {\n          let u = `\n          float ${o}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        let a = `\n        float ${o}(int index) {\n          vec2 uv = uvFromFlat(${n}, ${s}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n      }\n      getUnpackedSampler2D(o, t, r) {\n        let n = r.unpackedShape,\n          s = [r.height, r.width];\n        if (s != null && Me.arraysEqual(n, s)) {\n          let y = s[1],\n            T = s[0],\n            v = `\n          float ${o}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${y}.0, ${T}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(v, [\"coordinates.sampleTexture\"]);\n        }\n        let {\n            newShape: a,\n            keptDims: u\n          } = hr(n),\n          l = a;\n        if (l.length < n.length) {\n          let y = lr(n, l),\n            T = JSON.parse(JSON.stringify(r));\n          T.unpackedShape = y;\n          let v = [\"col\", \"row\"],\n            S = `\n          ${this.getUnpackedSamplerFromInput(o, t, T).routineBody}\n          float ${o}(int row, int col) {\n            return ${o}(${fr(v, u)});\n          }\n        `;\n          return new k(S, [\"coordinates.sampleTexture\"]);\n        }\n        let f = s[1],\n          p = s[0];\n        if (p === 1) {\n          let y = `\n          float ${o}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${f}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${n[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(y, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n        }\n        if (f === 1) {\n          let y = `\n          float ${o}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${f}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${n[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(y, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n        }\n        let d = `\n        float ${o}(int row, int col) {\n          int index = col * ${n[1]} + row;\n          vec2 uv = uvFromFlat(${f}, ${p}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(d, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      getUnpackedSampler3D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[1] * n[2],\n          a = n[2],\n          {\n            newShape: u,\n            keptDims: l\n          } = hr(n),\n          f = u;\n        if (f.length < n.length) {\n          let T = lr(n, f),\n            v = [\"batch\", \"col\", \"row\"],\n            S = JSON.parse(JSON.stringify(r));\n          S.unpackedShape = T;\n          let L = this.getUnpackedSamplerFromInput(o, t, S),\n            P = l.reverse(),\n            A = `\n          ${L.routineBody}\n          float ${o}(int batch, int row, int col) {\n            return ${o}(${fr(v, P)});\n          }\n        `;\n          return new k(A, L.dependencies);\n        }\n        let p = r.width,\n          d = r.height,\n          y = `\n          float ${o}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${s} + col * ${a} + row;\n            vec2 uv = uvFromFlat(${p}, ${d}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;\n        return new k(y, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      getUnpackedSampler4D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[3],\n          a = n[2] * s,\n          u = n[1] * a,\n          l = r.width,\n          f = r.height,\n          p = `\n        float ${o}(int row, int col, int depth, int depth2) {\n          int index = row * ${u} + col * ${a} +\n              depth2 * ${s} + depth;\n          vec2 uv = uvFromFlat(${l}, ${f}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(p, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n      }\n      getUnpackedSampler5D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[4],\n          a = n[3] * s,\n          u = n[2] * a,\n          l = n[1] * u,\n          {\n            newShape: f,\n            keptDims: p\n          } = hr(n);\n        if (f.length < n.length) {\n          let v = lr(n, f),\n            S = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"],\n            L = JSON.parse(JSON.stringify(r));\n          L.unpackedShape = v;\n          let P = `\n          ${this.getUnpackedSamplerFromInput(o, t, L).routineBody}\n          float ${o}(int row, int col, int depth, int depth2, int depth3) {\n            return ${o}(${fr(S, p)});\n          }\n        `;\n          return new k(P, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n        }\n        let d = r.width,\n          y = r.height,\n          T = `\n        float ${o}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${l} + col * ${u} + depth * ${a} +\n          depth3 * ${s} + depth2;\n          vec2 uv = uvFromFlat(${d}, ${y}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(T, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n      }\n      getUnpackedSampler6D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[5],\n          a = n[4] * s,\n          u = n[3] * a,\n          l = n[2] * u,\n          f = n[1] * l,\n          {\n            newShape: p,\n            keptDims: d\n          } = hr(n);\n        if (p.length < n.length) {\n          let S = lr(n, p),\n            L = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"],\n            P = JSON.parse(JSON.stringify(r));\n          P.unpackedShape = S;\n          let A = `\n            ${this.getUnpackedSamplerFromInput(o, t, P).routineBody}\n            float ${o}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${o}(${fr(L, d)});\n            }\n          `;\n          return new k(A, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n        }\n        let y = r.width,\n          T = r.height,\n          v = `\n          float ${o}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${f} + col * ${l} + depth * ${u} +\n            depth2 * ${a} + depth3 * ${s} + depth4;\n            vec2 uv = uvFromFlat(${y}, ${T}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n        return new k(v, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      toVec() {\n        let o = this.context.outputTextureLayout,\n          t = o.shape.length,\n          r = o.strides,\n          n = o.width,\n          s = o.height,\n          a = [];\n        for (let l = 0; l < t - 1; ++l) a.push(`\n        c[${l}] = offset / ${r[l]};`), a.push(`\n        offset -= c[${l}] * ${r[l]};`);\n        a.push(`\n        c[${t - 1}] = offset;`);\n        let u = `\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${n}, ${s});\n        ${a.join(\"\")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${a.join(\"\")}\n      }\n    `;\n        return {\n          toVec: new k(u, [\"coordinates.coordsToOffset\"])\n        };\n      }\n      valueFrom() {\n        let o = {};\n        return this.context.programInfo.inputNames.forEach((t, r) => {\n          let n = this.context.inputTextureLayouts[r],\n            a = (n.unpackedShape.length > 0 ? n.unpackedShape : n.shape).length,\n            u = `_${t}`;\n          o[u] = new k(this.getValueFromSingle(t, a, n.width, n.height, !1), [`shapeUtils.indicesToOffset${u}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]), u = u + \"_T\", o[u] = new k(this.getValueFromSingle(t, a, n.width, n.height, !0), [`shapeUtils.indicesToOffset${u}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]);\n        }), o;\n      }\n      getValueFromSingle(o, t, r, n, s) {\n        let a = `_${o}`;\n        s && (a = a + \"_T\");\n        let u = G(this.context.glContext.version);\n        return `\n        float ${a}(int m[${t}]) {\n          int offset = indicesToOffset${a}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          float value = getColorAsFloat(${u.texture2D}(${o}, coords));\n          return value;\n        }\n        `;\n      }\n      getPackedValueFrom(o, t, r, n, s) {\n        let a = `_${o}_Pack`;\n        s && (a = a + \"_T\");\n        let u = G(this.context.glContext.version);\n        return `\n        vec4 ${a}(int m[${t}]) {\n          int offset = indicesToOffset_${o}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          return ${u.texture2D}(${o}, coords);\n        }\n        `;\n      }\n    };\n  });\nvar zn,\n  pp = O(() => {\n    \"use strict\";\n\n    Te();\n    zn = class i extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getFunctions() {\n        return {\n          ...this.encodeFloat32(),\n          ...this.decodeFloat32()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      encodeFloat32() {\n        return {\n          encode: new k(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `)\n        };\n      }\n      decodeFloat32() {\n        return {\n          decode: new k(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `)\n        };\n      }\n      encodeUint8() {\n        let e = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n        return {\n          encode: new k(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)\n        };\n      }\n      decodeUint8() {\n        let e = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n        return {\n          decode: new k(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)\n        };\n      }\n      static isLittleEndian() {\n        let e = new ArrayBuffer(4),\n          o = new Uint32Array(e),\n          t = new Uint8Array(e);\n        if (o[0] = 3735928559, t[0] === 239) return !0;\n        if (t[0] === 222) return !1;\n        throw new Error(\"unknown endianness\");\n      }\n    };\n  });\nvar Wn,\n  dp = O(() => {\n    \"use strict\";\n\n    Te();\n    ut();\n    Wn = class extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getFunctions() {\n        return {\n          ...this.setFragColor(),\n          ...this.getColorAsFloat()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      setFragColor() {\n        let e = G(this.context.glContext.version);\n        return {\n          setFragColor: new k(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `, [\"encoding.encode\"])\n        };\n      }\n      getColorAsFloat() {\n        return {\n          getColorAsFloat: new k(`\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `, [\"encoding.decode\"])\n        };\n      }\n    };\n  });\nvar Hn,\n  hp = O(() => {\n    \"use strict\";\n\n    Te();\n    Hn = class i extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getFunctions() {\n        return {\n          ...this.bcastIndex(),\n          ...this.bcastMatmulIndex(),\n          ...this.offsetToIndices(),\n          ...this.indicesToOffset(),\n          ...this.incrementIndices()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      bcastIndex() {\n        let e = this.context.outputTextureLayout.shape.length,\n          o = {};\n        return this.context.programInfo.inputNames.forEach((t, r) => {\n          let n = this.context.inputTextureLayouts[r].unpackedShape;\n          if (n.length <= e) {\n            let s = n.length,\n              a = e - s,\n              u = `bcastIndices_${t}`,\n              l = \"\";\n            for (let p = 0; p < s; ++p) l += `\n          realIndices[${p}] = int( mod(float(bcastedIndices[${a + p}]), ${n[p]}.0) );\n          `;\n            let f = `\n        void ${u} (int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${l}\n        }\n        `;\n            o[u] = new k(f);\n          }\n        }), o;\n      }\n      bcastMatmulIndex() {\n        let e = this.context.outputTextureLayout.shape.length,\n          o = {};\n        return this.context.programInfo.inputNames.forEach((t, r) => {\n          let n = this.context.inputTextureLayouts[r].shape;\n          if (!(n.length < 2 || n.length > e)) {\n            let s = n.length,\n              a = e - s,\n              u = `bcastMatmulIndices_${t}`,\n              l = \"\";\n            for (let p = 0; p < s - 2; ++p) l += `\n          realIndices[${p}] = int( mod(float(bcastedIndices[${a + p}]), ${n[p]}.0) );\n          `;\n            let f = `\n        void ${u}(int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${l}\n          realIndices[${s - 1}] = bcastedIndices[${e - 1}];\n          realIndices[${s - 2}] = bcastedIndices[${e - 2}];\n        }\n        `;\n            o[u] = new k(f);\n          }\n        }), o;\n      }\n      indicesToOffset() {\n        let e = {};\n        return this.context.programInfo.inputNames.forEach((o, t) => {\n          let r = this.context.inputTextureLayouts[t].shape,\n            n = this.context.inputTextureLayouts[t].strides,\n            s = r.length,\n            a = `indicesToOffset_${o}`;\n          e[a] = new k(i.indexToOffsetSingle(a, s, n)), a = `indicesToOffset_${o}_T`, e[a] = new k(i.indexToOffsetSingle(a, s, n.slice().reverse()));\n        }), e;\n      }\n      static indexToOffsetSingle(e, o, t) {\n        let r = \"\";\n        for (let n = o - 1; n >= 0; --n) r += `\n        offset += indices[${n}] * ${t[n]};\n        `;\n        return `\n      int ${e}(int indices[${o}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `;\n      }\n      offsetToIndices() {\n        let e = {};\n        return this.context.programInfo.inputNames.forEach((o, t) => {\n          let r = this.context.inputTextureLayouts[t].shape,\n            n = this.context.inputTextureLayouts[t].strides,\n            s = r.length,\n            a = `offsetToIndices_${o}`;\n          e[a] = new k(i.offsetToIndicesSingle(a, s, n)), a = `offsetToIndices_${o}_T`, e[a] = new k(i.offsetToIndicesSingle(a, s, n.slice().reverse()));\n        }), e;\n      }\n      static offsetToIndicesSingle(e, o, t) {\n        let r = [];\n        for (let n = 0; n < o - 1; ++n) r.push(`\n      indices[${n}] = offset / ${t[n]};`), r.push(`\n        offset -= indices[${n}] * ${t[n]};`);\n        return r.push(`\n      indices[${o - 1}] = offset;`), `\n      void ${e}(int offset, out int indices[${o}]) {\n        ${r.join(\"\")}\n      }\n      `;\n      }\n      incrementIndices() {\n        let e = {};\n        return this.context.programInfo.inputNames.forEach((o, t) => {\n          let r = this.context.inputTextureLayouts[t].shape,\n            n = r.length,\n            s = `incrementIndices_${o}`,\n            a = \"\";\n          for (let l = 0; l < n; ++l) a += `\n        shape[${l}] = ${r[l]};`;\n          let u = `\n        void ${s}(int axis, out int indices[${n}]) {\n          int shape[${n}];\n          ${a};\n          for(int i = ${n} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;\n          e[s] = new k(u);\n        }), e;\n      }\n    };\n  });\nvar qn,\n  mp = O(() => {\n    \"use strict\";\n\n    Te();\n    qn = class extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getCustomTypes() {\n        return {};\n      }\n      getFunctions() {\n        return {\n          ...this.binaryVecFunctions(),\n          ...this.copyVec(),\n          ...this.setVecItem(),\n          ...this.getVecItem()\n        };\n      }\n      binaryVecFunctions() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = {\n            add: \"+=\",\n            sub: \"-=\",\n            mul: \"*=\",\n            div: \"/=\"\n          },\n          r = {};\n        for (let n in t) {\n          let s = `${n}Vec`,\n            a = \"\";\n          for (let l = 0; l < o; ++l) a += `\n          dest[${l}] ${t[n]} src[${l}];\n          `;\n          let u = `\n        void ${s}(int src[${o}], out int dest[${o}]) {\n          ${a}\n        }\n        `;\n          r[s] = new k(u);\n        }\n        return r;\n      }\n      copyVec() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = \"\";\n        for (let n = 0; n < o; ++n) t += `\n        dest[${n}] = src[${n}];\n        `;\n        let r = `\n      void copyVec(int src[${o}], out int dest[${o}]) {\n        ${t}\n      }\n      `;\n        return {\n          copyVec: new k(r)\n        };\n      }\n      setVecItem() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = `\n        if(index < 0)\n            index =${o} + index;\n        if (index == 0)\n            m[0] = value;\n        `;\n        for (let n = 1; n < o - 1; ++n) t += `\n        else if (index == ${n})\n            m[${n}] = value;\n            `;\n        t += `\n        else\n            m[${o - 1}] = value;\n        `;\n        let r = `\n      void setVecItem(out int m[${o}], int index, int value) {\n        ${t}\n      }\n        `;\n        return {\n          setVecItem: new k(r)\n        };\n      }\n      getVecItem() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = `\n        if(index < 0)\n            index = ${o} + index;\n        if (index == 0)\n            return m[0];\n      `;\n        for (let n = 1; n < o - 1; ++n) t += `\n        else if (index == ${n})\n            return m[${n}];\n      `;\n        t += `\n        else\n            return m[${o - 1}];\n        `;\n        let r = `\n      int getVecItem(int m[${o}], int index) {\n        ${t}\n      }\n    `;\n        return {\n          getVecItem: new k(r)\n        };\n      }\n    };\n  });\nvar Ri,\n  bp = O(() => {\n    \"use strict\";\n\n    cp();\n    pp();\n    dp();\n    hp();\n    mp();\n    Ri = {\n      encoding: zn,\n      fragcolor: Wn,\n      vec: qn,\n      shapeUtils: Hn,\n      coordinates: Vn\n    };\n  });\nvar jn,\n  gp = O(() => {\n    \"use strict\";\n\n    Te();\n    lp();\n    bp();\n    ut();\n    jn = class {\n      constructor(e, o, t, r) {\n        this.libs = {};\n        this.glslLibRoutineDependencyGraph = {};\n        this.context = new Ln(e, o, t, r), Object.keys(Ri).forEach(s => {\n          let a = new Ri[s](this.context);\n          this.libs[s] = a;\n        });\n        let n = this.glslLibRoutineDependencyGraph;\n        for (let s in this.libs) {\n          let u = this.libs[s].getFunctions();\n          for (let l in u) {\n            let f = s + \".\" + l,\n              p;\n            n[f] ? (p = n[f], p.routineBody = u[l].routineBody) : (p = new Nr(f, u[l].routineBody), n[f] = p);\n            let d = u[l].dependencies;\n            if (d) for (let y = 0; y < d.length; ++y) if (n[d[y]]) p.addDependency(n[d[y]]);else {\n              let T = new Nr(d[y]);\n              n[d[y]] = T, p.addDependency(T);\n            }\n          }\n        }\n      }\n      preprocess() {\n        let e = this.context.programInfo,\n          o = e.shaderSource;\n        return this.context.programInfo.hasMain || (o = `${o}\n      ${Ju(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), o = up(o), `${Ku(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames, e.variables)}\n    ${this.getImports(o)}\n    ${o}`;\n      }\n      getImports(e) {\n        let o = this.selectGlslLibRoutinesToBeIncluded(e);\n        if (o.length === 0) return \"\";\n        let t = \"\";\n        for (let r = 0; r < o.length; ++r) if (o[r].routineBody) t += o[r].routineBody + `\n`;else throw new Error(`Missing body for the Glsl Library routine: ${o[r].name}`);\n        return t;\n      }\n      selectGlslLibRoutinesToBeIncluded(e) {\n        let o = [];\n        return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t => {\n          let r = t.split(\".\")[1];\n          e.indexOf(r) !== -1 && o.push(this.glslLibRoutineDependencyGraph[t]);\n        }), $n.returnOrderedNodes(o);\n      }\n      getUniforms(e, o) {\n        let t = [];\n        if (e) for (let r of e) t.push(`uniform sampler2D ${r};`);\n        if (o) for (let r of o) t.push(`uniform ${r.type} ${r.name}${r.arrayLength ? `[${r.arrayLength}]` : \"\"};`);\n        return t.join(`\n`);\n      }\n    };\n  });\nvar Xn,\n  yp = O(() => {\n    \"use strict\";\n\n    Yt();\n    Ut();\n    gp();\n    ut();\n    Xn = class {\n      constructor(e, o, t) {\n        this.profiler = e;\n        this.glContext = o;\n        this.textureLayoutStrategy = t;\n        this.repo = new Map(), this.attributesBound = !1;\n      }\n      getArtifact(e) {\n        return this.repo.get(e);\n      }\n      setArtifact(e, o) {\n        this.repo.set(e, o);\n      }\n      run(e, o, t) {\n        this.profiler.event(\"op\", `ProgramManager.run ${e.programInfo.name ?? \"unknown kernel\"}`, () => {\n          let r = this.glContext.gl,\n            n = e.program;\n          r.useProgram(n);\n          try {\n            this.bindOutput(t), this.attributesBound || this.bindAttributes(e.attribLocations), this.bindUniforms(e.uniformLocations, e.programInfo.variables ?? [], o);\n          } catch (s) {\n            throw tt.error(\"ProgramManager\", e.programInfo.shaderSource), s;\n          }\n          this.profiler.event(\"backend\", \"GlContext.draw()\", () => {\n            this.glContext.draw();\n          });\n        }, this.glContext);\n      }\n      dispose() {\n        this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach(e => this.glContext.deleteProgram(e.program));\n      }\n      build(e, o, t) {\n        return this.profiler.event(\"backend\", \"ProgramManager.build\", () => {\n          let r = new jn(this.glContext, e, o, t),\n            n = r.preprocess(),\n            s = this.compile(n);\n          return {\n            programInfo: e,\n            program: s,\n            uniformLocations: this.getUniformLocations(s, r.context.programInfo.inputNames, r.context.programInfo.variables),\n            attribLocations: this.getAttribLocations(s)\n          };\n        });\n      }\n      compile(e) {\n        if (!this.vertexShader) {\n          tt.verbose(\"ProrgramManager\", \"Compiling and caching Vertex shader for the first time\");\n          let r = Xu(this.glContext.version);\n          this.vertexShader = this.glContext.compileShader(r, this.glContext.gl.VERTEX_SHADER);\n        }\n        z.debug && tt.verbose(\"ProrgramManager\", `FragShader:\n${e}\n`);\n        let o = this.glContext.compileShader(e, this.glContext.gl.FRAGMENT_SHADER),\n          t = this.glContext.createProgram(this.vertexShader, o);\n        return this.glContext.deleteShader(o), t;\n      }\n      bindOutput(e) {\n        let o = e.width,\n          t = e.height;\n        tt.verbose(\"ProrgramManager\", `Binding output texture to Framebuffer: w/h=${o}/${t}, shape=${e.shape}, type=${e.tensor.type}`), this.glContext.attachFramebuffer(e.texture, o, t);\n      }\n      bindAttributes(e) {\n        let o = e.position,\n          t = e.textureCoord;\n        this.glContext.setVertexAttributes(o, t), this.attributesBound = !0;\n      }\n      bindUniforms(e, o, t) {\n        let r = this.glContext.gl,\n          n = 0;\n        for (let {\n          name: s,\n          type: a,\n          location: u,\n          arrayLength: l\n        } of e) {\n          let f = o.find(p => p.name === s)?.data;\n          if (a !== \"sampler2D\" && !f) throw new Error(`variable '${s}' does not have data defined in program info`);\n          switch (a) {\n            case \"sampler2D\":\n              this.bindTexture(t[n], u, n), n++;\n              break;\n            case \"float\":\n              l ? r.uniform1fv(u, f) : r.uniform1f(u, f);\n              break;\n            case \"int\":\n              l ? r.uniform1iv(u, f) : r.uniform1i(u, f);\n              break;\n            default:\n              throw new Error(`Uniform not implemented: ${a}`);\n          }\n        }\n      }\n      bindTexture(e, o, t) {\n        this.glContext.bindTextureToUniform(e.texture, t, o);\n      }\n      getAttribLocations(e) {\n        return {\n          position: this.getAttribLocation(e, \"position\"),\n          textureCoord: this.getAttribLocation(e, \"textureCoord\")\n        };\n      }\n      getUniformLocations(e, o, t) {\n        let r = [];\n        if (o) for (let n of o) r.push({\n          name: n,\n          type: \"sampler2D\",\n          location: this.getUniformLocation(e, n)\n        });\n        if (t) for (let n of t) r.push({\n          ...n,\n          location: this.getUniformLocation(e, n.name)\n        });\n        return r;\n      }\n      getUniformLocation(e, o) {\n        let r = this.glContext.gl.getUniformLocation(e, o);\n        if (r === null) throw new Error(`Uniform ${o} not found.`);\n        return r;\n      }\n      getAttribLocation(e, o) {\n        return this.glContext.gl.getAttribLocation(e, o);\n      }\n    };\n  });\nvar Kn,\n  xp = O(() => {\n    \"use strict\";\n\n    Ut();\n    Fr();\n    Kn = class {\n      constructor(e, o, t, r) {\n        this.glContext = e;\n        this.layoutStrategy = o;\n        this.profiler = t;\n        this.config = r;\n        this.pendingRead = new Map();\n        r.reuseTextures && (this.inUseTextures = new Map(), this.idleTextures = new Map(), this.textureLookup = new Map());\n      }\n      createTextureFromLayout(e, o, t, r) {\n        let n = this.toEncoderType(e),\n          s = this.glContext.getEncoder(n, o.channels || 1, r);\n        if (o.isPacked && r === 1) throw new Error(\"not implemented\");\n        let a = o.width,\n          u = o.height,\n          l,\n          f;\n        if (this.config.reuseTextures) {\n          l = `${a}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`, f = this.inUseTextures.get(l), f || (f = [], this.inUseTextures.set(l, f));\n          let d = this.idleTextures.get(l);\n          if (d && d.length > 0) {\n            let y = d.pop();\n            return f.push(y), r === 1 && this.glContext.updateTexture(y, a, u, s, this.toTextureData(e, t)), y;\n          }\n        }\n        tt.verbose(\"TextureManager\", `Creating new texture of size ${o.width}x${o.height}`);\n        let p = this.glContext.allocateTexture(a, u, s, this.toTextureData(e, t));\n        return this.config.reuseTextures && (f.push(p), this.textureLookup.set(p, l)), p;\n      }\n      readTexture(e, o, t) {\n        return t || (t = 1), this.profiler.event(\"backend\", \"TextureManager.readTexture\", () => {\n          let r = e.shape.reduce((s, a) => s * a) * t,\n            n = this.glContext.readTexture(e.texture, e.width, e.height, r, this.toEncoderType(o), t);\n          return this.toTensorData(o, n);\n        });\n      }\n      readTextureAsync(e, o, t) {\n        var _this17 = this;\n        return _asyncToGenerator(function* () {\n          let r = e.tensor.dataId;\n          if (t || (t = 1), _this17.pendingRead.has(r)) {\n            let n = _this17.pendingRead.get(r);\n            return new Promise(s => n?.push(s));\n          }\n          return _this17.profiler.event(\"backend\", \"TextureManager.readTextureAsync\", /*#__PURE__*/_asyncToGenerator(function* () {\n            _this17.pendingRead.set(r, []);\n            let n = e.shape.reduce((l, f) => l * f) * t;\n            yield _this17.glContext.createAndWaitForFence();\n            let s = _this17.glContext.readTexture(e.texture, e.width, e.height, n, _this17.toEncoderType(o), t),\n              a = _this17.toTensorData(o, s),\n              u = _this17.pendingRead.get(r);\n            return _this17.pendingRead.delete(r), u?.forEach(l => l(a)), a;\n          }));\n        })();\n      }\n      readUint8TextureAsFloat(e) {\n        return this.profiler.event(\"backend\", \"TextureManager.readUint8TextureAsFloat\", () => {\n          let o = e.shape.reduce((r, n) => r * n),\n            t = this.glContext.readTexture(e.texture, e.width, e.height, o * 4, \"byte\", 4);\n          return new Float32Array(t.buffer, t.byteOffset, o);\n        });\n      }\n      releaseTexture(e, o) {\n        let t;\n        if (this.config.reuseTextures && (t = this.textureLookup.get(e.texture), t)) {\n          o && this.textureLookup.delete(t);\n          let r = this.inUseTextures.get(t);\n          if (r) {\n            let n = r.indexOf(e.texture);\n            if (n !== -1) {\n              r.splice(n, 1);\n              let s = this.idleTextures.get(t);\n              s || (s = [], this.idleTextures.set(t, s)), s.push(e.texture);\n            }\n          }\n        }\n        (!t || o) && (tt.verbose(\"TextureManager\", `Deleting texture of size ${e.width}x${e.height}`), this.glContext.deleteTexture(e.texture));\n      }\n      toTensorData(e, o) {\n        switch (e) {\n          case \"int16\":\n            return o instanceof Int16Array ? o : Int16Array.from(o);\n          case \"int32\":\n            return o instanceof Int32Array ? o : Int32Array.from(o);\n          case \"int8\":\n            return o instanceof Int8Array ? o : Int8Array.from(o);\n          case \"uint16\":\n            return o instanceof Uint16Array ? o : Uint16Array.from(o);\n          case \"uint32\":\n            return o instanceof Uint32Array ? o : Uint32Array.from(o);\n          case \"uint8\":\n          case \"bool\":\n            return o instanceof Uint8Array ? o : Uint8Array.from(o);\n          case \"float32\":\n            return o instanceof Float32Array ? o : Float32Array.from(o);\n          case \"float64\":\n            return o instanceof Float64Array ? o : Float64Array.from(o);\n          default:\n            throw new Error(`TensorData type ${e} is not supported`);\n        }\n      }\n      toTextureData(e, o) {\n        if (o) return o instanceof Float32Array ? o : new Float32Array(o);\n      }\n      toEncoderType(e) {\n        return \"float\";\n      }\n      clearActiveTextures() {\n        this.glContext.clearActiveTextures();\n      }\n    };\n  });\nvar Jn,\n  Tp = O(() => {\n    \"use strict\";\n\n    Ut();\n    Bs();\n    cl();\n    ap();\n    yp();\n    Ni();\n    xp();\n    Jn = class {\n      constructor(e, o) {\n        this.backend = e;\n        this.context = o;\n        this.layoutStrategy = new Un(e.glContext.maxTextureSize), this.programManager = new Xn(this.context.profiler, e.glContext, this.layoutStrategy), this.textureManager = new Kn(e.glContext, this.layoutStrategy, this.context.profiler, {\n          reuseTextures: e.textureCacheMode === \"full\"\n        }), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map(), this.pack = e.pack, this.pack2unpackMap = new Map(), this.unpack2packMap = new Map();\n      }\n      createInferenceHandler() {\n        return new Dn(this);\n      }\n      onGraphInitialized(e) {\n        let o = e.getValues().filter(t => t.from === -1 && t.tensor).map(t => t.tensor.dataId);\n        this.initializers = new Set(o);\n      }\n      isInitializer(e) {\n        return this.initializers ? this.initializers.has(e) : !1;\n      }\n      addInitializer(e) {\n        this.initializers.add(e);\n      }\n      getTextureData(e, o) {\n        return o ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);\n      }\n      setTextureData(e, o, t = !1) {\n        tt.verbose(\"WebGLSessionHandler\", \"Storing Texture data in cache\"), t ? this.packedTextureDataCache.set(e, o) : this.unpackedTextureDataCache.set(e, o);\n      }\n      dispose() {\n        this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(e => this.textureManager.releaseTexture(e, !0)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(e => this.textureManager.releaseTexture(e, !0)), this.unpackedTextureDataCache = new Map();\n      }\n      resolve(e, o, t) {\n        let r = ks(e, o, ip);\n        return {\n          impl: r.opImpl,\n          context: r.opInit ? r.opInit(e, t) : e\n        };\n      }\n    };\n  });\nfunction bg(i) {\n  let e = 0;\n  for (; e < i.length && i[e](); ++e);\n  return e - 1;\n}\nvar Mr,\n  wp = O(() => {\n    \"use strict\";\n\n    Yt();\n    Fr();\n    Fr();\n    pe();\n    Mr = class {\n      constructor(e, o) {\n        this.frameBufferBound = !1;\n        this.itemsToPoll = [];\n        this.gl = e, this.version = o, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();\n      }\n      allocateTexture(e, o, t, r) {\n        let n = this.gl,\n          s = n.createTexture();\n        n.bindTexture(n.TEXTURE_2D, s), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);\n        let a = r ? t.encode(r, e * o) : null;\n        return n.texImage2D(n.TEXTURE_2D, 0, t.internalFormat, e, o, 0, t.format, t.textureType, a), this.checkError(), s;\n      }\n      updateTexture(e, o, t, r, n) {\n        let s = this.gl;\n        s.bindTexture(s.TEXTURE_2D, e);\n        let a = r.encode(n, o * t);\n        s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, o, t, r.format, r.textureType, a), this.checkError();\n      }\n      attachFramebuffer(e, o, t) {\n        let r = this.gl;\n        r.bindTexture(r.TEXTURE_2D, e), r.bindFramebuffer(r.FRAMEBUFFER, this.framebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.checkError(), r.viewport(0, 0, o, t), r.scissor(0, 0, o, t);\n      }\n      readTexture(e, o, t, r, n, s) {\n        let a = this.gl;\n        s || (s = 1), this.frameBufferBound || this.attachFramebuffer(e, o, t);\n        let u = this.getEncoder(n, s),\n          l = u.allocate(o * t);\n        return a.bindTexture(a.TEXTURE_2D, e), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), a.readPixels(0, 0, o, t, a.RGBA, u.textureType, l), this.checkError(), u.decode(l, r);\n      }\n      isFramebufferReady() {\n        return !0;\n      }\n      getActiveTexture() {\n        let e = this.gl;\n        return `TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE) - e.TEXTURE0}`;\n      }\n      getTextureBinding() {\n        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n      }\n      getFramebufferBinding() {\n        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n      }\n      setVertexAttributes(e, o) {\n        let t = this.gl;\n        t.vertexAttribPointer(e, 3, t.FLOAT, !1, 20, 0), t.enableVertexAttribArray(e), o !== -1 && (t.vertexAttribPointer(o, 2, t.FLOAT, !1, 20, 12), t.enableVertexAttribArray(o)), this.checkError();\n      }\n      createProgram(e, o) {\n        let t = this.gl,\n          r = t.createProgram();\n        return t.attachShader(r, e), t.attachShader(r, o), t.linkProgram(r), r;\n      }\n      compileShader(e, o) {\n        let t = this.gl,\n          r = t.createShader(o);\n        if (!r) throw new Error(`createShader() returned null with type ${o}`);\n        if (t.shaderSource(r, e), t.compileShader(r), t.getShaderParameter(r, t.COMPILE_STATUS) === !1) throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(r)}\nShader source:\n${e}`);\n        return r;\n      }\n      deleteShader(e) {\n        this.gl.deleteShader(e);\n      }\n      bindTextureToUniform(e, o, t) {\n        let r = this.gl;\n        r.activeTexture(r.TEXTURE0 + o), this.checkError(), r.bindTexture(r.TEXTURE_2D, e), this.checkError(), r.uniform1i(t, o), this.checkError();\n      }\n      draw() {\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();\n      }\n      checkError() {\n        if (z.debug) {\n          let e = this.gl,\n            o = e.getError(),\n            t = \"\";\n          switch (o) {\n            case e.NO_ERROR:\n              return;\n            case e.INVALID_ENUM:\n              t = \"INVALID_ENUM\";\n              break;\n            case e.INVALID_VALUE:\n              t = \"INVALID_VALUE\";\n              break;\n            case e.INVALID_OPERATION:\n              t = \"INVALID_OPERATION\";\n              break;\n            case e.INVALID_FRAMEBUFFER_OPERATION:\n              t = \"INVALID_FRAMEBUFFER_OPERATION\";\n              break;\n            case e.OUT_OF_MEMORY:\n              t = \"OUT_OF_MEMORY\";\n              break;\n            case e.CONTEXT_LOST_WEBGL:\n              t = \"CONTEXT_LOST_WEBGL\";\n              break;\n            default:\n              t = `Unknown WebGL Error: ${o.toString(16)}`;\n          }\n          throw new Error(t);\n        }\n      }\n      deleteTexture(e) {\n        this.gl.deleteTexture(e);\n      }\n      deleteProgram(e) {\n        this.gl.deleteProgram(e);\n      }\n      getEncoder(e, o, t = 0) {\n        if (this.version === 2) return new Pn(this.gl, o);\n        switch (e) {\n          case \"float\":\n            return t === 1 || this.isRenderFloat32Supported ? new Br(this.gl, o) : new Br(this.gl, o, this.textureHalfFloatExtension.HALF_FLOAT_OES);\n          case \"int\":\n            throw new Error(\"not implemented\");\n          case \"byte\":\n            return new En(this.gl, o);\n          default:\n            throw new Error(`Invalid dataType: ${e}`);\n        }\n      }\n      clearActiveTextures() {\n        let e = this.gl;\n        for (let o = 0; o < this.maxTextureImageUnits; ++o) e.activeTexture(e.TEXTURE0 + o), e.bindTexture(e.TEXTURE_2D, null);\n      }\n      dispose() {\n        if (this.disposed) return;\n        let e = this.gl;\n        e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(this.framebuffer), e.bindBuffer(e.ARRAY_BUFFER, null), e.deleteBuffer(this.vertexbuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), e.finish(), this.disposed = !0;\n      }\n      createDefaultGeometry() {\n        return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n      }\n      createVertexbuffer() {\n        let e = this.gl,\n          o = e.createBuffer();\n        if (!o) throw new Error(\"createBuffer() returned null\");\n        let t = this.createDefaultGeometry();\n        return e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), this.checkError(), o;\n      }\n      createFramebuffer() {\n        let e = this.gl.createFramebuffer();\n        if (!e) throw new Error(\"createFramebuffer returned null\");\n        return e;\n      }\n      queryVitalParameters() {\n        let e = this.gl;\n        if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error(\"both float32 and float16 TextureType are not supported\");\n        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.version;\n      }\n      getExtensions() {\n        this.version === 2 ? (this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")) : (this.textureFloatExtension = this.gl.getExtension(\"OES_texture_float\"), this.textureHalfFloatExtension = this.gl.getExtension(\"OES_texture_half_float\"));\n      }\n      checkFloatTextureAttachableToFrameBuffer() {\n        let e = this.gl,\n          o = e.createTexture();\n        e.bindTexture(e.TEXTURE_2D, o);\n        let t = this.version === 2 ? e.RGBA32F : e.RGBA;\n        e.texImage2D(e.TEXTURE_2D, 0, t, 1, 1, 0, e.RGBA, e.FLOAT, null);\n        let r = e.createFramebuffer();\n        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, o, 0);\n        let n = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;\n        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(o), e.deleteFramebuffer(r), n;\n      }\n      checkRenderFloat32() {\n        if (this.version === 2) {\n          if (!this.colorBufferFloatExtension) return !1;\n        } else if (!this.textureFloatExtension) return !1;\n        return this.isFloatTextureAttachableToFrameBuffer;\n      }\n      checkFloat32Download() {\n        if (this.version === 2) {\n          if (!this.colorBufferFloatExtension) return !1;\n        } else if (!this.textureFloatExtension || !this.gl.getExtension(\"WEBGL_color_buffer_float\")) return !1;\n        return this.isFloatTextureAttachableToFrameBuffer;\n      }\n      checkFloat32Blend() {\n        let e = this.gl,\n          o,\n          t,\n          r,\n          n,\n          s;\n        try {\n          o = e.createTexture(), t = e.createFramebuffer(), e.bindTexture(e.TEXTURE_2D, o);\n          let a = this.version === 2 ? e.RGBA32F : e.RGBA;\n          return e.texImage2D(e.TEXTURE_2D, 0, a, 1, 1, 0, e.RGBA, e.FLOAT, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, o, 0), e.enable(e.BLEND), r = e.createShader(e.VERTEX_SHADER), !r || (e.shaderSource(r, \"void main(){}\"), e.compileShader(r), n = e.createShader(e.FRAGMENT_SHADER), !n) || (e.shaderSource(n, \"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"), e.compileShader(n), s = e.createProgram(), !s) ? !1 : (e.attachShader(s, r), e.attachShader(s, n), e.linkProgram(s), e.useProgram(s), e.drawArrays(e.POINTS, 0, 1), e.getError() === e.NO_ERROR);\n        } finally {\n          e.disable(e.BLEND), s && e.deleteProgram(s), r && e.deleteShader(r), n && e.deleteShader(n), t && (e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(t)), o && (e.bindTexture(e.TEXTURE_2D, null), e.deleteTexture(o));\n        }\n      }\n      beginTimer() {\n        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n          let e = this.gl,\n            o = this.disjointTimerQueryWebgl2Extension,\n            t = e.createQuery();\n          return e.beginQuery(o.TIME_ELAPSED_EXT, t), t;\n        } else throw new Error(\"WebGL1 profiling currently not supported.\");\n      }\n      endTimer() {\n        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n          let e = this.gl,\n            o = this.disjointTimerQueryWebgl2Extension;\n          e.endQuery(o.TIME_ELAPSED_EXT);\n          return;\n        } else throw new Error(\"WebGL1 profiling currently not supported\");\n      }\n      isTimerResultAvailable(e) {\n        let o = !1,\n          t = !1;\n        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n          let r = this.gl,\n            n = this.disjointTimerQueryWebgl2Extension;\n          o = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE), t = r.getParameter(n.GPU_DISJOINT_EXT);\n        } else throw new Error(\"WebGL1 profiling currently not supported\");\n        return o && !t;\n      }\n      getTimerResult(e) {\n        let o = 0;\n        if (this.version === 2) {\n          let t = this.gl;\n          o = t.getQueryParameter(e, t.QUERY_RESULT), t.deleteQuery(e);\n        } else throw new Error(\"WebGL1 profiling currently not supported\");\n        return o / 1e6;\n      }\n      waitForQueryAndGetTime(e) {\n        var _this18 = this;\n        return _asyncToGenerator(function* () {\n          return yield li(() => _this18.isTimerResultAvailable(e)), _this18.getTimerResult(e);\n        })();\n      }\n      createAndWaitForFence() {\n        var _this19 = this;\n        return _asyncToGenerator(function* () {\n          let e = _this19.createFence(_this19.gl);\n          return _this19.pollFence(e);\n        })();\n      }\n      createFence(e) {\n        let o,\n          t = e,\n          r = t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        return e.flush(), r === null ? o = () => !0 : o = () => {\n          let n = t.clientWaitSync(r, 0, 0);\n          return n === t.ALREADY_SIGNALED || n === t.CONDITION_SATISFIED;\n        }, {\n          query: r,\n          isFencePassed: o\n        };\n      }\n      pollFence(e) {\n        var _this20 = this;\n        return _asyncToGenerator(function* () {\n          return new Promise(o => {\n            _this20.addItemToPoll(() => e.isFencePassed(), () => o());\n          });\n        })();\n      }\n      pollItems() {\n        let e = bg(this.itemsToPoll.map(o => o.isDoneFn));\n        for (let o = 0; o <= e; ++o) {\n          let {\n            resolveFn: t\n          } = this.itemsToPoll[o];\n          t();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(e + 1);\n      }\n      addItemToPoll(e, o) {\n        var _this21 = this;\n        return _asyncToGenerator(function* () {\n          _this21.itemsToPoll.push({\n            isDoneFn: e,\n            resolveFn: o\n          }), !(_this21.itemsToPoll.length > 1) && (yield li(() => (_this21.pollItems(), _this21.itemsToPoll.length === 0)));\n        })();\n      }\n    };\n  });\nfunction Gi(i) {\n  let e;\n  if ((!i || i === \"webgl2\") && \"webgl2\" in mr ? e = mr.webgl2 : (!i || i === \"webgl\") && \"webgl\" in mr && (e = mr.webgl), !e) try {\n    let t = yg();\n    e = vp(t, i);\n  } catch {\n    let r = gg();\n    e = vp(r, i);\n  }\n  i = i || e.version === 1 ? \"webgl\" : \"webgl2\";\n  let o = e.gl;\n  return mr[i] = e, o.isContextLost() ? (delete mr[i], Gi(i)) : (o.disable(o.DEPTH_TEST), o.disable(o.STENCIL_TEST), o.disable(o.BLEND), o.disable(o.DITHER), o.disable(o.POLYGON_OFFSET_FILL), o.disable(o.SAMPLE_COVERAGE), o.enable(o.SCISSOR_TEST), o.enable(o.CULL_FACE), o.cullFace(o.BACK), e);\n}\nfunction vp(i, e) {\n  let o = {\n      alpha: !1,\n      depth: !1,\n      antialias: !1,\n      stencil: !1,\n      preserveDrawingBuffer: !1,\n      premultipliedAlpha: !1,\n      failIfMajorPerformanceCaveat: !1\n    },\n    t,\n    r = o;\n  if ((!e || e === \"webgl2\") && (t = i.getContext(\"webgl2\", r), t)) try {\n    return new Mr(t, 2);\n  } catch (n) {\n    tt.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`);\n  }\n  if ((!e || e === \"webgl\") && (t = i.getContext(\"webgl\", r) || i.getContext(\"experimental-webgl\", r), t)) try {\n    return new Mr(t, 1);\n  } catch (n) {\n    tt.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`);\n  }\n  throw new Error(\"WebGL is not supported\");\n}\nfunction gg() {\n  if (typeof document > \"u\") throw new TypeError(\"failed to create canvas: document is not supported\");\n  let i = document.createElement(\"canvas\");\n  return i.width = 1, i.height = 1, i;\n}\nfunction yg() {\n  if (typeof OffscreenCanvas > \"u\") throw new TypeError(\"failed to create offscreen canvas: OffscreenCanvas is not supported\");\n  return new OffscreenCanvas(1, 1);\n}\nvar mr,\n  Ip = O(() => {\n    \"use strict\";\n\n    Ut();\n    wp();\n    mr = {};\n  });\nvar Yn,\n  _p = O(() => {\n    \"use strict\";\n\n    Yt();\n    Ut();\n    Tp();\n    Ip();\n    Yn = class {\n      get contextId() {\n        return z.webgl.contextId;\n      }\n      set contextId(e) {\n        z.webgl.contextId = e;\n      }\n      get matmulMaxBatchSize() {\n        return z.webgl.matmulMaxBatchSize;\n      }\n      set matmulMaxBatchSize(e) {\n        z.webgl.matmulMaxBatchSize = e;\n      }\n      get textureCacheMode() {\n        return z.webgl.textureCacheMode;\n      }\n      set textureCacheMode(e) {\n        z.webgl.textureCacheMode = e;\n      }\n      get pack() {\n        return z.webgl.pack;\n      }\n      set pack(e) {\n        z.webgl.pack = e;\n      }\n      get async() {\n        return z.webgl.async;\n      }\n      set async(e) {\n        z.webgl.async = e;\n      }\n      initialize() {\n        try {\n          return this.glContext = Gi(this.contextId), typeof this.matmulMaxBatchSize != \"number\" && (this.matmulMaxBatchSize = 16), typeof this.textureCacheMode != \"string\" && (this.textureCacheMode = \"full\"), typeof this.pack != \"boolean\" && (this.pack = !1), typeof this.async != \"boolean\" && (this.async = !1), tt.setWithEnv(z), z.webgl.context || Object.defineProperty(z.webgl, \"context\", {\n            value: this.glContext.gl\n          }), tt.verbose(\"WebGLBackend\", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;\n        } catch (e) {\n          return tt.warning(\"WebGLBackend\", `Unable to initialize WebGLBackend. ${e}`), !1;\n        }\n      }\n      createSessionHandler(e) {\n        return new Jn(this, e);\n      }\n      dispose() {\n        this.glContext.dispose();\n      }\n    };\n  });\nfunction Mi(_x1) {\n  return _Mi.apply(this, arguments);\n}\nfunction _Mi() {\n  _Mi = _asyncToGenerator(function* (i) {\n    if (i) {\n      let e = typeof i == \"string\" ? [i] : i;\n      for (let o of e) {\n        let t = Op.get(o);\n        if (t) return t;\n        let r = yield Tg(o);\n        if (r) return r;\n      }\n    } else return Mi([\"webgl\"]);\n    throw new Error(\"no available backend to use\");\n  });\n  return _Mi.apply(this, arguments);\n}\nfunction Tg(_x10) {\n  return _Tg.apply(this, arguments);\n}\nfunction _Tg() {\n  _Tg = _asyncToGenerator(function* (i) {\n    let e = xg;\n    if (typeof e[i] < \"u\" && wg(e[i])) {\n      let o = e[i],\n        t = o.initialize();\n      if (typeof t == \"object\" && \"then\" in t && (t = yield t), t) return Op.set(i, o), o;\n    }\n  });\n  return _Tg.apply(this, arguments);\n}\nfunction wg(i) {\n  let e = i;\n  return \"initialize\" in e && typeof e.initialize == \"function\" && \"createSessionHandler\" in e && typeof e.createSessionHandler == \"function\" && \"dispose\" in e && typeof e.dispose == \"function\";\n}\nvar Op,\n  xg,\n  Sp = O(() => {\n    \"use strict\";\n\n    _p();\n    Op = new Map(), xg = {\n      webgl: new Yn()\n    };\n  });\nvar Ui,\n  Zn,\n  Ap = O(() => {\n    \"use strict\";\n\n    Ut();\n    Ui = class {\n      constructor(e, o) {\n        this.op = e;\n        this.node = o;\n      }\n    }, Zn = class {\n      constructor(e, o, t) {\n        this.graph = e;\n        this.profiler = t;\n        this.initialize(o);\n      }\n      initialize(e) {\n        this.profiler.event(\"session\", \"ExecutionPlan.initialize\", () => {\n          let o = this.graph.getNodes();\n          if (o.length !== e.length) throw new Error(\"The size of nodes and OPs do not match.\");\n          this._ops = e.map((t, r) => new Ui(t, o[r])), this.reset(), this._starter = [], this._ops.forEach((t, r) => {\n            let n = !0;\n            for (let s of t.node.inputs) if (!this._values[s] && this.graph.getInputIndices().indexOf(s) === -1) {\n              n = !1;\n              break;\n            }\n            n && this._starter.push(r);\n          });\n        });\n      }\n      reset() {\n        this._values = this.graph.getValues().map(e => e.tensor);\n      }\n      execute(e, o) {\n        var _this22 = this;\n        return _asyncToGenerator(function* () {\n          return _this22.profiler.event(\"session\", \"ExecutionPlan.execute\", /*#__PURE__*/_asyncToGenerator(function* () {\n            _this22.reset();\n            let t = e.createInferenceHandler(),\n              r = _this22.graph.getInputIndices();\n            if (o.length !== r.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${o.length} expected: ${r.length}`);\n            o.forEach((f, p) => {\n              let d = r[p];\n              _this22._values[d] = f;\n            });\n            let n = _this22._starter.slice(0),\n              s = _this22.graph.getValues(),\n              a = _this22.graph.getNodes(),\n              u = 0;\n            for (; u < n.length;) {\n              let f = n[u++],\n                p = _this22._ops[f],\n                d = p.node.inputs.map(S => _this22._values[S]);\n              if (d.indexOf(void 0) !== -1) throw new Error(`unresolved input detected: op: ${p.node}`);\n              let y = d;\n              tt.verbose(\"ExecPlan\", `Running op:${p.node.name} (${y.map((S, L) => `'${p.node.inputs[L]}': ${S.type}[${S.dims.join(\",\")}]`).join(\", \")})`);\n              let T = yield _this22.profiler.event(\"node\", p.node.name, /*#__PURE__*/_asyncToGenerator(function* () {\n                return p.op.impl(t, y, p.op.context);\n              }));\n              if (T.length !== p.node.outputs.length) throw new Error(\"the size of output does not match model definition.\");\n              T.forEach((S, L) => {\n                let P = p.node.outputs[L];\n                if (_this22._values[P]) throw new Error(`output [${P}] already has value: op:${p.node.name}`);\n                _this22._values[P] = S;\n              });\n              let v = new Set();\n              T.forEach((S, L) => {\n                let P = p.node.outputs[L];\n                for (let A of s[P].to) {\n                  let M = a[A],\n                    V = !0;\n                  for (let lt of M.inputs) if (!_this22._values[lt]) {\n                    V = !1;\n                    break;\n                  }\n                  V && v.add(A);\n                }\n              }), n.push(...v);\n            }\n            let l = [];\n            for (let f = 0; f < _this22.graph.getOutputIndices().length; f++) {\n              let p = _this22.graph.getOutputIndices()[f],\n                d = _this22._values[p];\n              if (d === void 0) throw new Error(`required output [${p}] does not have value`);\n              p === 0 ? yield d.getData() : d.data, l.push(d);\n            }\n            return tt.verbose(\"ExecPlan\", \"disposing of inferenceHandler\"), t.dispose(), l;\n          }));\n        })();\n      }\n    };\n  });\nvar q,\n  Xt,\n  Ur,\n  Pp = O(() => {\n    \"use strict\";\n\n    Pr();\n    q = rr(sr());\n    We();\n    Y();\n    Xt = F.experimental.fbs, Ur = class i {\n      constructor(e) {\n        if (this._attributes = new Map(), e != null) {\n          for (let o of e) o instanceof q.onnx.AttributeProto ? this._attributes.set(o.name, [i.getValue(o), i.getType(o)]) : o instanceof Xt.Attribute && this._attributes.set(o.name(), [i.getValue(o), i.getType(o)]);\n          if (this._attributes.size < e.length) throw new Error(\"duplicated attribute names\");\n        }\n      }\n      set(e, o, t) {\n        this._attributes.set(e, [t, o]);\n      }\n      delete(e) {\n        this._attributes.delete(e);\n      }\n      getFloat(e, o) {\n        return this.get(e, \"float\", o);\n      }\n      getInt(e, o) {\n        return this.get(e, \"int\", o);\n      }\n      getString(e, o) {\n        return this.get(e, \"string\", o);\n      }\n      getTensor(e, o) {\n        return this.get(e, \"tensor\", o);\n      }\n      getFloats(e, o) {\n        return this.get(e, \"floats\", o);\n      }\n      getInts(e, o) {\n        return this.get(e, \"ints\", o);\n      }\n      getStrings(e, o) {\n        return this.get(e, \"strings\", o);\n      }\n      getTensors(e, o) {\n        return this.get(e, \"tensors\", o);\n      }\n      get(e, o, t) {\n        let r = this._attributes.get(e);\n        if (r === void 0) {\n          if (t !== void 0) return t;\n          throw new Error(`required attribute not found: ${e}`);\n        }\n        if (r[1] !== o) throw new Error(`type mismatch: expected ${o} but got ${r[1]}`);\n        return r[0];\n      }\n      static getType(e) {\n        let o = e instanceof q.onnx.AttributeProto ? e.type : e.type();\n        switch (o) {\n          case q.onnx.AttributeProto.AttributeType.FLOAT:\n            return \"float\";\n          case q.onnx.AttributeProto.AttributeType.INT:\n            return \"int\";\n          case q.onnx.AttributeProto.AttributeType.STRING:\n            return \"string\";\n          case q.onnx.AttributeProto.AttributeType.TENSOR:\n            return \"tensor\";\n          case q.onnx.AttributeProto.AttributeType.FLOATS:\n            return \"floats\";\n          case q.onnx.AttributeProto.AttributeType.INTS:\n            return \"ints\";\n          case q.onnx.AttributeProto.AttributeType.STRINGS:\n            return \"strings\";\n          case q.onnx.AttributeProto.AttributeType.TENSORS:\n            return \"tensors\";\n          default:\n            throw new Error(`attribute type is not supported yet: ${q.onnx.AttributeProto.AttributeType[o]}`);\n        }\n      }\n      static getValue(e) {\n        let o = e instanceof q.onnx.AttributeProto ? e.type : e.type();\n        if (o === q.onnx.AttributeProto.AttributeType.GRAPH || o === q.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error(\"graph attribute is not supported yet\");\n        let t = this.getValueNoCheck(e);\n        if (o === q.onnx.AttributeProto.AttributeType.INT && Rt.isLong(t)) return Rt.longToNumber(t);\n        if (o === q.onnx.AttributeProto.AttributeType.INTS) {\n          let r = t,\n            n = new Array(r.length);\n          for (let s = 0; s < r.length; s++) {\n            let a = r[s];\n            n[s] = Rt.longToNumber(a);\n          }\n          return n;\n        }\n        if (o === q.onnx.AttributeProto.AttributeType.TENSOR) return e instanceof q.onnx.AttributeProto ? bt.fromProto(t) : bt.fromOrtTensor(t);\n        if (o === q.onnx.AttributeProto.AttributeType.TENSORS) {\n          if (e instanceof q.onnx.AttributeProto) return t.map(n => bt.fromProto(n));\n          if (e instanceof Xt.Attribute) return t.map(n => bt.fromOrtTensor(n));\n        }\n        return o === q.onnx.AttributeProto.AttributeType.STRING && e instanceof q.onnx.AttributeProto ? kr(t) : o === q.onnx.AttributeProto.AttributeType.STRINGS && e instanceof q.onnx.AttributeProto ? t.map(kr) : t;\n      }\n      static getValueNoCheck(e) {\n        return e instanceof q.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e) : this.getValueNoCheckFromOrtFormat(e);\n      }\n      static getValueNoCheckFromOnnxFormat(e) {\n        switch (e.type) {\n          case q.onnx.AttributeProto.AttributeType.FLOAT:\n            return e.f;\n          case q.onnx.AttributeProto.AttributeType.INT:\n            return e.i;\n          case q.onnx.AttributeProto.AttributeType.STRING:\n            return e.s;\n          case q.onnx.AttributeProto.AttributeType.TENSOR:\n            return e.t;\n          case q.onnx.AttributeProto.AttributeType.GRAPH:\n            return e.g;\n          case q.onnx.AttributeProto.AttributeType.FLOATS:\n            return e.floats;\n          case q.onnx.AttributeProto.AttributeType.INTS:\n            return e.ints;\n          case q.onnx.AttributeProto.AttributeType.STRINGS:\n            return e.strings;\n          case q.onnx.AttributeProto.AttributeType.TENSORS:\n            return e.tensors;\n          case q.onnx.AttributeProto.AttributeType.GRAPHS:\n            return e.graphs;\n          default:\n            throw new Error(`unsupported attribute type: ${q.onnx.AttributeProto.AttributeType[e.type]}`);\n        }\n      }\n      static getValueNoCheckFromOrtFormat(e) {\n        switch (e.type()) {\n          case Xt.AttributeType.FLOAT:\n            return e.f();\n          case Xt.AttributeType.INT:\n            return e.i();\n          case Xt.AttributeType.STRING:\n            return e.s();\n          case Xt.AttributeType.TENSOR:\n            return e.t();\n          case Xt.AttributeType.GRAPH:\n            return e.g();\n          case Xt.AttributeType.FLOATS:\n            return e.floatsArray();\n          case Xt.AttributeType.INTS:\n            {\n              let o = [];\n              for (let t = 0; t < e.intsLength(); t++) o.push(e.ints(t));\n              return o;\n            }\n          case Xt.AttributeType.STRINGS:\n            {\n              let o = [];\n              for (let t = 0; t < e.stringsLength(); t++) o.push(e.strings(t));\n              return o;\n            }\n          case Xt.AttributeType.TENSORS:\n            {\n              let o = [];\n              for (let t = 0; t < e.tensorsLength(); t++) o.push(e.tensors(t));\n              return o;\n            }\n          default:\n            throw new Error(`unsupported attribute type: ${Xt.AttributeType[e.type()]}`);\n        }\n      }\n    };\n  });\nvar zi,\n  Qn,\n  Wi,\n  me,\n  to,\n  Vi,\n  Ep = O(() => {\n    \"use strict\";\n\n    Pp();\n    Pr();\n    zi = rr(sr());\n    We();\n    Y();\n    Qn = F.experimental.fbs, Wi = {\n      from: (i, e) => new Vi(i, e)\n    }, me = class {\n      constructor(e) {\n        this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e && (this.type = At.tensorValueTypeFromProto(e.type.tensorType));\n      }\n      get from() {\n        return this._from;\n      }\n      get to() {\n        return this._to;\n      }\n    }, to = class {\n      constructor(e, o) {\n        e instanceof zi.onnx.NodeProto ? (this.name = e.name, this.opType = e.opType, this.attributes = new Ur(e.attribute)) : e instanceof Qn.Node && (this.name = o ?? e.name(), this.opType = e.opType(), this.attributes = new Ur(At.tensorAttributesFromORTFormat(e))), this.inputs = [], this.outputs = [], this.executeNode = !0;\n      }\n    }, Vi = class {\n      constructor(e, o) {\n        if (!e) throw new TypeError(\"graph is empty\");\n        this.buildGraph(e), this.transformGraph(o), this.checkIsAcyclic();\n      }\n      getInputIndices() {\n        return this._allInputIndices;\n      }\n      getInputNames() {\n        return this._allInputNames;\n      }\n      getOutputIndices() {\n        return this._allOutputIndices;\n      }\n      getOutputNames() {\n        return this._allOutputNames;\n      }\n      getValues() {\n        return this._allData;\n      }\n      getNodes() {\n        return this._nodes;\n      }\n      buildGraph(e) {\n        if (e instanceof zi.onnx.GraphProto) this.buildGraphFromOnnxFormat(e);else if (e instanceof Qn.Graph) this.buildGraphFromOrtFormat(e);else throw new TypeError(\"Graph type is not supported.\");\n      }\n      buildGraphFromOnnxFormat(e) {\n        let o = new Map();\n        this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n        let t = new Map();\n        if (!e.input) throw new Error(\"missing information in graph: input\");\n        let r = [];\n        for (let n of e.input) {\n          if (o.has(n.name)) throw new Error(`duplicated input name: ${n.name}`);\n          let s = this._allData.push(new me(n)) - 1;\n          o.set(n.name, s), r.push(n.name);\n        }\n        if (!e.initializer) throw new Error(\"missing information in graph: initializer\");\n        for (let n of e.initializer) {\n          let s = o.get(n.name);\n          if (s === void 0) {\n            let a = new me();\n            a.type = {\n              shape: {\n                dims: At.tensorDimsFromProto(n.dims)\n              },\n              tensorType: At.tensorDataTypeFromProto(n.dataType)\n            }, s = this._allData.push(a) - 1, o.set(n.name, s);\n          }\n          this._allData[s]._from = -1, this._allData[s].tensor = bt.fromProto(n);\n        }\n        for (let n = 0; n < this._allData.length; n++) this._allData[n].tensor || (this._allInputIndices.push(n), this._allInputNames.push(r[n]));\n        if (!e.output) throw new Error(\"missing information in graph: output\");\n        for (let n of e.output) {\n          if (o.has(n.name)) throw new Error(`duplicated output name: ${n.name}`);\n          let s = this._allData.push(new me(n)) - 1;\n          o.set(n.name, s), this._allOutputIndices.push(s), this._allOutputNames.push(n.name);\n        }\n        if (!e.node) throw new Error(\"missing information in graph: node\");\n        for (let n of e.node) {\n          if (!n.name) for (let a = 0;; a++) {\n            let u = `unnamed_${n.opType}_${a}`;\n            if (!t.has(u)) {\n              n.name = u;\n              break;\n            }\n          }\n          if (t.has(n.name)) throw new Error(`duplicated node name: ${n.name}`);\n          let s = this._nodes.push(new to(n)) - 1;\n          t.set(n.name, s);\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.node[n];\n          if (!a.output) throw new Error(`missing output for node: ${a.name}`);\n          for (let u of a.output) {\n            let l = o.get(u);\n            if (typeof l > \"u\" && (l = this._allData.push(new me()) - 1, o.set(u, l)), s.outputs.push(l), this._allData[l]._from !== void 0) throw new Error(`multiple nodes output to one data value: ${l}`);\n            if (this._allData[l]._from = n, a.opType === \"Constant\") {\n              if (!a.attribute || a.attribute.length !== 1 || !a.attribute[0].t) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n              if (!a.output || a.output.length !== 1) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n              s.outputs.pop(), s.executeNode = !1, this._allData[l]._from = -1, this._allData[l].tensor = bt.fromProto(a.attribute[0].t);\n            }\n          }\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.node[n];\n          if (!a.input) throw new Error(`missing input for node: ${a.name}`);\n          for (let u of a.input) {\n            let l = o.get(u);\n            if (typeof l > \"u\") {\n              if (u === \"\" && (a.input.length === 3 || a.input.length === 4) && a.opType === \"Resize\") continue;\n              throw new Error(`unrecognized input '${u}' for node: ${a.name}`);\n            }\n            s.inputs.push(l), this._allData[l]._to.push(n);\n          }\n        }\n        return !0;\n      }\n      buildGraphFromOrtFormat(e) {\n        let o = new Map();\n        this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n        let t = new Map(),\n          r = [];\n        for (let n = 0; n < e.inputsLength(); n++) {\n          let s = e.inputs(n);\n          if (o.has(s)) throw new Error(`duplicated input name: ${s}`);\n          for (let a = 0; a < e.nodeArgsLength(); a++) if (e.nodeArgs(a)?.name() === s) {\n            let u = new me();\n            if (e.nodeArgs(a)?.type()?.valueType() !== Qn.TypeInfoValue.tensor_type) throw new Error(\"Unexpected value type for the nodeArg.\");\n            let f = e.nodeArgs(a).type().value(new Qn.TensorTypeAndShape()),\n              p = At.tensorDataTypeFromProto(f.elemType()),\n              d = f.shape(),\n              y = [];\n            for (let v = 0; v < d.dimLength(); v++) y.push(Rt.longToNumber(d.dim(v).value().dimValue()));\n            u.type = {\n              shape: {\n                dims: y\n              },\n              tensorType: p\n            };\n            let T = this._allData.push(u) - 1;\n            o.set(s, T), r.push(s);\n          }\n        }\n        for (let n = 0; n < e.initializersLength(); n++) {\n          let s = e.initializers(n),\n            a = o.get(s.name());\n          if (a === void 0) {\n            let u = new me(),\n              l = At.tensorDimsFromORTFormat(s),\n              f = At.tensorDataTypeFromProto(s.dataType());\n            u.type = {\n              shape: {\n                dims: l\n              },\n              tensorType: f\n            }, a = this._allData.push(u) - 1, o.set(s.name(), a);\n          }\n          this._allData[a]._from = -1, this._allData[a].tensor = bt.fromOrtTensor(s);\n        }\n        for (let n = 0; n < this._allData.length; n++) this._allData[n].tensor || (this._allInputIndices.push(n), this._allInputNames.push(r[n]));\n        for (let n = 0; n < e.outputsLength(); n++) {\n          let s = e.outputs(n);\n          if (o.has(s)) throw new Error(`duplicated output name: ${s}`);\n          let a = this._allData.push(new me()) - 1;\n          o.set(s, a), this._allOutputIndices.push(a), this._allOutputNames.push(s);\n        }\n        if (!e.nodes) throw new Error(\"missing information in graph: node\");\n        for (let n = 0; n < e.nodesLength(); n++) {\n          let s = e.nodes(n),\n            a = s.name();\n          if (!a) for (let l = 0; a = `unnamed_${s.opType()}_${l}`, !!t.has(a); l++);\n          if (t.has(a)) throw new Error(`duplicated node name: ${a}`);\n          let u = this._nodes.push(new to(s, a)) - 1;\n          t.set(a, u);\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.nodes(n);\n          if (a == null) throw new Error(`No node exists at index ${n}`);\n          if (a?.outputsLength() === 0) throw new Error(`missing output for node: ${a.name}`);\n          for (let u = 0; u < a?.outputsLength(); u++) {\n            let l = a?.outputs(u),\n              f = o.get(l);\n            if (typeof f > \"u\" && (f = this._allData.push(new me()) - 1, o.set(l, f)), s.outputs.push(f), this._allData[f]._from !== void 0) throw new Error(`multiple nodes output to one data value: ${f}`);\n            if (this._allData[f]._from = n, a.opType() === \"Constant\") {\n              if (a.attributesLength() !== 1 || !a.attributes(0).t()) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n              if (a.outputsLength() !== 1) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n              s.outputs.pop(), s.executeNode = !1, this._allData[f]._from = -1, this._allData[f].tensor = bt.fromOrtTensor(a.attributes(0).t());\n            }\n          }\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.nodes(n);\n          if (a.inputsLength() === 0) throw new Error(`missing input for node: ${a.name}`);\n          for (let u = 0; u < a.inputsLength(); u++) {\n            let l = a.inputs(u),\n              f = o.get(l);\n            if (typeof f > \"u\") throw new Error(`unrecognized input '${l}' for node: ${a.name()}`);\n            s.inputs.push(f), this._allData[f]._to.push(n);\n          }\n        }\n      }\n      checkIsAcyclic() {\n        let e = new Set();\n        this._allInputIndices.forEach(r => {\n          this._allData[r]._to.forEach(s => {\n            e.add(s);\n          });\n        });\n        let o = Array.from(e),\n          t = new Array(this._nodes.length).fill(\"white\");\n        for (; o.length > 0;) {\n          let r = o.pop();\n          t[r] === \"gray\" ? t[r] = \"black\" : (o.push(r), t[r] = \"gray\", this._nodes[r].outputs.forEach(n => {\n            let s = this._allData[n];\n            if (typeof s.tensor < \"u\") throw new Error(\"node outputs should not be initialized\");\n            if (s._from !== r) throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n            s._to.forEach(a => {\n              if (t[a] === \"gray\") throw new Error(\"model graph is cyclic\");\n              t[a] === \"white\" && o.push(a);\n            });\n          }));\n        }\n      }\n      transformGraph(e) {\n        this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e && e.transformGraph(this), this.finalizeGraph();\n      }\n      finalizeGraph() {\n        let e = 0,\n          o = new Array(this._nodes.length, 0),\n          t = 0;\n        for (let r = 0; r < this._nodes.length; r++) o[r] = t, this._nodes[r].executeNode ? (t !== r && (this._nodes[t] = this._nodes[r]), t++) : this._nodes[r].outputs.forEach(n => {\n          this._allData[n]._from = -2;\n        });\n        this._nodes.splice(t, this._nodes.length - t);\n        for (let r = 0; r < this._allData.length; r++) {\n          let n = this._allData[r];\n          n._from !== void 0 && n._from !== -1 && n._from !== -2 && (n._from = o[n._from]);\n          for (let s = 0; s < n._to.length; s++) if (n._to[s] >= 0) n._to[s] = o[n._to[s]];else throw new Error(\"Trying to update a removed node\");\n        }\n        e = 0;\n        for (let r = 0; r < this._allData.length; r++) {\n          if (this._allData[r].from === -2 && this._allOutputIndices.indexOf(r + e) === -1) {\n            e++, this._allData.splice(r, 1), r--;\n            continue;\n          }\n          if (e > 0) {\n            let n = -1;\n            this._allData[r].from !== void 0 && this._allData[r].from !== -1 ? (n = this._nodes[this._allData[r].from].outputs.indexOf(r + e), n !== -1 && (this._nodes[this._allData[r].from].outputs[n] = r)) : (n = this._allInputIndices.indexOf(r + e), n !== -1 && (this._allInputIndices[n] = r)), this._allData[r].to.forEach(s => {\n              n = this._nodes[s].inputs.indexOf(r + e), n !== -1 && (this._nodes[s].inputs[n] = r);\n            }), this._allData[r].to.length === 0 && (n = this._allOutputIndices.indexOf(r + e), n !== -1 && (this._allOutputIndices[n] = r));\n          }\n        }\n      }\n      deleteNode(e) {\n        let o = this._nodes[e];\n        if (o.outputs.length > 1) {\n          for (let a = 1; a < o.outputs.length; a++) if (this._allData[o.outputs[a]].to.length > 0) throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");\n        }\n        o.executeNode = !1;\n        let t = o.inputs[0],\n          r = o.outputs[0],\n          n = this._allData[r].to;\n        for (let a = 0; a < o.inputs.length; a++) {\n          let u = this._allData[o.inputs[a]].to.indexOf(e);\n          if (u === -1) throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n          this._allData[o.inputs[a]].to.splice(u, 1);\n        }\n        this._allData[r]._to = [];\n        let s = this._allOutputIndices.indexOf(r);\n        if (s !== -1 && (this._allOutputIndices[s] = t), n && n.length > 0) for (let a of n) {\n          let u = this._nodes[a].inputs.indexOf(r);\n          if (u === -1) throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n          this._nodes[a].inputs[u] = t, this._allData[t].to.push(a);\n        }\n      }\n      removeAllDropoutNodes() {\n        let e = 0;\n        for (let o of this._nodes) {\n          if (o.opType === \"Dropout\") {\n            if (o.inputs.length !== 1) throw new Error(\"Dropout nodes should only contain one input. \");\n            if (o.outputs.length !== 1 && o.outputs.length !== 2) throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");\n            if (o.outputs.length === 2 && this._allData[o.outputs[1]]._to.length !== 0) throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n            this.deleteNode(e);\n          }\n          e++;\n        }\n      }\n      removeAllIdentityNodes() {\n        let e = 0;\n        for (let o of this._nodes) o.opType === \"Identity\" && this.deleteNode(e), e++;\n      }\n      isActivation(e) {\n        switch (e.opType) {\n          case \"Relu\":\n          case \"Sigmoid\":\n          case \"Clip\":\n            return !0;\n          default:\n            return !1;\n        }\n      }\n      fuseConvActivationNodes() {\n        for (let e of this._nodes) if (e.opType === \"Conv\") {\n          let o = this._allData[e.outputs[0]]._to;\n          if (o.length === 1 && this.isActivation(this._nodes[o[0]])) {\n            let t = this._nodes[o[0]];\n            if (t.opType === \"Clip\") if (t.inputs.length === 1) try {\n              e.attributes.set(\"activation_params\", \"floats\", [t.attributes.getFloat(\"min\"), t.attributes.getFloat(\"max\")]);\n            } catch {\n              e.attributes.set(\"activation_params\", \"floats\", [Ve, ze]);\n            } else if (t.inputs.length >= 3 && this._allData[t.inputs[1]].tensor !== void 0 && this._allData[t.inputs[2]].tensor !== void 0) e.attributes.set(\"activation_params\", \"floats\", [this._allData[t.inputs[1]].tensor.floatData[0], this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;\n            e.attributes.set(\"activation\", \"string\", t.opType), this.deleteNode(o[0]);\n          }\n        }\n      }\n    };\n  });\nvar Dp,\n  vg,\n  eo,\n  Lp = O(() => {\n    \"use strict\";\n\n    wn();\n    Ep();\n    Pr();\n    Dp = rr(sr());\n    Y();\n    vg = F.experimental.fbs, eo = class {\n      constructor() {}\n      load(e, o, t) {\n        let r;\n        if (!t) try {\n          this.loadFromOnnxFormat(e, o);\n          return;\n        } catch (n) {\n          if (t !== void 0) throw n;\n          r = n;\n        }\n        try {\n          this.loadFromOrtFormat(e, o);\n        } catch (n) {\n          throw t !== void 0 ? n : new Error(`Failed to load model as ONNX format: ${r}\nas ORT format: ${n}`);\n        }\n      }\n      loadFromOnnxFormat(e, o) {\n        let t = Dp.onnx.ModelProto.decode(e);\n        if (Rt.longToNumber(t.irVersion) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n        this._opsets = t.opsetImport.map(n => ({\n          domain: n.domain,\n          version: Rt.longToNumber(n.version)\n        })), this._graph = Wi.from(t.graph, o);\n      }\n      loadFromOrtFormat(e, o) {\n        let t = new w.ByteBuffer(e),\n          r = vg.InferenceSession.getRootAsInferenceSession(t).model();\n        if (Rt.longToNumber(r.irVersion()) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n        this._opsets = [];\n        for (let s = 0; s < r.opsetImportLength(); s++) {\n          let a = r.opsetImport(s);\n          this._opsets.push({\n            domain: a?.domain(),\n            version: Rt.longToNumber(a.version())\n          });\n        }\n        this._graph = Wi.from(r.graph(), o);\n      }\n      get graph() {\n        return this._graph;\n      }\n      get opsets() {\n        return this._opsets;\n      }\n    };\n  });\nvar ro,\n  $p = O(() => {\n    \"use strict\";\n\n    Sp();\n    Ap();\n    Ut();\n    Lp();\n    ro = class {\n      constructor(e = {}) {\n        this._initialized = !1, this.backendHint = e.backendHint, this.profiler = xn.create(e.profiler), this.context = {\n          profiler: this.profiler,\n          graphInputTypes: [],\n          graphInputDims: []\n        };\n      }\n      get inputNames() {\n        return this._model.graph.getInputNames();\n      }\n      get outputNames() {\n        return this._model.graph.getOutputNames();\n      }\n      startProfiling() {\n        this.profiler.start();\n      }\n      endProfiling() {\n        this.profiler.stop();\n      }\n      loadModel(e, o, t) {\n        var _this23 = this;\n        return _asyncToGenerator(function* () {\n          yield _this23.profiler.event(\"session\", \"Session.loadModel\", /*#__PURE__*/_asyncToGenerator(function* () {\n            let r = yield Mi(_this23.backendHint);\n            if (_this23.sessionHandler = r.createSessionHandler(_this23.context), _this23._model = new eo(), typeof e == \"string\") {\n              let n = e.endsWith(\".ort\");\n              {\n                let a = yield (yield fetch(e)).arrayBuffer();\n                _this23.initialize(new Uint8Array(a), n);\n              }\n            } else if (ArrayBuffer.isView(e)) _this23.initialize(e);else {\n              let n = new Uint8Array(e, o || 0, t || e.byteLength);\n              _this23.initialize(n);\n            }\n          }));\n        })();\n      }\n      initialize(e, o) {\n        if (this._initialized) throw new Error(\"already initialized\");\n        this.profiler.event(\"session\", \"Session.initialize\", () => {\n          let t = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;\n          this._model.load(e, t, o), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new Zn(this._model.graph, this._ops, this.profiler);\n        }), this._initialized = !0;\n      }\n      run(e) {\n        var _this24 = this;\n        return _asyncToGenerator(function* () {\n          if (!_this24._initialized) throw new Error(\"session not initialized yet\");\n          return _this24.profiler.event(\"session\", \"Session.run\", /*#__PURE__*/_asyncToGenerator(function* () {\n            let o = _this24.normalizeAndValidateInputs(e),\n              t = yield _this24._executionPlan.execute(_this24.sessionHandler, o);\n            return _this24.createOutput(t);\n          }));\n        })();\n      }\n      normalizeAndValidateInputs(e) {\n        let o = this._model.graph.getInputNames();\n        if (Array.isArray(e)) {\n          if (e.length !== o.length) throw new Error(`incorrect input array length: expected ${o.length} but got ${e.length}`);\n        } else {\n          if (e.size !== o.length) throw new Error(`incorrect input map size: expected ${o.length} but got ${e.size}`);\n          let t = new Array(e.size),\n            r = 0;\n          for (let n = 0; n < o.length; ++n) {\n            let s = e.get(o[n]);\n            if (!s) throw new Error(`missing input tensor for: '${name}'`);\n            t[r++] = s;\n          }\n          e = t;\n        }\n        if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {\n          let t = this._model.graph.getInputIndices(),\n            r = this._model.graph.getValues(),\n            n = new Array(t.length);\n          for (let s = 0; s < t.length; ++s) {\n            let a = r[t[s]];\n            n[s] = a.type.shape.dims, this.context.graphInputTypes.push(a.type.tensorType), this.context.graphInputDims.push(e[s].dims);\n          }\n          this.validateInputTensorDims(n, e, !0);\n        } else this.validateInputTensorDims(this.context.graphInputDims, e, !1);\n        return this.validateInputTensorTypes(this.context.graphInputTypes, e), e;\n      }\n      validateInputTensorTypes(e, o) {\n        for (let t = 0; t < o.length; t++) {\n          let r = e[t],\n            n = o[t].type;\n          if (r !== n) throw new Error(`input tensor[${t}] check failed: expected type '${r}' but got ${n}`);\n        }\n      }\n      validateInputTensorDims(e, o, t) {\n        for (let r = 0; r < o.length; r++) {\n          let n = e[r],\n            s = o[r].dims;\n          if (!this.compareTensorDims(n, s, t)) throw new Error(`input tensor[${r}] check failed: expected shape '[${n.join(\",\")}]' but got [${s.join(\",\")}]`);\n        }\n      }\n      compareTensorDims(e, o, t) {\n        if (e.length !== o.length) return !1;\n        for (let r = 0; r < e.length; ++r) if (e[r] !== o[r] && (!t || e[r] !== 0)) return !1;\n        return !0;\n      }\n      createOutput(e) {\n        let o = this._model.graph.getOutputNames();\n        if (e.length !== o.length) throw new Error(\"expected number of outputs do not match number of generated outputs\");\n        let t = new Map();\n        for (let r = 0; r < o.length; ++r) t.set(o[r], e[r]);\n        return t;\n      }\n      initializeOps(e) {\n        let o = e.getNodes();\n        this._ops = new Array(o.length);\n        for (let t = 0; t < o.length; t++) this._ops[t] = this.sessionHandler.resolve(o[t], this._model.opsets, e);\n      }\n    };\n  });\nvar no,\n  kp = O(() => {\n    \"use strict\";\n\n    Yt();\n    We();\n    no = class {\n      constructor(e) {\n        this.session = e;\n        this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;\n      }\n      dispose() {\n        return _asyncToGenerator(function* () {})();\n      }\n      run(e, o, t) {\n        var _this25 = this;\n        return _asyncToGenerator(function* () {\n          let r = new Map();\n          for (let a in e) if (Object.hasOwnProperty.call(e, a)) {\n            let u = e[a];\n            r.set(a, new bt(u.dims, u.type, void 0, void 0, u.data));\n          }\n          let n = yield _this25.session.run(r),\n            s = {};\n          return n.forEach((a, u) => {\n            s[u] = new yt(a.type, a.data, a.dims);\n          }), s;\n        })();\n      }\n      startProfiling() {\n        this.session.startProfiling();\n      }\n      endProfiling() {\n        this.session.endProfiling();\n      }\n    };\n  });\nvar Bp = {};\nOr(Bp, {\n  onnxjsBackend: () => Ig\n});\nvar Hi,\n  Ig,\n  Fp = O(() => {\n    \"use strict\";\n\n    $p();\n    kp();\n    Hi = class {\n      init() {\n        return _asyncToGenerator(function* () {})();\n      }\n      createInferenceSessionHandler(e, o) {\n        return _asyncToGenerator(function* () {\n          let t = new ro(o);\n          return typeof e == \"string\" ? yield t.loadModel(e) : yield t.loadModel(e), new no(t);\n        })();\n      }\n    }, Ig = new Hi();\n  });\nvar oo = O(() => {\n  \"use strict\";\n});\nvar Rp = {};\nOr(Rp, {\n  default: () => _g\n});\nvar Cp,\n  Np,\n  _g,\n  Gp = O(() => {\n    \"use strict\";\n\n    qi();\n    Ke();\n    Vr();\n    Cp = \"ort-wasm-proxy-worker\", Np = globalThis.self?.name === Cp;\n    Np && (self.onmessage = i => {\n      let {\n        type: e,\n        in: o\n      } = i.data;\n      try {\n        switch (e) {\n          case \"init-wasm\":\n            io(o.wasm).then(() => {\n              ao(o).then(() => {\n                postMessage({\n                  type: e\n                });\n              }, t => {\n                postMessage({\n                  type: e,\n                  err: t\n                });\n              });\n            }, t => {\n              postMessage({\n                type: e,\n                err: t\n              });\n            });\n            break;\n          case \"init-ep\":\n            {\n              let {\n                epName: t,\n                env: r\n              } = o;\n              so(r, t).then(() => {\n                postMessage({\n                  type: e\n                });\n              }, n => {\n                postMessage({\n                  type: e,\n                  err: n\n                });\n              });\n              break;\n            }\n          case \"copy-from\":\n            {\n              let {\n                  buffer: t\n                } = o,\n                r = zr(t);\n              postMessage({\n                type: e,\n                out: r\n              });\n              break;\n            }\n          case \"create\":\n            {\n              let {\n                model: t,\n                options: r\n              } = o;\n              uo(t, r).then(n => {\n                postMessage({\n                  type: e,\n                  out: n\n                });\n              }, n => {\n                postMessage({\n                  type: e,\n                  err: n\n                });\n              });\n              break;\n            }\n          case \"release\":\n            lo(o), postMessage({\n              type: e\n            });\n            break;\n          case \"run\":\n            {\n              let {\n                sessionId: t,\n                inputIndices: r,\n                inputs: n,\n                outputIndices: s,\n                options: a\n              } = o;\n              fo(t, r, n, s, new Array(s.length).fill(null), a).then(u => {\n                u.some(l => l[3] !== \"cpu\") ? postMessage({\n                  type: e,\n                  err: \"Proxy does not support non-cpu tensor location.\"\n                }) : postMessage({\n                  type: e,\n                  out: u\n                }, po([...n, ...u]));\n              }, u => {\n                postMessage({\n                  type: e,\n                  err: u\n                });\n              });\n              break;\n            }\n          case \"end-profiling\":\n            co(o), postMessage({\n              type: e\n            });\n            break;\n          default:\n        }\n      } catch (t) {\n        postMessage({\n          type: e,\n          err: t\n        });\n      }\n    });\n    _g = Np ? null : i => new Worker(i ?? br, {\n      type: \"module\",\n      name: Cp\n    });\n  });\nvar Up = {};\nOr(Up, {\n  default: () => Og\n});\nvar ji,\n  Mp,\n  Og,\n  Vp = O(() => {\n    \"use strict\";\n\n    Mp = (ji = import.meta.url, /*#__PURE__*/_asyncToGenerator(function* (i = {}) {\n      function e() {\n        return C.buffer != oe.buffer && it(), oe;\n      }\n      function o() {\n        return C.buffer != oe.buffer && it(), be;\n      }\n      function t() {\n        return C.buffer != oe.buffer && it(), Z;\n      }\n      function r() {\n        return C.buffer != oe.buffer && it(), ge;\n      }\n      function n() {\n        return C.buffer != oe.buffer && it(), ae;\n      }\n      var s,\n        a,\n        u = Object.assign({}, i),\n        l = new Promise((c, m) => {\n          s = c, a = m;\n        }),\n        f = typeof window == \"object\",\n        p = typeof importScripts == \"function\",\n        d = p && self.name == \"em-pthread\";\n      u.mountExternalData = (c, m) => {\n        c.startsWith(\"./\") && (c = c.substring(2)), (u.Ua || (u.Ua = new Map())).set(c, m);\n      }, u.unmountExternalData = () => {\n        delete u.Ua;\n      };\n      var y,\n        T,\n        v = globalThis.SharedArrayBuffer ?? new WebAssembly.Memory({\n          initial: 0,\n          maximum: 0,\n          shared: !0\n        }).buffer.constructor,\n        S = Object.assign({}, u),\n        L = \"./this.program\",\n        P = (c, m) => {\n          throw m;\n        },\n        A = \"\";\n      (f || p) && (p ? A = self.location.href : typeof document < \"u\" && document.currentScript && (A = document.currentScript.src), ji && (A = ji), A = A.startsWith(\"blob:\") ? \"\" : A.substr(0, A.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), p && (T = c => {\n        var m = new XMLHttpRequest();\n        return m.open(\"GET\", c, !1), m.responseType = \"arraybuffer\", m.send(null), new Uint8Array(m.response);\n      }), y = (c, m, g) => {\n        var x = new XMLHttpRequest();\n        x.open(\"GET\", c, !0), x.responseType = \"arraybuffer\", x.onload = () => {\n          x.status == 200 || x.status == 0 && x.response ? m(x.response) : g();\n        }, x.onerror = g, x.send(null);\n      });\n      var M,\n        V = console.log.bind(console),\n        lt = console.error.bind(console),\n        wt = V,\n        et = lt;\n      if (Object.assign(u, S), S = null, d) {\n        let c = function (m) {\n          try {\n            var g = m.data,\n              x = g.cmd;\n            if (x === \"load\") {\n              let I = [];\n              self.onmessage = E => I.push(E), self.startWorker = () => {\n                postMessage({\n                  cmd: \"loaded\"\n                });\n                for (let E of I) c(E);\n                self.onmessage = c;\n              };\n              for (let E of g.handlers) u[E] && !u[E].proxy || (u[E] = (...R) => {\n                postMessage({\n                  Za: \"callHandler\",\n                  kb: E,\n                  args: R\n                });\n              }, E == \"print\" && (wt = u[E]), E == \"printErr\" && (et = u[E]));\n              C = g.wasmMemory, it(), Dt(g.wasmModule);\n            } else if (x === \"run\") {\n              $o(g.pthread_ptr, 0, 0, 1, 0, 0), Ao(g.pthread_ptr), md(), aa(), _t ||= !0;\n              try {\n                bd(g.start_routine, g.arg);\n              } catch (I) {\n                if (I != \"unwind\") throw I;\n              }\n            } else x === \"cancel\" ? er() && nn(-1) : g.target !== \"setimmediate\" && (x === \"checkMailbox\" ? _t && tn() : x && (et(`worker: received unknown command ${x}`), et(g)));\n          } catch (I) {\n            throw Ha(), I;\n          }\n        };\n        var Vg = c,\n          Dt,\n          _t = !1;\n        et = function (...m) {\n          m = m.join(\" \"), console.error(m);\n        }, self.alert = function (...m) {\n          postMessage({\n            Za: \"alert\",\n            text: m.join(\" \"),\n            nb: er()\n          });\n        }, u.instantiateWasm = (m, g) => new Promise(x => {\n          Dt = I => {\n            I = new WebAssembly.Instance(I, Yr()), g(I), x();\n          };\n        }), self.onunhandledrejection = m => {\n          throw m.reason || m;\n        }, self.onmessage = c;\n      }\n      u.wasmBinary && (M = u.wasmBinary);\n      var C,\n        Kr,\n        we,\n        oe,\n        be,\n        Z,\n        ge,\n        ie,\n        ae,\n        se = !1;\n      function it() {\n        var c = C.buffer;\n        u.HEAP8 = oe = new Int8Array(c), u.HEAP16 = new Int16Array(c), u.HEAPU8 = be = new Uint8Array(c), u.HEAPU16 = new Uint16Array(c), u.HEAP32 = Z = new Int32Array(c), u.HEAPU32 = ge = new Uint32Array(c), u.HEAPF32 = new Float32Array(c), u.HEAPF64 = ae = new Float64Array(c), u.HEAP64 = ie = new BigInt64Array(c), u.HEAPU64 = new BigUint64Array(c);\n      }\n      if (!d) {\n        if (!((C = new WebAssembly.Memory({\n          initial: 256,\n          maximum: 65536,\n          shared: !0\n        })).buffer instanceof v)) throw et(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), Error(\"bad memory\");\n        it();\n      }\n      var Lt = [],\n        Jr = [],\n        Ye = [],\n        ue = 0,\n        Ze = null,\n        De = null;\n      function le() {\n        if (--ue == 0 && (Ze !== null && (clearInterval(Ze), Ze = null), De)) {\n          var c = De;\n          De = null, c();\n        }\n      }\n      function Mt(c) {\n        throw et(c = \"Aborted(\" + c + \")\"), se = !0, we = 1, c = new WebAssembly.RuntimeError(c + \". Build with -sASSERTIONS for more info.\"), a(c), c;\n      }\n      var ve,\n        gt = c => c.startsWith(\"data:application/octet-stream;base64,\"),\n        Ot = c => c.startsWith(\"file://\");\n      function Jt(c) {\n        if (c == ve && M) return new Uint8Array(M);\n        if (T) return T(c);\n        throw \"both async and sync fetching of the wasm failed\";\n      }\n      function wr(c, m, g) {\n        return function (x) {\n          if (!M && (f || p)) {\n            if (typeof fetch == \"function\" && !Ot(x)) return fetch(x, {\n              credentials: \"same-origin\"\n            }).then(I => {\n              if (!I.ok) throw `failed to load wasm binary file at '${x}'`;\n              return I.arrayBuffer();\n            }).catch(() => Jt(x));\n            if (y) return new Promise((I, E) => {\n              y(x, R => I(new Uint8Array(R)), E);\n            });\n          }\n          return Promise.resolve().then(() => Jt(x));\n        }(c).then(x => WebAssembly.instantiate(x, m)).then(g, x => {\n          et(`failed to asynchronously prepare wasm: ${x}`), Mt(x);\n        });\n      }\n      function Yr() {\n        return {\n          a: {\n            j: hd,\n            b: yd,\n            E: ca,\n            g: ha,\n            V: ma,\n            A: ya,\n            C: xa,\n            W: Ta,\n            T: wa,\n            L: va,\n            S: Ia,\n            o: _a,\n            B: Oa,\n            y: Sa,\n            U: Aa,\n            z: Pa,\n            _: xd,\n            Z: Td,\n            P: wd,\n            w: vd,\n            F: Id,\n            k: _d,\n            O: Ao,\n            Y: Od,\n            I: Sd,\n            J: Ad,\n            K: Pd,\n            G: La,\n            H: $a,\n            v: Ed,\n            q: Dd,\n            l: Ld,\n            p: $d,\n            e: kd,\n            X: Bd,\n            x: Fd,\n            d: ka,\n            f: Cd,\n            i: Nd,\n            u: Rd,\n            t: Gd,\n            s: Md,\n            Q: Ca,\n            R: Na,\n            D: So,\n            h: Ra,\n            n: Ga,\n            M: Ma,\n            m: Ua,\n            a: C,\n            r: Oo,\n            N: Wa,\n            c: zd\n          }\n        };\n      }\n      var ea = {\n        836900: (c, m, g, x, I) => {\n          if (u === void 0 || !u.Ua) return 1;\n          if ((c = Ir(c >>> 0)).startsWith(\"./\") && (c = c.substring(2)), !(c = u.Ua.get(c))) return 2;\n          if (x >>>= 0, (m >>>= 0) + (g >>>= 0) > c.byteLength) return 3;\n          try {\n            let E = c.subarray(m, m + g);\n            switch (I) {\n              case 0:\n                o().set(E, x >>> 0);\n                break;\n              case 1:\n                u.mb(x, E);\n                break;\n              default:\n                return 4;\n            }\n            return 0;\n          } catch {\n            return 4;\n          }\n        },\n        837583: () => typeof wasmOffsetConverter < \"u\"\n      };\n      function hd() {\n        return typeof wasmOffsetConverter < \"u\";\n      }\n      function Io(c) {\n        this.name = \"ExitStatus\", this.message = `Program terminated with exit(${c})`, this.status = c;\n      }\n      var _o = c => {\n          c.terminate(), c.onmessage = () => {};\n        },\n        ra = c => {\n          Ie.length == 0 && (ua(), sa(Ie[0]));\n          var m = Ie.pop();\n          if (!m) return 6;\n          Le.push(m), fe[c.Ra] = m, m.Ra = c.Ra;\n          var g = {\n            cmd: \"run\",\n            start_routine: c.cb,\n            arg: c.ab,\n            pthread_ptr: c.Ra\n          };\n          return m.postMessage(g, c.ib), 0;\n        },\n        vr = 0,\n        st = (c, m, ...g) => {\n          for (var x = 2 * g.length, I = Fo(), E = Bo(8 * x), R = E >>> 3, at = 0; at < g.length; at++) {\n            var Pt = g[at];\n            typeof Pt == \"bigint\" ? (ie[R + 2 * at] = 1n, ie[R + 2 * at + 1] = Pt) : (ie[R + 2 * at] = 0n, n()[R + 2 * at + 1 >>> 0] = Pt);\n          }\n          return c = qa(c, 0, x, E, m), on(I), c;\n        };\n      function Oo(c) {\n        if (d) return st(0, 1, c);\n        if (we = c, !(0 < vr)) {\n          for (var m of Le) _o(m);\n          for (m of Ie) _o(m);\n          Ie = [], Le = [], fe = [], se = !0;\n        }\n        P(c, new Io(c));\n      }\n      function na(c) {\n        if (d) return st(1, 0, c);\n        So(c);\n      }\n      var So = c => {\n          if (we = c, d) throw na(c), \"unwind\";\n          Oo(c);\n        },\n        Ie = [],\n        Le = [],\n        oa = [],\n        fe = {},\n        ia = c => {\n          var m = c.Ra;\n          delete fe[m], Ie.push(c), Le.splice(Le.indexOf(c), 1), c.Ra = 0, ko(m);\n        };\n      function aa() {\n        oa.forEach(c => c());\n      }\n      var sa = c => new Promise(m => {\n        c.onmessage = I => {\n          var E = (I = I.data).cmd;\n          if (I.targetThread && I.targetThread != er()) {\n            var R = fe[I.targetThread];\n            R ? R.postMessage(I, I.transferList) : et(`Internal error! Worker sent a message \"${E}\" to target pthread ${I.targetThread}, but that thread no longer exists!`);\n          } else E === \"checkMailbox\" ? tn() : E === \"spawnThread\" ? ra(I) : E === \"cleanupThread\" ? ia(fe[I.thread]) : E === \"killThread\" ? (I = I.thread, E = fe[I], delete fe[I], _o(E), ko(I), Le.splice(Le.indexOf(E), 1), E.Ra = 0) : E === \"cancelThread\" ? fe[I.thread].postMessage({\n            cmd: \"cancel\"\n          }) : E === \"loaded\" ? (c.loaded = !0, m(c)) : E === \"alert\" ? alert(`Thread ${I.threadId}: ${I.text}`) : I.target === \"setimmediate\" ? c.postMessage(I) : E === \"callHandler\" ? u[I.handler](...I.args) : E && et(`worker sent an unknown command ${E}`);\n        }, c.onerror = I => {\n          throw et(`worker sent an error! ${I.filename}:${I.lineno}: ${I.message}`), I;\n        };\n        var g,\n          x = [];\n        for (g of []) u.hasOwnProperty(g) && x.push(g);\n        c.postMessage({\n          cmd: \"load\",\n          handlers: x,\n          wasmMemory: C,\n          wasmModule: Kr\n        });\n      });\n      function ua() {\n        var c = new Worker(new URL(import.meta.url), {\n          type: \"module\",\n          workerData: \"em-pthread\",\n          name: \"em-pthread\"\n        });\n        Ie.push(c);\n      }\n      var la,\n        Zr = c => {\n          for (; 0 < c.length;) c.shift()(u);\n        },\n        md = () => {\n          var c = er(),\n            m = r()[c + 52 >>> 2 >>> 0];\n          c = r()[c + 56 >>> 2 >>> 0], Xa(m, m - c), on(m);\n        },\n        Qr = [],\n        bd = (c, m) => {\n          vr = 0;\n          var g = Qr[c];\n          g || (c >= Qr.length && (Qr.length = c + 1), Qr[c] = g = la.get(c)), c = g(m), 0 < vr ? we = c : nn(c);\n        };\n      class gd {\n        constructor(m) {\n          this.Xa = m - 24;\n        }\n      }\n      function yd(c, m, g) {\n        var x = new gd(c >>>= 0);\n        throw m >>>= 0, g >>>= 0, r()[x.Xa + 16 >>> 2 >>> 0] = 0, r()[x.Xa + 4 >>> 2 >>> 0] = m, r()[x.Xa + 8 >>> 2 >>> 0] = g, c;\n      }\n      function fa(c, m, g, x) {\n        return d ? st(2, 1, c, m, g, x) : ca(c, m, g, x);\n      }\n      function ca(c, m, g, x) {\n        if (c >>>= 0, m >>>= 0, g >>>= 0, x >>>= 0, v === void 0) return et(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n        var I = [];\n        return d && I.length === 0 ? fa(c, m, g, x) : (c = {\n          cb: g,\n          Ra: c,\n          ab: x,\n          ib: I\n        }, d ? (c.Za = \"spawnThread\", postMessage(c, I), 0) : ra(c));\n      }\n      var pa = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf8\") : void 0,\n        da = (c, m, g) => {\n          var x = (m >>>= 0) + g;\n          for (g = m; c[g] && !(g >= x);) ++g;\n          if (16 < g - m && c.buffer && pa) return pa.decode(c.buffer instanceof v ? c.slice(m, g) : c.subarray(m, g));\n          for (x = \"\"; m < g;) {\n            var I = c[m++];\n            if (128 & I) {\n              var E = 63 & c[m++];\n              if ((224 & I) == 192) x += String.fromCharCode((31 & I) << 6 | E);else {\n                var R = 63 & c[m++];\n                65536 > (I = (240 & I) == 224 ? (15 & I) << 12 | E << 6 | R : (7 & I) << 18 | E << 12 | R << 6 | 63 & c[m++]) ? x += String.fromCharCode(I) : (I -= 65536, x += String.fromCharCode(55296 | I >> 10, 56320 | 1023 & I));\n              }\n            } else x += String.fromCharCode(I);\n          }\n          return x;\n        },\n        Ir = (c, m) => (c >>>= 0) ? da(o(), c, m) : \"\";\n      function ha(c, m, g) {\n        return d ? st(3, 1, c, m, g) : 0;\n      }\n      function ma(c, m) {\n        if (d) return st(4, 1, c, m);\n      }\n      var ba = c => {\n          for (var m = 0, g = 0; g < c.length; ++g) {\n            var x = c.charCodeAt(g);\n            127 >= x ? m++ : 2047 >= x ? m += 2 : 55296 <= x && 57343 >= x ? (m += 4, ++g) : m += 3;\n          }\n          return m;\n        },\n        ga = (c, m, g, x) => {\n          if (!(0 < x)) return 0;\n          var I = g >>>= 0;\n          x = g + x - 1;\n          for (var E = 0; E < c.length; ++E) {\n            var R = c.charCodeAt(E);\n            if (55296 <= R && 57343 >= R && (R = 65536 + ((1023 & R) << 10) | 1023 & c.charCodeAt(++E)), 127 >= R) {\n              if (g >= x) break;\n              m[g++ >>> 0] = R;\n            } else {\n              if (2047 >= R) {\n                if (g + 1 >= x) break;\n                m[g++ >>> 0] = 192 | R >> 6;\n              } else {\n                if (65535 >= R) {\n                  if (g + 2 >= x) break;\n                  m[g++ >>> 0] = 224 | R >> 12;\n                } else {\n                  if (g + 3 >= x) break;\n                  m[g++ >>> 0] = 240 | R >> 18, m[g++ >>> 0] = 128 | R >> 12 & 63;\n                }\n                m[g++ >>> 0] = 128 | R >> 6 & 63;\n              }\n              m[g++ >>> 0] = 128 | 63 & R;\n            }\n          }\n          return m[g >>> 0] = 0, g - I;\n        },\n        _r = (c, m, g) => ga(c, o(), m, g);\n      function ya(c, m) {\n        if (d) return st(5, 1, c, m);\n      }\n      function xa(c, m, g) {\n        if (d) return st(6, 1, c, m, g);\n      }\n      function Ta(c, m, g) {\n        return d ? st(7, 1, c, m, g) : 0;\n      }\n      function wa(c, m) {\n        if (d) return st(8, 1, c, m);\n      }\n      function va(c, m, g) {\n        if (d) return st(9, 1, c, m, g);\n      }\n      function Ia(c, m, g, x) {\n        if (d) return st(10, 1, c, m, g, x);\n      }\n      function _a(c, m, g, x) {\n        if (d) return st(11, 1, c, m, g, x);\n      }\n      function Oa(c, m, g, x) {\n        if (d) return st(12, 1, c, m, g, x);\n      }\n      function Sa(c) {\n        if (d) return st(13, 1, c);\n      }\n      function Aa(c, m) {\n        if (d) return st(14, 1, c, m);\n      }\n      function Pa(c, m, g) {\n        if (d) return st(15, 1, c, m, g);\n      }\n      var xd = () => {\n          Mt(\"\");\n        },\n        Td = () => 1;\n      function wd(c) {\n        $o(c >>> 0, !p, 1, !f, 131072, !1), aa();\n      }\n      function Ao(c) {\n        c >>>= 0, typeof Atomics.jb == \"function\" && (Atomics.jb(t(), c >>> 2, c).value.then(tn), c += 128, Atomics.store(t(), c >>> 2, 1));\n      }\n      var tn = () => {\n        var c = er();\n        if (c && (Ao(c), c = ja, !se)) try {\n          if (c(), !(0 < vr)) try {\n            d ? nn(we) : So(we);\n          } catch (m) {\n            m instanceof Io || m == \"unwind\" || P(1, m);\n          }\n        } catch (m) {\n          m instanceof Io || m == \"unwind\" || P(1, m);\n        }\n      };\n      function vd(c, m) {\n        (c >>>= 0) == m >>> 0 ? setTimeout(tn) : d ? postMessage({\n          targetThread: c,\n          cmd: \"checkMailbox\"\n        }) : (c = fe[c]) && c.postMessage({\n          cmd: \"checkMailbox\"\n        });\n      }\n      var Po = [];\n      function Id(c, m, g, x, I) {\n        for (m >>>= 0, x /= 2, Po.length = x, g = I >>> 0 >>> 3, I = 0; I < x; I++) Po[I] = ie[g + 2 * I] ? ie[g + 2 * I + 1] : n()[g + 2 * I + 1 >>> 0];\n        return (m ? ea[m] : Wd[c])(...Po);\n      }\n      function _d(c) {\n        c >>>= 0, d ? postMessage({\n          cmd: \"cleanupThread\",\n          thread: c\n        }) : ia(fe[c]);\n      }\n      function Od(c) {}\n      function Sd(c, m) {\n        c = -9007199254740992 > c || 9007199254740992 < c ? NaN : Number(c), m >>>= 0, c = new Date(1e3 * c), t()[m >>> 2 >>> 0] = c.getUTCSeconds(), t()[m + 4 >>> 2 >>> 0] = c.getUTCMinutes(), t()[m + 8 >>> 2 >>> 0] = c.getUTCHours(), t()[m + 12 >>> 2 >>> 0] = c.getUTCDate(), t()[m + 16 >>> 2 >>> 0] = c.getUTCMonth(), t()[m + 20 >>> 2 >>> 0] = c.getUTCFullYear() - 1900, t()[m + 24 >>> 2 >>> 0] = c.getUTCDay(), c = (c.getTime() - Date.UTC(c.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, t()[m + 28 >>> 2 >>> 0] = c;\n      }\n      var Qe = c => c % 4 == 0 && (c % 100 != 0 || c % 400 == 0),\n        Ea = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        Da = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n      function Ad(c, m) {\n        c = -9007199254740992 > c || 9007199254740992 < c ? NaN : Number(c), m >>>= 0, c = new Date(1e3 * c), t()[m >>> 2 >>> 0] = c.getSeconds(), t()[m + 4 >>> 2 >>> 0] = c.getMinutes(), t()[m + 8 >>> 2 >>> 0] = c.getHours(), t()[m + 12 >>> 2 >>> 0] = c.getDate(), t()[m + 16 >>> 2 >>> 0] = c.getMonth(), t()[m + 20 >>> 2 >>> 0] = c.getFullYear() - 1900, t()[m + 24 >>> 2 >>> 0] = c.getDay();\n        var g = (Qe(c.getFullYear()) ? Ea : Da)[c.getMonth()] + c.getDate() - 1 | 0;\n        t()[m + 28 >>> 2 >>> 0] = g, t()[m + 36 >>> 2 >>> 0] = -60 * c.getTimezoneOffset(), g = new Date(c.getFullYear(), 6, 1).getTimezoneOffset();\n        var x = new Date(c.getFullYear(), 0, 1).getTimezoneOffset();\n        c = 0 | (g != x && c.getTimezoneOffset() == Math.min(x, g)), t()[m + 32 >>> 2 >>> 0] = c;\n      }\n      function Pd(c) {\n        c >>>= 0;\n        var m = new Date(t()[c + 20 >>> 2 >>> 0] + 1900, t()[c + 16 >>> 2 >>> 0], t()[c + 12 >>> 2 >>> 0], t()[c + 8 >>> 2 >>> 0], t()[c + 4 >>> 2 >>> 0], t()[c >>> 2 >>> 0], 0),\n          g = t()[c + 32 >>> 2 >>> 0],\n          x = m.getTimezoneOffset(),\n          I = new Date(m.getFullYear(), 6, 1).getTimezoneOffset(),\n          E = new Date(m.getFullYear(), 0, 1).getTimezoneOffset(),\n          R = Math.min(E, I);\n        return 0 > g ? t()[c + 32 >>> 2 >>> 0] = +(I != E && R == x) : 0 < g != (R == x) && (I = Math.max(E, I), m.setTime(m.getTime() + 6e4 * ((0 < g ? R : I) - x))), t()[c + 24 >>> 2 >>> 0] = m.getDay(), g = (Qe(m.getFullYear()) ? Ea : Da)[m.getMonth()] + m.getDate() - 1 | 0, t()[c + 28 >>> 2 >>> 0] = g, t()[c >>> 2 >>> 0] = m.getSeconds(), t()[c + 4 >>> 2 >>> 0] = m.getMinutes(), t()[c + 8 >>> 2 >>> 0] = m.getHours(), t()[c + 12 >>> 2 >>> 0] = m.getDate(), t()[c + 16 >>> 2 >>> 0] = m.getMonth(), t()[c + 20 >>> 2 >>> 0] = m.getYear(), c = m.getTime(), BigInt(isNaN(c) ? -1 : c / 1e3);\n      }\n      function La(c, m, g, x, I, E, R) {\n        return d ? st(16, 1, c, m, g, x, I, E, R) : -52;\n      }\n      function $a(c, m, g, x, I, E) {\n        if (d) return st(17, 1, c, m, g, x, I, E);\n      }\n      function Ed(c, m, g, x) {\n        c >>>= 0, m >>>= 0, g >>>= 0, x >>>= 0;\n        var I = new Date().getFullYear(),\n          E = new Date(I, 0, 1),\n          R = new Date(I, 6, 1);\n        I = E.getTimezoneOffset();\n        var at = R.getTimezoneOffset(),\n          Pt = Math.max(I, at);\n        r()[c >>> 2 >>> 0] = 60 * Pt, t()[m >>> 2 >>> 0] = +(I != at), E = (c = $t => $t.toLocaleTimeString(void 0, {\n          hour12: !1,\n          timeZoneName: \"short\"\n        }).split(\" \")[1])(E), R = c(R), at < I ? (_r(E, g, 17), _r(R, x, 17)) : (_r(E, x, 17), _r(R, g, 17));\n      }\n      var Eo = [];\n      function Dd(c, m, g) {\n        c >>>= 0, m >>>= 0, g >>>= 0, Eo.length = 0;\n        for (var x; x = o()[m++ >>> 0];) {\n          var I = x != 105;\n          g += (I &= x != 112) && g % 8 ? 4 : 0, Eo.push(x == 112 ? r()[g >>> 2 >>> 0] : x == 106 ? ie[g >>> 3] : x == 105 ? t()[g >>> 2 >>> 0] : n()[g >>> 3 >>> 0]), g += I ? 8 : 4;\n        }\n        return ea[c](...Eo);\n      }\n      var Ld = () => {},\n        $d = () => Date.now();\n      function kd(c, m) {\n        return et(Ir(c >>> 0, m >>> 0));\n      }\n      var ka,\n        Bd = () => {\n          throw vr += 1, \"unwind\";\n        };\n      function Fd() {\n        return 4294901760;\n      }\n      ka = () => performance.timeOrigin + performance.now();\n      var Cd = () => navigator.hardwareConcurrency;\n      function Nd() {\n        return Mt(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"), 0;\n      }\n      function Rd(c) {\n        c >>>= 0;\n        var m = o().length;\n        if (c <= m || 4294901760 < c) return !1;\n        for (var g = 1; 4 >= g; g *= 2) {\n          var x = m * (1 + .2 / g);\n          x = Math.min(x, c + 100663296);\n          var I = Math;\n          x = Math.max(c, x);\n          t: {\n            I = (I.min.call(I, 4294901760, x + (65536 - x % 65536) % 65536) - C.buffer.byteLength + 65535) / 65536;\n            try {\n              C.grow(I), it();\n              var E = 1;\n              break t;\n            } catch {}\n            E = void 0;\n          }\n          if (E) return !0;\n        }\n        return !1;\n      }\n      var en = () => (Mt(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"), 0),\n        tr = {},\n        Ba = c => {\n          c.forEach(m => {\n            var g = en();\n            g && (tr[g] = m);\n          });\n        };\n      function Gd() {\n        var c = Error().stack.toString().split(`\n`);\n        return c[0] == \"Error\" && c.shift(), Ba(c), tr.$a = en(), tr.bb = c, tr.$a;\n      }\n      function Md(c, m, g) {\n        if (c >>>= 0, m >>>= 0, tr.$a == c) var x = tr.bb;else (x = Error().stack.toString().split(`\n`))[0] == \"Error\" && x.shift(), Ba(x);\n        for (var I = 3; x[I] && en() != c;) ++I;\n        for (c = 0; c < g && x[c + I]; ++c) t()[m + 4 * c >>> 2 >>> 0] = en();\n        return c;\n      }\n      var Do,\n        Lo = {},\n        Fa = () => {\n          if (!Do) {\n            var c,\n              m = {\n                USER: \"web_user\",\n                LOGNAME: \"web_user\",\n                PATH: \"/\",\n                PWD: \"/\",\n                HOME: \"/home/web_user\",\n                LANG: (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                _: L || \"./this.program\"\n              };\n            for (c in Lo) Lo[c] === void 0 ? delete m[c] : m[c] = Lo[c];\n            var g = [];\n            for (c in m) g.push(`${c}=${m[c]}`);\n            Do = g;\n          }\n          return Do;\n        };\n      function Ca(c, m) {\n        if (d) return st(18, 1, c, m);\n        c >>>= 0, m >>>= 0;\n        var g = 0;\n        return Fa().forEach((x, I) => {\n          var E = m + g;\n          for (I = r()[c + 4 * I >>> 2 >>> 0] = E, E = 0; E < x.length; ++E) e()[I++ >>> 0] = x.charCodeAt(E);\n          e()[I >>> 0] = 0, g += x.length + 1;\n        }), 0;\n      }\n      function Na(c, m) {\n        if (d) return st(19, 1, c, m);\n        c >>>= 0, m >>>= 0;\n        var g = Fa();\n        r()[c >>> 2 >>> 0] = g.length;\n        var x = 0;\n        return g.forEach(I => x += I.length + 1), r()[m >>> 2 >>> 0] = x, 0;\n      }\n      function Ra(c) {\n        return d ? st(20, 1, c) : 52;\n      }\n      function Ga(c, m, g, x) {\n        return d ? st(21, 1, c, m, g, x) : 52;\n      }\n      function Ma(c, m, g, x) {\n        return d ? st(22, 1, c, m, g, x) : 70;\n      }\n      var Ud = [null, [], []];\n      function Ua(c, m, g, x) {\n        if (d) return st(23, 1, c, m, g, x);\n        m >>>= 0, g >>>= 0, x >>>= 0;\n        for (var I = 0, E = 0; E < g; E++) {\n          var R = r()[m >>> 2 >>> 0],\n            at = r()[m + 4 >>> 2 >>> 0];\n          m += 8;\n          for (var Pt = 0; Pt < at; Pt++) {\n            var $t = o()[R + Pt >>> 0],\n              Ft = Ud[c];\n            $t === 0 || $t === 10 ? ((c === 1 ? wt : et)(da(Ft, 0)), Ft.length = 0) : Ft.push($t);\n          }\n          I += at;\n        }\n        return r()[x >>> 2 >>> 0] = I, 0;\n      }\n      var Va = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        za = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        Vd = (c, m) => {\n          e().set(c, m >>> 0);\n        };\n      function Wa(c, m, g, x) {\n        function I(_, Q, ft) {\n          for (_ = typeof _ == \"number\" ? _.toString() : _ || \"\"; _.length < Q;) _ = ft[0] + _;\n          return _;\n        }\n        function E(_, Q) {\n          return I(_, Q, \"0\");\n        }\n        function R(_, Q) {\n          function ft(Za) {\n            return 0 > Za ? -1 : 0 < Za ? 1 : 0;\n          }\n          var $e;\n          return ($e = ft(_.getFullYear() - Q.getFullYear())) === 0 && ($e = ft(_.getMonth() - Q.getMonth())) === 0 && ($e = ft(_.getDate() - Q.getDate())), $e;\n        }\n        function at(_) {\n          switch (_.getDay()) {\n            case 0:\n              return new Date(_.getFullYear() - 1, 11, 29);\n            case 1:\n              return _;\n            case 2:\n              return new Date(_.getFullYear(), 0, 3);\n            case 3:\n              return new Date(_.getFullYear(), 0, 2);\n            case 4:\n              return new Date(_.getFullYear(), 0, 1);\n            case 5:\n              return new Date(_.getFullYear() - 1, 11, 31);\n            case 6:\n              return new Date(_.getFullYear() - 1, 11, 30);\n          }\n        }\n        function Pt(_) {\n          var Q = _.Sa;\n          for (_ = new Date(new Date(_.Ta + 1900, 0, 1).getTime()); 0 < Q;) {\n            var ft = _.getMonth(),\n              $e = (Qe(_.getFullYear()) ? Va : za)[ft];\n            if (!(Q > $e - _.getDate())) {\n              _.setDate(_.getDate() + Q);\n              break;\n            }\n            Q -= $e - _.getDate() + 1, _.setDate(1), 11 > ft ? _.setMonth(ft + 1) : (_.setMonth(0), _.setFullYear(_.getFullYear() + 1));\n          }\n          return ft = new Date(_.getFullYear() + 1, 0, 4), Q = at(new Date(_.getFullYear(), 0, 4)), ft = at(ft), 0 >= R(Q, _) ? 0 >= R(ft, _) ? _.getFullYear() + 1 : _.getFullYear() : _.getFullYear() - 1;\n        }\n        c >>>= 0, m >>>= 0, g >>>= 0, x >>>= 0;\n        var $t = r()[x + 40 >>> 2 >>> 0];\n        for (var Ft in x = {\n          gb: t()[x >>> 2 >>> 0],\n          fb: t()[x + 4 >>> 2 >>> 0],\n          Va: t()[x + 8 >>> 2 >>> 0],\n          Ya: t()[x + 12 >>> 2 >>> 0],\n          Wa: t()[x + 16 >>> 2 >>> 0],\n          Ta: t()[x + 20 >>> 2 >>> 0],\n          Qa: t()[x + 24 >>> 2 >>> 0],\n          Sa: t()[x + 28 >>> 2 >>> 0],\n          ob: t()[x + 32 >>> 2 >>> 0],\n          eb: t()[x + 36 >>> 2 >>> 0],\n          hb: $t ? Ir($t) : \"\"\n        }, g = Ir(g), $t = {\n          \"%c\": \"%a %b %d %H:%M:%S %Y\",\n          \"%D\": \"%m/%d/%y\",\n          \"%F\": \"%Y-%m-%d\",\n          \"%h\": \"%b\",\n          \"%r\": \"%I:%M:%S %p\",\n          \"%R\": \"%H:%M\",\n          \"%T\": \"%H:%M:%S\",\n          \"%x\": \"%m/%d/%y\",\n          \"%X\": \"%H:%M:%S\",\n          \"%Ec\": \"%c\",\n          \"%EC\": \"%C\",\n          \"%Ex\": \"%m/%d/%y\",\n          \"%EX\": \"%H:%M:%S\",\n          \"%Ey\": \"%y\",\n          \"%EY\": \"%Y\",\n          \"%Od\": \"%d\",\n          \"%Oe\": \"%e\",\n          \"%OH\": \"%H\",\n          \"%OI\": \"%I\",\n          \"%Om\": \"%m\",\n          \"%OM\": \"%M\",\n          \"%OS\": \"%S\",\n          \"%Ou\": \"%u\",\n          \"%OU\": \"%U\",\n          \"%OV\": \"%V\",\n          \"%Ow\": \"%w\",\n          \"%OW\": \"%W\",\n          \"%Oy\": \"%y\"\n        }) g = g.replace(new RegExp(Ft, \"g\"), $t[Ft]);\n        var Ja = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          Ya = \"January February March April May June July August September October November December\".split(\" \");\n        for (Ft in $t = {\n          \"%a\": _ => Ja[_.Qa].substring(0, 3),\n          \"%A\": _ => Ja[_.Qa],\n          \"%b\": _ => Ya[_.Wa].substring(0, 3),\n          \"%B\": _ => Ya[_.Wa],\n          \"%C\": _ => E((_.Ta + 1900) / 100 | 0, 2),\n          \"%d\": _ => E(_.Ya, 2),\n          \"%e\": _ => I(_.Ya, 2, \" \"),\n          \"%g\": _ => Pt(_).toString().substring(2),\n          \"%G\": Pt,\n          \"%H\": _ => E(_.Va, 2),\n          \"%I\": _ => ((_ = _.Va) == 0 ? _ = 12 : 12 < _ && (_ -= 12), E(_, 2)),\n          \"%j\": _ => {\n            for (var Q = 0, ft = 0; ft <= _.Wa - 1; Q += (Qe(_.Ta + 1900) ? Va : za)[ft++]);\n            return E(_.Ya + Q, 3);\n          },\n          \"%m\": _ => E(_.Wa + 1, 2),\n          \"%M\": _ => E(_.fb, 2),\n          \"%n\": () => `\n`,\n          \"%p\": _ => 0 <= _.Va && 12 > _.Va ? \"AM\" : \"PM\",\n          \"%S\": _ => E(_.gb, 2),\n          \"%t\": () => \"\t\",\n          \"%u\": _ => _.Qa || 7,\n          \"%U\": _ => E(Math.floor((_.Sa + 7 - _.Qa) / 7), 2),\n          \"%V\": _ => {\n            var Q = Math.floor((_.Sa + 7 - (_.Qa + 6) % 7) / 7);\n            if (2 >= (_.Qa + 371 - _.Sa - 2) % 7 && Q++, Q) Q == 53 && ((ft = (_.Qa + 371 - _.Sa) % 7) == 4 || ft == 3 && Qe(_.Ta) || (Q = 1));else {\n              Q = 52;\n              var ft = (_.Qa + 7 - _.Sa - 1) % 7;\n              (ft == 4 || ft == 5 && Qe(_.Ta % 400 - 1)) && Q++;\n            }\n            return E(Q, 2);\n          },\n          \"%w\": _ => _.Qa,\n          \"%W\": _ => E(Math.floor((_.Sa + 7 - (_.Qa + 6) % 7) / 7), 2),\n          \"%y\": _ => (_.Ta + 1900).toString().substring(2),\n          \"%Y\": _ => _.Ta + 1900,\n          \"%z\": _ => {\n            var Q = 0 <= (_ = _.eb);\n            return _ = Math.abs(_) / 60, (Q ? \"+\" : \"-\") + (\"0000\" + (_ / 60 * 100 + _ % 60)).slice(-4);\n          },\n          \"%Z\": _ => _.hb,\n          \"%%\": () => \"%\"\n        }, g = g.replace(/%%/g, \"\\0\\0\"), $t) g.includes(Ft) && (g = g.replace(new RegExp(Ft, \"g\"), $t[Ft](x)));\n        return Ft = function (_) {\n          var Q = Array(ba(_) + 1);\n          return ga(_, Q, 0, Q.length), Q;\n        }(g = g.replace(/\\0\\0/g, \"%\")), Ft.length > m ? 0 : (Vd(Ft, c), Ft.length - 1);\n      }\n      function zd(c, m, g, x) {\n        return Wa(c >>> 0, m >>> 0, g >>> 0, x >>> 0);\n      }\n      d || function () {\n        for (var c = u.numThreads - 1; c--;) ua();\n        Lt.unshift(() => {\n          ue++, function (m) {\n            d ? m() : Promise.all(Ie.map(sa)).then(m);\n          }(() => le());\n        });\n      }();\n      var Wd = [Oo, na, fa, ha, ma, ya, xa, Ta, wa, va, Ia, _a, Oa, Sa, Aa, Pa, La, $a, Ca, Na, Ra, Ga, Ma, Ua],\n        U = function () {\n          function c(g, x) {\n            return U = g.exports, U = function () {\n              var I = U,\n                E = at => () => at() >>> 0,\n                R = at => Pt => at(Pt) >>> 0;\n              return (I = Object.assign({}, I)).Ba = E(I.Ba), I.Ca = R(I.Ca), I.emscripten_main_runtime_thread_id = E(I.emscripten_main_runtime_thread_id), I.Oa = R(I.Oa), I.Pa = E(I.Pa), I;\n            }(), oa.push(U.Ea), la = U.Fa, Jr.unshift(U.$), Kr = x, le(), U;\n          }\n          var m = Yr();\n          if (ue++, u.instantiateWasm) try {\n            return u.instantiateWasm(m, c);\n          } catch (g) {\n            et(`Module.instantiateWasm callback failed with error: ${g}`), a(g);\n          }\n          return ve ||= u.locateFile ? gt(\"ort-wasm-simd-threaded.wasm\") ? \"ort-wasm-simd-threaded.wasm\" : u.locateFile ? u.locateFile(\"ort-wasm-simd-threaded.wasm\", A) : A + \"ort-wasm-simd-threaded.wasm\" : new URL(\"ort-wasm-simd-threaded.wasm\", import.meta.url).href, function (g, x) {\n            var I = ve;\n            return M || typeof WebAssembly.instantiateStreaming != \"function\" || gt(I) || Ot(I) || typeof fetch != \"function\" ? wr(I, g, x) : fetch(I, {\n              credentials: \"same-origin\"\n            }).then(E => WebAssembly.instantiateStreaming(E, g).then(x, function (R) {\n              return et(`wasm streaming compile failed: ${R}`), et(\"falling back to ArrayBuffer instantiation\"), wr(I, g, x);\n            }));\n          }(m, function (g) {\n            c(g.instance, g.module);\n          }).catch(a), {};\n        }();\n      u._OrtInit = (c, m) => (u._OrtInit = U.aa)(c, m), u._OrtGetLastError = (c, m) => (u._OrtGetLastError = U.ba)(c, m), u._OrtCreateSessionOptions = (c, m, g, x, I, E, R, at, Pt, $t) => (u._OrtCreateSessionOptions = U.ca)(c, m, g, x, I, E, R, at, Pt, $t), u._OrtAppendExecutionProvider = (c, m) => (u._OrtAppendExecutionProvider = U.da)(c, m), u._OrtAddFreeDimensionOverride = (c, m, g) => (u._OrtAddFreeDimensionOverride = U.ea)(c, m, g), u._OrtAddSessionConfigEntry = (c, m, g) => (u._OrtAddSessionConfigEntry = U.fa)(c, m, g), u._OrtReleaseSessionOptions = c => (u._OrtReleaseSessionOptions = U.ga)(c), u._OrtCreateSession = (c, m, g) => (u._OrtCreateSession = U.ha)(c, m, g), u._OrtReleaseSession = c => (u._OrtReleaseSession = U.ia)(c), u._OrtGetInputOutputCount = (c, m, g) => (u._OrtGetInputOutputCount = U.ja)(c, m, g), u._OrtGetInputName = (c, m) => (u._OrtGetInputName = U.ka)(c, m), u._OrtGetOutputName = (c, m) => (u._OrtGetOutputName = U.la)(c, m), u._OrtFree = c => (u._OrtFree = U.ma)(c), u._OrtCreateTensor = (c, m, g, x, I, E) => (u._OrtCreateTensor = U.na)(c, m, g, x, I, E), u._OrtGetTensorData = (c, m, g, x, I) => (u._OrtGetTensorData = U.oa)(c, m, g, x, I), u._OrtReleaseTensor = c => (u._OrtReleaseTensor = U.pa)(c), u._OrtCreateRunOptions = (c, m, g, x) => (u._OrtCreateRunOptions = U.qa)(c, m, g, x), u._OrtAddRunConfigEntry = (c, m, g) => (u._OrtAddRunConfigEntry = U.ra)(c, m, g), u._OrtReleaseRunOptions = c => (u._OrtReleaseRunOptions = U.sa)(c), u._OrtCreateBinding = c => (u._OrtCreateBinding = U.ta)(c), u._OrtBindInput = (c, m, g) => (u._OrtBindInput = U.ua)(c, m, g), u._OrtBindOutput = (c, m, g, x) => (u._OrtBindOutput = U.va)(c, m, g, x), u._OrtClearBoundOutputs = c => (u._OrtClearBoundOutputs = U.wa)(c), u._OrtReleaseBinding = c => (u._OrtReleaseBinding = U.xa)(c), u._OrtRunWithBinding = (c, m, g, x, I) => (u._OrtRunWithBinding = U.ya)(c, m, g, x, I), u._OrtRun = (c, m, g, x, I, E, R, at) => (u._OrtRun = U.za)(c, m, g, x, I, E, R, at), u._OrtEndProfiling = c => (u._OrtEndProfiling = U.Aa)(c);\n      var er = () => (er = U.Ba)();\n      u._malloc = c => (u._malloc = U.Ca)(c), u._free = c => (u._free = U.Da)(c);\n      var rn,\n        $o = (c, m, g, x, I, E) => ($o = U.Ga)(c, m, g, x, I, E),\n        Ha = () => (Ha = U.Ha)(),\n        qa = (c, m, g, x, I) => (qa = U.Ia)(c, m, g, x, I),\n        ko = c => (ko = U.Ja)(c),\n        nn = c => (nn = U.Ka)(c),\n        ja = () => (ja = U.La)(),\n        Xa = (c, m) => (Xa = U.Ma)(c, m),\n        on = c => (on = U.Na)(c),\n        Bo = c => (Bo = U.Oa)(c),\n        Fo = () => (Fo = U.Pa)();\n      function Ka() {\n        0 < ue || (d ? (s(u), d || Zr(Jr), startWorker(u)) : (Zr(Lt), 0 < ue || rn || (rn = !0, u.calledRun = !0, se || (d || Zr(Jr), s(u), d || Zr(Ye)))));\n      }\n      return u.___start_em_js = 837640, u.___stop_em_js = 837701, u.stackSave = () => Fo(), u.stackRestore = c => on(c), u.stackAlloc = c => Bo(c), u.UTF8ToString = Ir, u.stringToUTF8 = _r, u.lengthBytesUTF8 = ba, De = function c() {\n        rn || Ka(), rn || (De = c);\n      }, Ka(), l;\n    })), Og = Mp;\n    globalThis.self?.name === \"em-pthread\" && Mp();\n  });\nvar br,\n  Sg,\n  Ag,\n  Pg,\n  zp,\n  Wp,\n  Eg,\n  Hp,\n  Vr = O(() => {\n    \"use strict\";\n\n    oo();\n    br = !1 ? void 0 : import.meta.url ?? (typeof document < \"u\" ? document.currentScript?.src : typeof self < \"u\" ? self.location?.href : void 0), Sg = !1 || typeof location > \"u\" ? void 0 : location.origin, Ag = (i, e) => {\n      try {\n        let o = e ?? br;\n        return (o ? new URL(i, o) : new URL(i)).origin === Sg;\n      } catch {\n        return !1;\n      }\n    }, Pg = /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator(function* (i) {\n        let o = yield (yield fetch(i, {\n          credentials: \"same-origin\"\n        })).blob();\n        return URL.createObjectURL(o);\n      });\n      return function Pg(_x11) {\n        return _ref12.apply(this, arguments);\n      };\n    }(), zp = (Gp(), sn(Rp)).default, Wp = /*#__PURE__*/function () {\n      var _ref13 = _asyncToGenerator(function* () {\n        if (!br) throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");\n        if (Ag(br)) return [void 0, zp()];\n        let i = yield Pg(br);\n        return [i, zp(i)];\n      });\n      return function Wp() {\n        return _ref13.apply(this, arguments);\n      };\n    }(), Eg = (Vp(), sn(Up)).default, Hp = /*#__PURE__*/function () {\n      var _ref14 = _asyncToGenerator(function* (i, e, o) {\n        return [void 0, Eg];\n      });\n      return function Hp(_x12, _x13, _x14) {\n        return _ref14.apply(this, arguments);\n      };\n    }();\n  });\nvar Xi,\n  Ki,\n  ho,\n  qp,\n  Dg,\n  Lg,\n  io,\n  xt,\n  Ke = O(() => {\n    \"use strict\";\n\n    Vr();\n    Ki = !1, ho = !1, qp = !1, Dg = () => {\n      if (typeof SharedArrayBuffer > \"u\") return !1;\n      try {\n        return typeof MessageChannel < \"u\" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));\n      } catch {\n        return !1;\n      }\n    }, Lg = () => {\n      try {\n        return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));\n      } catch {\n        return !1;\n      }\n    }, io = /*#__PURE__*/function () {\n      var _ref15 = _asyncToGenerator(function* (i) {\n        if (Ki) return Promise.resolve();\n        if (ho) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n        if (qp) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n        ho = !0;\n        let e = i.initTimeout,\n          o = i.numThreads;\n        if (!Lg()) throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");\n        let t = Dg();\n        o > 1 && !t && (typeof self < \"u\" && !self.crossOriginIsolated && console.warn(\"env.wasm.numThreads is set to \" + o + \", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"), console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"), i.numThreads = o = 1);\n        let r = i.wasmPaths,\n          n = typeof r == \"string\" ? r : void 0,\n          s = r?.mjs,\n          a = s?.href ?? s,\n          u = r?.wasm,\n          l = u?.href ?? u,\n          f = i.wasmBinary,\n          [p, d] = yield Hp(a, n, o > 1),\n          y = !1,\n          T = [];\n        if (e > 0 && T.push(new Promise(v => {\n          setTimeout(() => {\n            y = !0, v();\n          }, e);\n        })), T.push(new Promise((v, S) => {\n          let L = {\n            numThreads: o\n          };\n          f ? L.wasmBinary = f : (l || n) && (L.locateFile = (P, A) => l ?? (n ?? A) + P), d(L).then(P => {\n            ho = !1, Ki = !0, Xi = P, v(), p && URL.revokeObjectURL(p);\n          }, P => {\n            ho = !1, qp = !0, S(P);\n          });\n        })), yield Promise.race(T), y) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`);\n      });\n      return function io(_x15) {\n        return _ref15.apply(this, arguments);\n      };\n    }(), xt = () => {\n      if (Ki && Xi) return Xi;\n      throw new Error(\"WebAssembly is not initialized yet.\");\n    };\n  });\nvar Tt,\n  Wr,\n  ht,\n  mo = O(() => {\n    \"use strict\";\n\n    Ke();\n    Tt = (i, e) => {\n      let o = xt(),\n        t = o.lengthBytesUTF8(i) + 1,\n        r = o._malloc(t);\n      return o.stringToUTF8(i, r, t), e.push(r), r;\n    }, Wr = (i, e, o, t) => {\n      if (typeof i == \"object\" && i !== null) {\n        if (o.has(i)) throw new Error(\"Circular reference in options\");\n        o.add(i);\n      }\n      Object.entries(i).forEach(([r, n]) => {\n        let s = e ? e + r : r;\n        if (typeof n == \"object\") Wr(n, s + \".\", o, t);else if (typeof n == \"string\" || typeof n == \"number\") t(s, n.toString());else if (typeof n == \"boolean\") t(s, n ? \"1\" : \"0\");else throw new Error(`Can't handle extra config type: ${typeof n}`);\n      });\n    }, ht = i => {\n      let e = xt(),\n        o = e.stackSave();\n      try {\n        let t = e.stackAlloc(8);\n        e._OrtGetLastError(t, t + 4);\n        let r = e.HEAP32[t / 4],\n          n = e.HEAPU32[t / 4 + 1],\n          s = n ? e.UTF8ToString(n) : \"\";\n        throw new Error(`${i} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`);\n      } finally {\n        e.stackRestore(o);\n      }\n    };\n  });\nvar jp,\n  Xp = O(() => {\n    \"use strict\";\n\n    Ke();\n    mo();\n    jp = i => {\n      let e = xt(),\n        o = 0,\n        t = [],\n        r = i || {};\n      try {\n        if (i?.logSeverityLevel === void 0) r.logSeverityLevel = 2;else if (typeof i.logSeverityLevel != \"number\" || !Number.isInteger(i.logSeverityLevel) || i.logSeverityLevel < 0 || i.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${i.logSeverityLevel}`);\n        if (i?.logVerbosityLevel === void 0) r.logVerbosityLevel = 0;else if (typeof i.logVerbosityLevel != \"number\" || !Number.isInteger(i.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${i.logVerbosityLevel}`);\n        i?.terminate === void 0 && (r.terminate = !1);\n        let n = 0;\n        return i?.tag !== void 0 && (n = Tt(i.tag, t)), o = e._OrtCreateRunOptions(r.logSeverityLevel, r.logVerbosityLevel, !!r.terminate, n), o === 0 && ht(\"Can't create run options.\"), i?.extra !== void 0 && Wr(i.extra, \"\", new WeakSet(), (s, a) => {\n          let u = Tt(s, t),\n            l = Tt(a, t);\n          e._OrtAddRunConfigEntry(o, u, l) !== 0 && ht(`Can't set a run config entry: ${s} - ${a}.`);\n        }), [o, t];\n      } catch (n) {\n        throw o !== 0 && e._OrtReleaseRunOptions(o), t.forEach(s => e._free(s)), n;\n      }\n    };\n  });\nvar $g,\n  kg,\n  Bg,\n  Fg,\n  Kp,\n  Jp = O(() => {\n    \"use strict\";\n\n    Ke();\n    mo();\n    $g = i => {\n      switch (i) {\n        case \"disabled\":\n          return 0;\n        case \"basic\":\n          return 1;\n        case \"extended\":\n          return 2;\n        case \"all\":\n          return 99;\n        default:\n          throw new Error(`unsupported graph optimization level: ${i}`);\n      }\n    }, kg = i => {\n      switch (i) {\n        case \"sequential\":\n          return 0;\n        case \"parallel\":\n          return 1;\n        default:\n          throw new Error(`unsupported execution mode: ${i}`);\n      }\n    }, Bg = i => {\n      i.extra || (i.extra = {}), i.extra.session || (i.extra.session = {});\n      let e = i.extra.session;\n      e.use_ort_model_bytes_directly || (e.use_ort_model_bytes_directly = \"1\"), i.executionProviders && i.executionProviders.some(o => (typeof o == \"string\" ? o : o.name) === \"webgpu\") && (i.enableMemPattern = !1);\n    }, Fg = (i, e, o) => {\n      for (let t of e) {\n        let r = typeof t == \"string\" ? t : t.name;\n        switch (r) {\n          case \"webnn\":\n            if (r = \"WEBNN\", typeof t != \"string\") {\n              let a = t?.deviceType;\n              if (a) {\n                let u = Tt(\"deviceType\", o),\n                  l = Tt(a, o);\n                xt()._OrtAddSessionConfigEntry(i, u, l) !== 0 && ht(`Can't set a session config entry: 'deviceType' - ${a}.`);\n              }\n            }\n            break;\n          case \"webgpu\":\n            if (r = \"JS\", typeof t != \"string\") {\n              let s = t;\n              if (s?.preferredLayout) {\n                if (s.preferredLayout !== \"NCHW\" && s.preferredLayout !== \"NHWC\") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);\n                let a = Tt(\"preferredLayout\", o),\n                  u = Tt(s.preferredLayout, o);\n                xt()._OrtAddSessionConfigEntry(i, a, u) !== 0 && ht(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`);\n              }\n            }\n            break;\n          case \"wasm\":\n          case \"cpu\":\n            continue;\n          default:\n            throw new Error(`not supported execution provider: ${r}`);\n        }\n        let n = Tt(r, o);\n        xt()._OrtAppendExecutionProvider(i, n) !== 0 && ht(`Can't append execution provider: ${r}.`);\n      }\n    }, Kp = i => {\n      let e = xt(),\n        o = 0,\n        t = [],\n        r = i || {};\n      Bg(r);\n      try {\n        let n = $g(r.graphOptimizationLevel ?? \"all\"),\n          s = kg(r.executionMode ?? \"sequential\"),\n          a = typeof r.logId == \"string\" ? Tt(r.logId, t) : 0,\n          u = r.logSeverityLevel ?? 2;\n        if (!Number.isInteger(u) || u < 0 || u > 4) throw new Error(`log serverity level is not valid: ${u}`);\n        let l = r.logVerbosityLevel ?? 0;\n        if (!Number.isInteger(l) || l < 0 || l > 4) throw new Error(`log verbosity level is not valid: ${l}`);\n        let f = typeof r.optimizedModelFilePath == \"string\" ? Tt(r.optimizedModelFilePath, t) : 0;\n        if (o = e._OrtCreateSessionOptions(n, !!r.enableCpuMemArena, !!r.enableMemPattern, s, !!r.enableProfiling, 0, a, u, l, f), o === 0 && ht(\"Can't create session options.\"), r.executionProviders && Fg(o, r.executionProviders, t), r.enableGraphCapture !== void 0) {\n          if (typeof r.enableGraphCapture != \"boolean\") throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);\n          let p = Tt(\"enableGraphCapture\", t),\n            d = Tt(r.enableGraphCapture.toString(), t);\n          e._OrtAddSessionConfigEntry(o, p, d) !== 0 && ht(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`);\n        }\n        if (r.freeDimensionOverrides) for (let [p, d] of Object.entries(r.freeDimensionOverrides)) {\n          if (typeof p != \"string\") throw new Error(`free dimension override name must be a string: ${p}`);\n          if (typeof d != \"number\" || !Number.isInteger(d) || d < 0) throw new Error(`free dimension override value must be a non-negative integer: ${d}`);\n          let y = Tt(p, t);\n          e._OrtAddFreeDimensionOverride(o, y, d) !== 0 && ht(`Can't set a free dimension override: ${p} - ${d}.`);\n        }\n        return r.extra !== void 0 && Wr(r.extra, \"\", new WeakSet(), (p, d) => {\n          let y = Tt(p, t),\n            T = Tt(d, t);\n          e._OrtAddSessionConfigEntry(o, y, T) !== 0 && ht(`Can't set a session config entry: ${p} - ${d}.`);\n        }), [o, t];\n      } catch (n) {\n        throw o !== 0 && e._OrtReleaseSessionOptions(o), t.forEach(s => e._free(s)), n;\n      }\n    };\n  });\nvar Hr,\n  Yp,\n  qr,\n  Zp,\n  Qp,\n  bo,\n  go,\n  td,\n  Ji = O(() => {\n    \"use strict\";\n\n    Hr = i => {\n      switch (i) {\n        case \"int8\":\n          return 3;\n        case \"uint8\":\n          return 2;\n        case \"bool\":\n          return 9;\n        case \"int16\":\n          return 5;\n        case \"uint16\":\n          return 4;\n        case \"int32\":\n          return 6;\n        case \"uint32\":\n          return 12;\n        case \"float16\":\n          return 10;\n        case \"float32\":\n          return 1;\n        case \"float64\":\n          return 11;\n        case \"string\":\n          return 8;\n        case \"int64\":\n          return 7;\n        case \"uint64\":\n          return 13;\n        case \"int4\":\n          return 22;\n        case \"uint4\":\n          return 21;\n        default:\n          throw new Error(`unsupported data type: ${i}`);\n      }\n    }, Yp = i => {\n      switch (i) {\n        case 3:\n          return \"int8\";\n        case 2:\n          return \"uint8\";\n        case 9:\n          return \"bool\";\n        case 5:\n          return \"int16\";\n        case 4:\n          return \"uint16\";\n        case 6:\n          return \"int32\";\n        case 12:\n          return \"uint32\";\n        case 10:\n          return \"float16\";\n        case 1:\n          return \"float32\";\n        case 11:\n          return \"float64\";\n        case 8:\n          return \"string\";\n        case 7:\n          return \"int64\";\n        case 13:\n          return \"uint64\";\n        case 22:\n          return \"int4\";\n        case 21:\n          return \"uint4\";\n        default:\n          throw new Error(`unsupported data type: ${i}`);\n      }\n    }, qr = (i, e) => {\n      let o = [-1, 4, 1, 1, 2, 2, 4, 8, -1, 1, 2, 8, 4, 8, -1, -1, -1, -1, -1, -1, -1, .5, .5][i],\n        t = typeof e == \"number\" ? e : e.reduce((r, n) => r * n, 1);\n      return o > 0 ? Math.ceil(t * o) : void 0;\n    }, Zp = i => {\n      switch (i) {\n        case \"float16\":\n          return typeof Float16Array < \"u\" && Float16Array.from ? Float16Array : Uint16Array;\n        case \"float32\":\n          return Float32Array;\n        case \"uint8\":\n          return Uint8Array;\n        case \"int8\":\n          return Int8Array;\n        case \"uint16\":\n          return Uint16Array;\n        case \"int16\":\n          return Int16Array;\n        case \"int32\":\n          return Int32Array;\n        case \"bool\":\n          return Uint8Array;\n        case \"float64\":\n          return Float64Array;\n        case \"uint32\":\n          return Uint32Array;\n        case \"int64\":\n          return BigInt64Array;\n        case \"uint64\":\n          return BigUint64Array;\n        default:\n          throw new Error(`unsupported type: ${i}`);\n      }\n    }, Qp = i => {\n      switch (i) {\n        case \"verbose\":\n          return 0;\n        case \"info\":\n          return 1;\n        case \"warning\":\n          return 2;\n        case \"error\":\n          return 3;\n        case \"fatal\":\n          return 4;\n        default:\n          throw new Error(`unsupported logging level: ${i}`);\n      }\n    }, bo = i => i === \"float32\" || i === \"float16\" || i === \"int32\" || i === \"int64\" || i === \"uint32\" || i === \"uint8\" || i === \"bool\" || i === \"uint4\" || i === \"int4\", go = i => i === \"float32\" || i === \"float16\" || i === \"int32\" || i === \"int64\" || i === \"uint32\" || i === \"uint64\" || i === \"int8\" || i === \"uint8\" || i === \"bool\", td = i => {\n      switch (i) {\n        case \"none\":\n          return 0;\n        case \"cpu\":\n          return 1;\n        case \"cpu-pinned\":\n          return 2;\n        case \"texture\":\n          return 3;\n        case \"gpu-buffer\":\n          return 4;\n        case \"ml-tensor\":\n          return 5;\n        default:\n          throw new Error(`unsupported data location: ${i}`);\n      }\n    };\n  });\nvar jr,\n  Yi = O(() => {\n    \"use strict\";\n\n    oo();\n    jr = /*#__PURE__*/function () {\n      var _ref16 = _asyncToGenerator(function* (i) {\n        if (typeof i == \"string\") {\n          if (!1) try {\n            let {\n              readFile: e\n            } = Co(\"node:fs/promises\");\n            return new Uint8Array(yield e(i));\n          } catch (e) {\n            if (e.code === \"ERR_FS_FILE_TOO_LARGE\") {\n              let {\n                  createReadStream: o\n                } = Co(\"node:fs\"),\n                t = o(i),\n                r = [];\n              var _iteratorAbruptCompletion = false;\n              var _didIteratorError = false;\n              var _iteratorError;\n              try {\n                for (var _iterator = _asyncIterator(t), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                  let n = _step.value;\n                  {\n                    r.push(n);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (_iteratorAbruptCompletion && _iterator.return != null) {\n                    yield _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n              return new Uint8Array(Buffer.concat(r));\n            }\n            throw e;\n          } else {\n            let e = yield fetch(i);\n            if (!e.ok) throw new Error(`failed to load external data file: ${i}`);\n            let o = e.headers.get(\"Content-Length\"),\n              t = o ? parseInt(o, 10) : 0;\n            if (t < 1073741824) return new Uint8Array(yield e.arrayBuffer());\n            {\n              if (!e.body) throw new Error(`failed to load external data file: ${i}, no response body.`);\n              let r = e.body.getReader(),\n                n;\n              try {\n                n = new ArrayBuffer(t);\n              } catch (a) {\n                if (a instanceof RangeError) {\n                  let u = Math.ceil(t / 65536);\n                  n = new WebAssembly.Memory({\n                    initial: u,\n                    maximum: u\n                  }).buffer;\n                } else throw a;\n              }\n              let s = 0;\n              for (;;) {\n                let {\n                  done: a,\n                  value: u\n                } = yield r.read();\n                if (a) break;\n                let l = u.byteLength;\n                new Uint8Array(n, s, l).set(u), s += l;\n              }\n              return new Uint8Array(n, 0, t);\n            }\n          }\n        } else return i instanceof Blob ? new Uint8Array(yield i.arrayBuffer()) : i instanceof Uint8Array ? i : new Uint8Array(i);\n      });\n      return function jr(_x16) {\n        return _ref16.apply(this, arguments);\n      };\n    }();\n  });\nvar Cg,\n  ao,\n  so,\n  yr,\n  Ng,\n  zr,\n  uo,\n  lo,\n  ed,\n  fo,\n  co,\n  po,\n  qi = O(() => {\n    \"use strict\";\n\n    Xp();\n    Jp();\n    Ji();\n    Ke();\n    mo();\n    Yi();\n    Cg = (i, e) => {\n      xt()._OrtInit(i, e) !== 0 && ht(\"Can't initialize onnxruntime.\");\n    }, ao = /*#__PURE__*/function () {\n      var _ref17 = _asyncToGenerator(function* (i) {\n        Cg(i.wasm.numThreads, Qp(i.logLevel));\n      });\n      return function ao(_x17) {\n        return _ref17.apply(this, arguments);\n      };\n    }(), so = /*#__PURE__*/function () {\n      var _ref18 = _asyncToGenerator(function* (i, e) {});\n      return function so(_x18, _x19) {\n        return _ref18.apply(this, arguments);\n      };\n    }(), yr = new Map(), Ng = i => {\n      let e = xt(),\n        o = e.stackSave();\n      try {\n        let t = e.stackAlloc(8);\n        return e._OrtGetInputOutputCount(i, t, t + 4) !== 0 && ht(\"Can't get session input/output count.\"), [e.HEAP32[t / 4], e.HEAP32[t / 4 + 1]];\n      } finally {\n        e.stackRestore(o);\n      }\n    }, zr = i => {\n      let e = xt(),\n        o = e._malloc(i.byteLength);\n      if (o === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${i.byteLength}.`);\n      return e.HEAPU8.set(i, o), [o, i.byteLength];\n    }, uo = /*#__PURE__*/function () {\n      var _ref19 = _asyncToGenerator(function* (i, e) {\n        let o,\n          t,\n          r = xt();\n        Array.isArray(i) ? [o, t] = i : i.buffer === r.HEAPU8.buffer ? [o, t] = [i.byteOffset, i.byteLength] : [o, t] = zr(i);\n        let n = 0,\n          s = 0,\n          a = 0,\n          u = [],\n          l = [],\n          f = [];\n        try {\n          if ([s, u] = Kp(e), e?.externalData && r.mountExternalData) {\n            let P = [];\n            for (let A of e.externalData) {\n              let M = typeof A == \"string\" ? A : A.path;\n              P.push(jr(typeof A == \"string\" ? A : A.data).then(V => {\n                r.mountExternalData(M, V);\n              }));\n            }\n            yield Promise.all(P);\n          }\n          for (let P of e?.executionProviders ?? []) if ((typeof P == \"string\" ? P : P.name) === \"webnn\") {\n            if (r.shouldTransferToMLTensor = !1, r.currentContext) throw new Error(\"WebNN execution provider is already set.\");\n            if (typeof P != \"string\") {\n              let M = P,\n                V = M?.context,\n                lt = M?.gpuDevice,\n                wt = M?.deviceType,\n                et = M?.numThreads,\n                Dt = M?.powerPreference;\n              V ? r.currentContext = V : lt ? r.currentContext = yield navigator.ml.createContext(lt) : r.currentContext = yield navigator.ml.createContext({\n                deviceType: wt,\n                numThreads: et,\n                powerPreference: Dt\n              });\n            } else r.currentContext = yield navigator.ml.createContext();\n            break;\n          }\n          n = yield r._OrtCreateSession(o, t, s), n === 0 && ht(\"Can't create a session.\"), r.currentContext && (r.jsepRegisterMLContext(n, r.currentContext), r.currentContext = void 0, r.shouldTransferToMLTensor = !0);\n          let [p, d] = Ng(n),\n            y = !!e?.enableGraphCapture,\n            T = [],\n            v = [],\n            S = [];\n          for (let P = 0; P < p; P++) {\n            let A = r._OrtGetInputName(n, P);\n            A === 0 && ht(\"Can't get an input name.\"), l.push(A), T.push(r.UTF8ToString(A));\n          }\n          for (let P = 0; P < d; P++) {\n            let A = r._OrtGetOutputName(n, P);\n            A === 0 && ht(\"Can't get an output name.\"), f.push(A);\n            let M = r.UTF8ToString(A);\n            v.push(M);\n          }\n          let L = null;\n          return yr.set(n, [n, l, f, L, y, !1]), [n, T, v];\n        } catch (p) {\n          throw l.forEach(d => r._OrtFree(d)), f.forEach(d => r._OrtFree(d)), a !== 0 && r._OrtReleaseBinding(a), n !== 0 && r._OrtReleaseSession(n), p;\n        } finally {\n          r._free(o), s !== 0 && r._OrtReleaseSessionOptions(s), u.forEach(p => r._free(p)), r.unmountExternalData?.();\n        }\n      });\n      return function uo(_x20, _x21) {\n        return _ref19.apply(this, arguments);\n      };\n    }(), lo = i => {\n      let e = xt(),\n        o = yr.get(i);\n      if (!o) throw new Error(`cannot release session. invalid session id: ${i}`);\n      let [t, r, n, s, a] = o;\n      s && (a && e._OrtClearBoundOutputs(s.handle), e._OrtReleaseBinding(s.handle)), e.jsepOnReleaseSession?.(i), r.forEach(u => e._OrtFree(u)), n.forEach(u => e._OrtFree(u)), e._OrtReleaseSession(t), yr.delete(i);\n    }, ed = (i, e, o, t, r, n = !1) => {\n      if (!i) {\n        e.push(0);\n        return;\n      }\n      let s = xt(),\n        a = i[0],\n        u = i[1],\n        l = i[3],\n        f,\n        p;\n      if (a === \"string\" && (l === \"gpu-buffer\" || l === \"ml-tensor\")) throw new Error(\"String tensor is not supported on GPU.\");\n      if (n && l !== \"gpu-buffer\") throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);\n      if (l === \"gpu-buffer\") {\n        let T = i[2].gpuBuffer;\n        p = qr(Hr(a), u);\n        let v = s.jsepRegisterBuffer;\n        if (!v) throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n        f = v(t, r, T, p);\n      } else if (l === \"ml-tensor\") {\n        let T = i[2].mlTensor;\n        p = qr(Hr(a), u);\n        let v = s.jsepRegisterMLTensor;\n        if (!v) throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n        f = v(T, Hr(a), u);\n      } else {\n        let T = i[2];\n        if (Array.isArray(T)) {\n          p = 4 * T.length, f = s._malloc(p), o.push(f);\n          let v = f / 4;\n          for (let S = 0; S < T.length; S++) {\n            if (typeof T[S] != \"string\") throw new TypeError(`tensor data at index ${S} is not a string`);\n            s.HEAPU32[v++] = Tt(T[S], o);\n          }\n        } else p = T.byteLength, f = s._malloc(p), o.push(f), s.HEAPU8.set(new Uint8Array(T.buffer, T.byteOffset, p), f);\n      }\n      let d = s.stackSave(),\n        y = s.stackAlloc(4 * u.length);\n      try {\n        let T = y / 4;\n        u.forEach(S => s.HEAP32[T++] = S);\n        let v = s._OrtCreateTensor(Hr(a), f, p, y, u.length, td(l));\n        v === 0 && ht(`Can't create tensor for input/output. session=${t}, index=${r}.`), e.push(v);\n      } finally {\n        s.stackRestore(d);\n      }\n    }, fo = /*#__PURE__*/function () {\n      var _ref20 = _asyncToGenerator(function* (i, e, o, t, r, n) {\n        let s = xt(),\n          a = yr.get(i);\n        if (!a) throw new Error(`cannot run inference. invalid session id: ${i}`);\n        let u = a[0],\n          l = a[1],\n          f = a[2],\n          p = a[3],\n          d = a[4],\n          y = a[5],\n          T = e.length,\n          v = t.length,\n          S = 0,\n          L = [],\n          P = [],\n          A = [],\n          M = [],\n          V = s.stackSave(),\n          lt = s.stackAlloc(T * 4),\n          wt = s.stackAlloc(T * 4),\n          et = s.stackAlloc(v * 4),\n          Dt = s.stackAlloc(v * 4);\n        try {\n          s.jsepOnRunStart?.(u), [S, L] = jp(n);\n          for (let Z = 0; Z < T; Z++) ed(o[Z], P, M, i, e[Z], d);\n          for (let Z = 0; Z < v; Z++) ed(r[Z], A, M, i, T + t[Z], d);\n          let _t = lt / 4,\n            C = wt / 4,\n            Kr = et / 4,\n            we = Dt / 4;\n          for (let Z = 0; Z < T; Z++) s.HEAPU32[_t++] = P[Z], s.HEAPU32[C++] = l[e[Z]];\n          for (let Z = 0; Z < v; Z++) s.HEAPU32[Kr++] = A[Z], s.HEAPU32[we++] = f[t[Z]];\n          let oe;\n          oe = yield s._OrtRun(u, wt, lt, T, Dt, v, et, S), oe !== 0 && ht(\"failed to call OrtRun().\");\n          let be = [];\n          for (let Z = 0; Z < v; Z++) {\n            let ge = s.HEAPU32[et / 4 + Z];\n            if (ge === A[Z]) {\n              be.push(r[Z]);\n              continue;\n            }\n            let ie = s.stackSave(),\n              ae = s.stackAlloc(4 * 4),\n              se = !1,\n              it,\n              Lt = 0;\n            try {\n              s._OrtGetTensorData(ge, ae, ae + 4, ae + 8, ae + 12) !== 0 && ht(`Can't access output tensor data on index ${Z}.`);\n              let Ye = ae / 4,\n                ue = s.HEAPU32[Ye++];\n              Lt = s.HEAPU32[Ye++];\n              let Ze = s.HEAPU32[Ye++],\n                De = s.HEAPU32[Ye++],\n                le = [];\n              for (let gt = 0; gt < De; gt++) le.push(s.HEAPU32[Ze / 4 + gt]);\n              s._OrtFree(Ze);\n              let Mt = le.reduce((gt, Ot) => gt * Ot, 1);\n              it = Yp(ue);\n              let ve = p?.outputPreferredLocations[t[Z]];\n              if (it === \"string\") {\n                if (ve === \"gpu-buffer\" || ve === \"ml-tensor\") throw new Error(\"String tensor is not supported on GPU.\");\n                let gt = [],\n                  Ot = Lt / 4;\n                for (let Jt = 0; Jt < Mt; Jt++) {\n                  let wr = s.HEAPU32[Ot++],\n                    Yr = Jt === Mt - 1 ? void 0 : s.HEAPU32[Ot] - wr;\n                  gt.push(s.UTF8ToString(wr, Yr));\n                }\n                be.push([it, le, gt, \"cpu\"]);\n              } else if (ve === \"gpu-buffer\" && Mt > 0) {\n                let gt = s.jsepGetBuffer;\n                if (!gt) throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n                let Ot = gt(Lt),\n                  Jt = qr(ue, Mt);\n                if (Jt === void 0 || !bo(it)) throw new Error(`Unsupported data type: ${it}`);\n                se = !0, be.push([it, le, {\n                  gpuBuffer: Ot,\n                  download: s.jsepCreateDownloader(Ot, Jt, it),\n                  dispose: () => {\n                    s._OrtReleaseTensor(ge);\n                  }\n                }, \"gpu-buffer\"]);\n              } else if (ve === \"ml-tensor\" && Mt > 0) {\n                let gt = s.jsepEnsureTensor;\n                if (!gt) throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n                if (qr(ue, Mt) === void 0 || !go(it)) throw new Error(`Unsupported data type: ${it}`);\n                let Jt = yield gt(Lt, ue, le, !1);\n                se = !0, be.push([it, le, {\n                  mlTensor: Jt,\n                  download: s.jsepCreateMLTensorDownloader(Lt, it),\n                  dispose: () => {\n                    s.jsepReleaseTensorId(Lt), s._OrtReleaseTensor(ge);\n                  }\n                }, \"ml-tensor\"]);\n              } else {\n                let gt = Zp(it),\n                  Ot = new gt(Mt);\n                new Uint8Array(Ot.buffer, Ot.byteOffset, Ot.byteLength).set(s.HEAPU8.subarray(Lt, Lt + Ot.byteLength)), be.push([it, le, Ot, \"cpu\"]);\n              }\n            } finally {\n              s.stackRestore(ie), it === \"string\" && Lt && s._free(Lt), se || s._OrtReleaseTensor(ge);\n            }\n          }\n          return p && !d && (s._OrtClearBoundOutputs(p.handle), yr.set(i, [u, l, f, p, d, !1])), be;\n        } finally {\n          s.stackRestore(V), P.forEach(_t => s._OrtReleaseTensor(_t)), A.forEach(_t => s._OrtReleaseTensor(_t)), M.forEach(_t => s._free(_t)), S !== 0 && s._OrtReleaseRunOptions(S), L.forEach(_t => s._free(_t));\n        }\n      });\n      return function fo(_x22, _x23, _x24, _x25, _x26, _x27) {\n        return _ref20.apply(this, arguments);\n      };\n    }(), co = i => {\n      let e = xt(),\n        o = yr.get(i);\n      if (!o) throw new Error(\"invalid session id\");\n      let t = o[0],\n        r = e._OrtEndProfiling(t);\n      r === 0 && ht(\"Can't get an profile file name.\"), e._OrtFree(r);\n    }, po = i => {\n      let e = [];\n      for (let o of i) {\n        let t = o[2];\n        !Array.isArray(t) && \"buffer\" in t && e.push(t.buffer);\n      }\n      return e;\n    };\n  });\nvar Je,\n  Kt,\n  Xr,\n  xo,\n  To,\n  yo,\n  Zi,\n  Qi,\n  xr,\n  Tr,\n  Gg,\n  rd,\n  nd,\n  od,\n  id,\n  ad,\n  sd,\n  ud,\n  ta = O(() => {\n    \"use strict\";\n\n    Yt();\n    qi();\n    Ke();\n    Vr();\n    Je = () => !!z.wasm.proxy && typeof document < \"u\", Xr = !1, xo = !1, To = !1, Qi = new Map(), xr = (i, e) => {\n      let o = Qi.get(i);\n      o ? o.push(e) : Qi.set(i, [e]);\n    }, Tr = () => {\n      if (Xr || !xo || To || !Kt) throw new Error(\"worker not ready\");\n    }, Gg = i => {\n      switch (i.data.type) {\n        case \"init-wasm\":\n          Xr = !1, i.data.err ? (To = !0, Zi[1](i.data.err)) : (xo = !0, Zi[0]()), yo && (URL.revokeObjectURL(yo), yo = void 0);\n          break;\n        case \"init-ep\":\n        case \"copy-from\":\n        case \"create\":\n        case \"release\":\n        case \"run\":\n        case \"end-profiling\":\n          {\n            let e = Qi.get(i.data.type);\n            i.data.err ? e.shift()[1](i.data.err) : e.shift()[0](i.data.out);\n            break;\n          }\n        default:\n      }\n    }, rd = /*#__PURE__*/function () {\n      var _ref21 = _asyncToGenerator(function* () {\n        if (!xo) {\n          if (Xr) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n          if (To) throw new Error(\"previous call to 'initWasm()' failed.\");\n          if (Xr = !0, Je()) return new Promise((i, e) => {\n            Kt?.terminate(), Wp().then(([o, t]) => {\n              try {\n                Kt = t, Kt.onerror = n => e(n), Kt.onmessage = Gg, Zi = [i, e];\n                let r = {\n                  type: \"init-wasm\",\n                  in: z\n                };\n                Kt.postMessage(r), yo = o;\n              } catch (r) {\n                e(r);\n              }\n            }, e);\n          });\n          try {\n            yield io(z.wasm), yield ao(z), xo = !0;\n          } catch (i) {\n            throw To = !0, i;\n          } finally {\n            Xr = !1;\n          }\n        }\n      });\n      return function rd() {\n        return _ref21.apply(this, arguments);\n      };\n    }(), nd = /*#__PURE__*/function () {\n      var _ref22 = _asyncToGenerator(function* (i) {\n        if (Je()) return Tr(), new Promise((e, o) => {\n          xr(\"init-ep\", [e, o]);\n          let t = {\n            type: \"init-ep\",\n            in: {\n              epName: i,\n              env: z\n            }\n          };\n          Kt.postMessage(t);\n        });\n        yield so(z, i);\n      });\n      return function nd(_x28) {\n        return _ref22.apply(this, arguments);\n      };\n    }(), od = /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator(function* (i) {\n        return Je() ? (Tr(), new Promise((e, o) => {\n          xr(\"copy-from\", [e, o]);\n          let t = {\n            type: \"copy-from\",\n            in: {\n              buffer: i\n            }\n          };\n          Kt.postMessage(t, [i.buffer]);\n        })) : zr(i);\n      });\n      return function od(_x29) {\n        return _ref23.apply(this, arguments);\n      };\n    }(), id = /*#__PURE__*/function () {\n      var _ref24 = _asyncToGenerator(function* (i, e) {\n        if (Je()) {\n          if (e?.preferredOutputLocation) throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n          return Tr(), new Promise((o, t) => {\n            xr(\"create\", [o, t]);\n            let r = {\n                type: \"create\",\n                in: {\n                  model: i,\n                  options: {\n                    ...e\n                  }\n                }\n              },\n              n = [];\n            i instanceof Uint8Array && n.push(i.buffer), Kt.postMessage(r, n);\n          });\n        } else return uo(i, e);\n      });\n      return function id(_x30, _x31) {\n        return _ref24.apply(this, arguments);\n      };\n    }(), ad = /*#__PURE__*/function () {\n      var _ref25 = _asyncToGenerator(function* (i) {\n        if (Je()) return Tr(), new Promise((e, o) => {\n          xr(\"release\", [e, o]);\n          let t = {\n            type: \"release\",\n            in: i\n          };\n          Kt.postMessage(t);\n        });\n        lo(i);\n      });\n      return function ad(_x32) {\n        return _ref25.apply(this, arguments);\n      };\n    }(), sd = /*#__PURE__*/function () {\n      var _ref26 = _asyncToGenerator(function* (i, e, o, t, r, n) {\n        if (Je()) {\n          if (o.some(s => s[3] !== \"cpu\")) throw new Error(\"input tensor on GPU is not supported for proxy.\");\n          if (r.some(s => s)) throw new Error(\"pre-allocated output tensor is not supported for proxy.\");\n          return Tr(), new Promise((s, a) => {\n            xr(\"run\", [s, a]);\n            let u = o,\n              l = {\n                type: \"run\",\n                in: {\n                  sessionId: i,\n                  inputIndices: e,\n                  inputs: u,\n                  outputIndices: t,\n                  options: n\n                }\n              };\n            Kt.postMessage(l, po(u));\n          });\n        } else return fo(i, e, o, t, r, n);\n      });\n      return function sd(_x33, _x34, _x35, _x36, _x37, _x38) {\n        return _ref26.apply(this, arguments);\n      };\n    }(), ud = /*#__PURE__*/function () {\n      var _ref27 = _asyncToGenerator(function* (i) {\n        if (Je()) return Tr(), new Promise((e, o) => {\n          xr(\"end-profiling\", [e, o]);\n          let t = {\n            type: \"end-profiling\",\n            in: i\n          };\n          Kt.postMessage(t);\n        });\n        co(i);\n      });\n      return function ud(_x39) {\n        return _ref27.apply(this, arguments);\n      };\n    }();\n  });\nvar ld,\n  Mg,\n  wo,\n  fd = O(() => {\n    \"use strict\";\n\n    Yt();\n    ta();\n    Ji();\n    oo();\n    Yi();\n    ld = (i, e) => {\n      switch (i.location) {\n        case \"cpu\":\n          return [i.type, i.dims, i.data, \"cpu\"];\n        case \"gpu-buffer\":\n          return [i.type, i.dims, {\n            gpuBuffer: i.gpuBuffer\n          }, \"gpu-buffer\"];\n        case \"ml-tensor\":\n          return [i.type, i.dims, {\n            mlTensor: i.mlTensor\n          }, \"ml-tensor\"];\n        default:\n          throw new Error(`invalid data location: ${i.location} for ${e()}`);\n      }\n    }, Mg = i => {\n      switch (i[3]) {\n        case \"cpu\":\n          return new yt(i[0], i[2], i[1]);\n        case \"gpu-buffer\":\n          {\n            let e = i[0];\n            if (!bo(e)) throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);\n            let {\n              gpuBuffer: o,\n              download: t,\n              dispose: r\n            } = i[2];\n            return yt.fromGpuBuffer(o, {\n              dataType: e,\n              dims: i[1],\n              download: t,\n              dispose: r\n            });\n          }\n        case \"ml-tensor\":\n          {\n            let e = i[0];\n            if (!go(e)) throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);\n            let {\n              mlTensor: o,\n              download: t,\n              dispose: r\n            } = i[2];\n            return yt.fromMLTensor(o, {\n              dataType: e,\n              dims: i[1],\n              download: t,\n              dispose: r\n            });\n          }\n        default:\n          throw new Error(`invalid data location: ${i[3]}`);\n      }\n    }, wo = class {\n      fetchModelAndCopyToWasmMemory(e) {\n        return _asyncToGenerator(function* () {\n          return od(yield jr(e));\n        })();\n      }\n      loadModel(e, o) {\n        var _this26 = this;\n        return _asyncToGenerator(function* () {\n          Fe();\n          let t;\n          typeof e == \"string\" ? !1 ? t = yield jr(e) : t = yield _this26.fetchModelAndCopyToWasmMemory(e) : t = e, [_this26.sessionId, _this26.inputNames, _this26.outputNames] = yield id(t, o), Ce();\n        })();\n      }\n      dispose() {\n        var _this27 = this;\n        return _asyncToGenerator(function* () {\n          return ad(_this27.sessionId);\n        })();\n      }\n      run(e, o, t) {\n        var _this28 = this;\n        return _asyncToGenerator(function* () {\n          Fe();\n          let r = [],\n            n = [];\n          Object.entries(e).forEach(d => {\n            let y = d[0],\n              T = d[1],\n              v = _this28.inputNames.indexOf(y);\n            if (v === -1) throw new Error(`invalid input '${y}'`);\n            r.push(T), n.push(v);\n          });\n          let s = [],\n            a = [];\n          Object.entries(o).forEach(d => {\n            let y = d[0],\n              T = d[1],\n              v = _this28.outputNames.indexOf(y);\n            if (v === -1) throw new Error(`invalid output '${y}'`);\n            s.push(T), a.push(v);\n          });\n          let u = r.map((d, y) => ld(d, () => `input \"${_this28.inputNames[n[y]]}\"`)),\n            l = s.map((d, y) => d ? ld(d, () => `output \"${_this28.outputNames[a[y]]}\"`) : null),\n            f = yield sd(_this28.sessionId, n, u, a, l, t),\n            p = {};\n          for (let d = 0; d < f.length; d++) p[_this28.outputNames[a[d]]] = s[d] ?? Mg(f[d]);\n          return Ce(), p;\n        })();\n      }\n      startProfiling() {}\n      endProfiling() {\n        ud(this.sessionId);\n      }\n    };\n  });\nvar pd = {};\nOr(pd, {\n  OnnxruntimeWebAssemblyBackend: () => vo,\n  initializeFlags: () => cd,\n  wasmBackend: () => Ug\n});\nvar cd,\n  vo,\n  Ug,\n  dd = O(() => {\n    \"use strict\";\n\n    Yt();\n    ta();\n    fd();\n    Vr();\n    cd = () => {\n      if ((typeof z.wasm.initTimeout != \"number\" || z.wasm.initTimeout < 0) && (z.wasm.initTimeout = 0), z.wasm.simd === !1 && console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof z.wasm.proxy != \"boolean\" && (z.wasm.proxy = !1), typeof z.wasm.trace != \"boolean\" && (z.wasm.trace = !1), typeof z.wasm.numThreads != \"number\" || !Number.isInteger(z.wasm.numThreads) || z.wasm.numThreads <= 0) if (typeof self < \"u\" && !self.crossOriginIsolated) z.wasm.numThreads = 1;else {\n        let i = typeof navigator > \"u\" ? Co(\"node:os\").cpus().length : navigator.hardwareConcurrency;\n        z.wasm.numThreads = Math.min(4, Math.ceil((i || 1) / 2));\n      }\n    }, vo = class {\n      init(e) {\n        return _asyncToGenerator(function* () {\n          cd(), yield rd(), yield nd(e);\n        })();\n      }\n      createInferenceSessionHandler(e, o) {\n        return _asyncToGenerator(function* () {\n          let t = new wo();\n          return yield t.loadModel(e, o), Promise.resolve(t);\n        })();\n      }\n    }, Ug = new vo();\n  });\nYt();\nYt();\nYt();\nvar Ds = \"1.20.0\";\nvar mO = Mo;\n{\n  let i = (Fp(), sn(Bp)).onnxjsBackend;\n  nr(\"webgl\", i, -10);\n}\n{\n  let i = (dd(), sn(pd)).wasmBackend;\n  nr(\"cpu\", i, 10), nr(\"wasm\", i, 10);\n}\nObject.defineProperty(z.versions, \"web\", {\n  value: Ds,\n  enumerable: !0\n});\nexport { Yd as InferenceSession, Ts as TRACE, Fe as TRACE_FUNC_BEGIN, Ce as TRACE_FUNC_END, yt as Tensor, Qd as TrainingSession, mO as default, z as env, nr as registerBackend };\n/*! Bundled license information:\n\nlong/index.js:\n  (**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/\n//# sourceMappingURL=ort.bundle.min.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}